<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PlayFame Animation Codex</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Days+One&family=Lato:wght@400;500;600;700;900&display=swap"
    rel="stylesheet"
  />
  <style>

:root {
  --pf-base-0: #1d092f;
  --pf-base-5: #3a125d;
  --pf-base-10: #4e187c;
  --pf-base-20: #7a468e;
  --pf-base-30: #c47ae5;
  --pf-base-40: #d79af3;
  --pf-base-50: #ecc3ff;
  --pf-base-60: #efd7fa;
  --pf-base-70: #ceb6d8;
  --pf-base-95: #f2f2f2;
  --pf-white: #ffffff;
  --pf-brand-accent-primary: #c83558;
  --pf-brand-accent-secondary: #c6ff77;
  --pf-brand-gradient: linear-gradient(160deg, #4e187c 0%, #c47ae5 52%, #d79af3 100%);
  --pf-sweep-gradient: linear-gradient(-135deg, #1bee02 0.56%, #00ad45 100%);
  --pf-gold-gradient: linear-gradient(-135deg, #ffb300 4.17%, #f57c00 96.87%);
  --pf-surface: rgba(58, 18, 93, 0.65);
  --pf-surface-strong: rgba(33, 15, 49, 0.86);
  --pf-overlay: rgba(29, 9, 47, 0.8);
  --pf-shadow-elevated: 0 24px 64px rgba(0, 0, 0, 0.55);
  --pf-shadow-soft: 0 12px 28px rgba(0, 0, 0, 0.38);
  --pf-shadow-inner: inset 0 0 0 1px rgba(236, 195, 255, 0.08);
  --pf-text-primary: var(--pf-base-50);
  --pf-text-secondary: rgba(255, 255, 255, 0.76);
  --pf-text-tertiary: rgba(255, 255, 255, 0.54);
  --pf-radius-xs: 6px;
  --pf-radius-sm: 10px;
  --pf-radius-md: 12px;
  --pf-radius-lg: 16px;
  --pf-radius-pill: 999px;
  --pf-grid-gap: 18px;
  --pf-transition-fast: 160ms;
  --pf-transition-base: 280ms;
  --pf-transition-slow: 440ms;
}

*, *::before, *::after {
  box-sizing: border-box;
}

body {
  margin: 0;
  min-height: 100vh;
  font-family: 'Lato', helvetica, arial, sans-serif;
  background: radial-gradient(circle at 20% 20%, rgba(123, 70, 142, 0.45) 0%, rgba(29, 9, 47, 0.92) 52%, rgba(7, 2, 12, 0.98) 100%);
  color: var(--pf-text-primary);
  -webkit-font-smoothing: antialiased;
}

h1, h2, h3, h4 {
  font-family: 'Days One', 'Lato', sans-serif;
  letter-spacing: 0.01em;
  margin: 0;
}

button,
input,
select,
textarea {
  font-family: inherit;
}

a {
  color: inherit;
  text-decoration: none;
}

.pf-app {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  padding: 32px;
  gap: 28px;
}



.pf-logo {
  font-size: 28px;
  color: var(--pf-base-60);
  text-transform: uppercase;
  letter-spacing: 0.08em;
}

.pf-tagline {
  margin: 8px 0 0;
  color: var(--pf-text-secondary);
  font-weight: 500;
  line-height: 1.4;
}


.pf-button {
  padding: 12px 20px;
  border-radius: var(--pf-radius-pill);
  border: 1px solid rgba(236, 195, 255, 0.32);
  background: var(--pf-brand-gradient);
  color: var(--pf-white);
  font-weight: 600;
  cursor: pointer;
  transition: transform var(--pf-transition-fast) ease, box-shadow var(--pf-transition-fast) ease;
  box-shadow: 0 12px 32px rgba(200, 53, 88, 0.35);
}

.pf-button:active {
  transform: translateY(1px) scale(0.99);
}

.pf-toggle {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  color: var(--pf-text-secondary);
}

.pf-toggle input[type="checkbox"] {
  width: 44px;
  height: 24px;
  appearance: none;
  border-radius: var(--pf-radius-pill);
  background: rgba(236, 195, 255, 0.2);
  position: relative;
  cursor: pointer;
  transition: background var(--pf-transition-fast) ease;
}

.pf-toggle input[type="checkbox"]::after {
  content: '';
  position: absolute;
  top: 3px;
  left: 4px;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--pf-base-60);
  transition: transform var(--pf-transition-fast) ease;
}

.pf-toggle input[type="checkbox"]:checked {
  background: var(--pf-sweep-gradient);
}

.pf-toggle input[type="checkbox"]:checked::after {
  transform: translateX(18px);
  background: var(--pf-white);
}

.pf-tech-filter {
  display: inline-flex;
  align-items: center;
  padding: 6px;
  border-radius: var(--pf-radius-pill);
  background: rgba(236, 195, 255, 0.08);
  box-shadow: var(--pf-shadow-inner);
  gap: 6px;
}

.pf-chip {
  padding: 8px 16px;
  border-radius: var(--pf-radius-pill);
  border: 1px solid transparent;
  background: transparent;
  color: var(--pf-text-secondary);
  cursor: pointer;
  transition: background var(--pf-transition-fast) ease, color var(--pf-transition-fast) ease, border var(--pf-transition-fast) ease;
}

.pf-chip:hover {
  background: rgba(236, 195, 255, 0.12);
  color: var(--pf-base-60);
}

.pf-chip--active {
  background: rgba(200, 53, 88, 0.28);
  color: var(--pf-base-60);
  border-color: rgba(255, 255, 255, 0.18);
}

.pf-main {
  display: grid;
  grid-template-columns: 320px minmax(0, 1fr);
  gap: 32px;
  align-items: flex-start;
}

.pf-sidebar {
  position: sticky;
  top: 32px;
  align-self: start;
  display: flex;
  flex-direction: column;
  gap: 20px;
  padding: 20px;
  border-radius: var(--pf-radius-lg);
  background: rgba(33, 15, 49, 0.82);
  box-shadow: var(--pf-shadow-soft);
  max-height: calc(100vh - 64px);
  overflow: hidden;
}

.pf-sidebar__intro {
  display: grid;
  gap: 6px;
}

.pf-sidebar__controls {
  display: grid;
  gap: 12px;
  padding: 16px;
  border-radius: var(--pf-radius-md);
  background: rgba(78, 24, 124, 0.55);
  box-shadow: var(--pf-shadow-inner);
}


.pf-sidebar__controls .pf-button {
  width: 100%;
}

.pf-sidebar__controls .pf-toggle {
  justify-content: space-between;
}
.pf-sidebar__controls .pf-tech-filter {
  width: 100%;
  justify-content: space-between;
}

.pf-sidebar__nav {
  flex: 1;
  overflow-y: auto;
  display: grid;
  gap: 18px;
  padding-right: 4px;
}

.pf-sidebar__nav::-webkit-scrollbar {
  width: 6px;
}

.pf-sidebar__nav::-webkit-scrollbar-thumb {
  background: rgba(236, 195, 255, 0.18);
  border-radius: 999px;
}

.pf-sidebar__section {
  display: grid;
  gap: 10px;
}

.pf-sidebar__section-title {
  font-size: 13px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--pf-text-tertiary);
}

.pf-sidebar__link {
  padding: 10px 12px;
  border-radius: var(--pf-radius-md);
  background: transparent;
  border: 1px solid transparent;
  color: var(--pf-text-secondary);
  cursor: pointer;
  text-align: left;
  transition: background var(--pf-transition-fast) ease, border var(--pf-transition-fast) ease;
}

.pf-sidebar__link:hover,
.pf-sidebar__link.is-active {
  background: rgba(196, 122, 229, 0.16);
  border-color: rgba(236, 195, 255, 0.18);
  color: var(--pf-base-60);
}

.pf-catalog {
  display: flex;
  flex-direction: column;
  gap: 32px;
}

.pf-category {
  display: flex;
  flex-direction: column;
  gap: 18px;
  padding-bottom: 16px;
  border-bottom: 1px solid rgba(236, 195, 255, 0.16);
}

.pf-category__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}

.pf-category__title {
  font-size: 24px;
  color: var(--pf-base-60);
}

.pf-category__meta {
  display: flex;
  gap: 12px;
  font-size: 14px;
  color: var(--pf-text-tertiary);
}

.pf-group {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.pf-group__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: rgba(78, 24, 124, 0.55);
  padding: 12px 16px;
  border-radius: var(--pf-radius-md);
  box-shadow: var(--pf-shadow-inner);
}

.pf-group__title {
  font-size: 18px;
  color: var(--pf-base-60);
}

.pf-card-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: var(--pf-grid-gap);
}

.pf-card {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 18px;
  border-radius: var(--pf-radius-lg);
  background: linear-gradient(160deg, rgba(58, 18, 93, 0.86) 0%, rgba(33, 15, 49, 0.92) 100%);
  box-shadow: var(--pf-shadow-soft);
  border: 1px solid rgba(236, 195, 255, 0.1);
  position: relative;
}

.pf-card::after {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: inherit;
  pointer-events: none;
  background: linear-gradient(140deg, rgba(200, 53, 88, 0.15) 0%, rgba(198, 255, 119, 0.12) 100%);
  opacity: 0;
  transition: opacity var(--pf-transition-base) ease;
}

.pf-card:hover::after {
  opacity: 0
}

.pf-card__header {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
}

.pf-card__title {
  font-size: 16px;
  font-weight: 600;
  color: var(--pf-base-60);
}

.pf-card__meta {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: var(--pf-text-tertiary);
}

.pf-card__meta span {
  padding: 4px 10px;
  border-radius: var(--pf-radius-pill);
  background: rgba(236, 195, 255, 0.12);
  border: 1px solid rgba(236, 195, 255, 0.18);
}

.pf-card__description {
  font-size: 13px;
  color: var(--pf-text-secondary);
  line-height: 1.55;
}

.pf-card__actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: auto;
}

.pf-card__controls {
  display: flex;
  gap: 8px;
}

.pf-card button[data-role="play-card"] {
  padding: 8px 14px;
  border-radius: var(--pf-radius-pill);
  border: 1px solid rgba(236, 195, 255, 0.2);
  background: rgba(236, 195, 255, 0.08);
  color: var(--pf-base-60);
  cursor: pointer;
  transition: background var(--pf-transition-fast) ease;
}

.pf-card button[data-role="play-card"]:hover {
  background: rgba(236, 195, 255, 0.16);
}

.pf-demo-canvas {
  position: relative;
  overflow: visible;
  border-radius: var(--pf-radius-md);
  border: 1px solid rgba(236, 195, 255, 0.12);
  min-height: var(--pf-demo-height, 220px);
  background: rgba(29, 9, 47, 0.76);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
  padding: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.pf-demo-stage {
  position: relative;
  width: 100%;
  min-height: var(--pf-demo-height, 220px);
}

.pf-demo-stage--top {
  display: block;
}


.pf-demo-canvas[data-demo="modalBase"],
.pf-demo-canvas[data-demo="wizard"],
.pf-demo-canvas[data-demo="celebration"] {
  background: radial-gradient(circle at 50% 0%, rgba(236, 195, 255, 0.25), rgba(29, 9, 47, 0.92));
}

.pf-badge-tech {
  font-size: 12px;
  padding: 4px 10px;
  border-radius: var(--pf-radius-pill);
  background: rgba(198, 255, 119, 0.16);
  color: var(--pf-brand-accent-secondary);
  text-transform: uppercase;
  letter-spacing: 0.08em;
}

.pf-card[data-tech="framer"] .pf-badge-tech {
  background: rgba(200, 53, 88, 0.16);
  color: #ff9cc0;
}


.pf-modal-overlay {
  position: absolute;
  inset: 0;
  display: grid;
  place-items: center;
  background: rgba(29, 9, 47, 0);
}

.pf-modal {
  position: absolute;
  top: 50%;
  left: 50%;
  width: clamp(280px, 80%, 320px);
  background: rgba(33, 15, 49, 0.92);
  border-radius: 20px;
  padding: 20px 24px;
  box-shadow: 0 18px 40px rgba(0, 0, 0, 0.45), inset 0 0 0 1px rgba(236, 195, 255, 0.12);
  transform: translate(-50%, -50%);
}

.pf-modal__header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 12px;
}

.pf-modal__title {
  font-size: 18px;
  color: var(--pf-base-60);
}

.pf-modal__body {
  margin: 16px 0;
  display: grid;
  gap: 12px;
  color: var(--pf-text-secondary);
}

.pf-modal__footer {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}

.pf-button-primary {
  flex: 1;
  min-width: 120px;
  padding: 10px 16px;
  border-radius: var(--pf-radius-pill);
  border: none;
  background: var(--pf-brand-gradient);
  color: var(--pf-white);
  font-weight: 600;
  cursor: pointer;
}

.pf-button-secondary {
  flex: 1;
  min-width: 120px;
  padding: 10px 16px;
  border-radius: var(--pf-radius-pill);
  border: 1px solid rgba(236, 195, 255, 0.2);
  background: rgba(236, 195, 255, 0.08);
  color: var(--pf-base-60);
  cursor: pointer;
}

.pf-toast {
  min-width: 240px;
  padding: 16px 18px;
  border-radius: var(--pf-radius-md);
  background: rgba(78, 24, 124, 0.88);
  color: var(--pf-base-60);
  box-shadow: var(--pf-shadow-soft);
  position: relative;
}

.pf-toast__title {
  font-weight: 600;
  margin-bottom: 6px;
}

.pf-toast__progress {
  position: absolute;
  inset-inline: 12px;
  bottom: 10px;
  height: 4px;
  border-radius: var(--pf-radius-pill);
  background: rgba(236, 195, 255, 0.16);
  overflow: hidden;
}

.pf-toast__progress-bar {
  position: relative;
  width: 100%;
  height: 100%;
  background: var(--pf-sweep-gradient);
  transform-origin: left center;
  overflow: hidden;
}

.pf-toast__progress-outer {
  position: absolute;
  inset: 0;
  border-radius: inherit;
  pointer-events: none;
}

.pf-toast__progress-spark {
  position: absolute;
  top: 50%;
  right: 0;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  transform: translate(50%, -50%);
  background: radial-gradient(circle, rgba(255, 255, 255, 0.85) 0%, rgba(255, 255, 255, 0.25) 60%, transparent 100%);
  box-shadow: 0 0 16px rgba(255, 255, 255, 0.65);
  opacity: 0;
}

.pf-toast__burst-overlay {
  position: absolute;
  inset: -12px;
  border-radius: inherit;
  pointer-events: none;
  mix-blend-mode: screen;
  opacity: 0;
}

.pf-toast__burst-halo {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 140px;
  height: 140px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(255, 128, 162, 0.55), rgba(255, 128, 162, 0));
  transform: translate(-50%, -50%) scale(0.3);
  opacity: 0;
  filter: blur(4px);
}

.pf-toast__burst-spark {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 4px;
  height: 32px;
  border-radius: 999px;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.92) 0%, rgba(255, 99, 146, 0.65) 100%);
  transform-origin: center 90%;
  opacity: 0;
  filter: drop-shadow(0 0 6px rgba(255, 178, 208, 0.6));
}

.pf-toast__burst-dot {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(255, 214, 235, 0.85), rgba(255, 214, 235, 0));
  opacity: 0;
  filter: blur(1px);
}

.pf-progress-track {
  width: 100%;
  height: 12px;
  border-radius: var(--pf-radius-pill);
  background: rgba(236, 195, 255, 0.12);
  overflow: hidden;
  position: relative;
}

.pf-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #c47ae5 0%, #d79af3 100%);
  border-radius: inherit;
  transform-origin: left center;
  position: relative;
}

.pf-progress-fill--segmented {
  background-image: repeating-linear-gradient(90deg, #c47ae5 0, #c47ae5 20%, transparent 20%, transparent 22%);
}

.pf-progress-fill--striped {
  background-image: repeating-linear-gradient(
    45deg,
    transparent,
    transparent 10px,
    rgba(255, 255, 255, 0.1) 10px,
    rgba(255, 255, 255, 0.1) 20px
  );
  background-size: 28px 28px;
}

.pf-progress-fill--wave {
  animation: progress-wave 2s linear infinite;
}

@keyframes progress-wave {
  0% { background-position: 0 0; }
  100% { background-position: 200% 0; }
}

.pf-progress-fill--flare::after {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  width: 30px;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
  animation: progress-flare 1s ease-out;
}

@keyframes progress-flare {
  0% { opacity: 0; transform: translateX(-30px); }
  50% { opacity: 1; }
  100% { opacity: 0; transform: translateX(0); }
}

.pf-progress-milestones {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
  font-size: 11px;
  color: var(--pf-text-tertiary);
}

.pf-progress-demo {
  display: flex;
  flex-direction: column;
  gap: 12px;
  width: 100%;
}

.pf-progress-demo__label {
  font-size: 12px;
  color: var(--pf-text-secondary);
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.pf-milestone {
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 220px;
  padding: 28px;
  border-radius: var(--pf-radius-lg);
  background: radial-gradient(circle at 50% 0%, rgba(236, 195, 255, 0.18), rgba(29, 9, 47, 0.92));
  border: 1px solid rgba(236, 195, 255, 0.16);
  box-shadow: var(--pf-shadow-soft);
  overflow: hidden;
}

.pf-milestone__visuals {
  position: relative;
  width: 100%;
  max-width: 320px;
  display: grid;
  place-items: center;
  gap: 14px;
}

.pf-milestone__effects {
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 1;
}

.pf-milestone__glow {
  position: absolute;
  width: 260px;
  height: 260px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(236, 195, 255, 0.45), rgba(236, 195, 255, 0));
  filter: blur(6px);
  opacity: 0.32;
  transform: translate(-50%, -50%);
  top: 50%;
  left: 50%;
  z-index: 0;
}

.pf-milestone__content {
  position: relative;
  z-index: 2;
  display: grid;
  gap: 12px;
  place-items: center;
  text-align: center;
  color: var(--pf-base-60);
}

.pf-milestone__badge {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 6px 14px;
  border-radius: var(--pf-radius-pill);
  background: rgba(236, 195, 255, 0.18);
  border: 1px solid rgba(236, 195, 255, 0.28);
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--pf-base-60);
}

.pf-milestone__badge::before {
  content: '';
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--pf-milestone-accent, #c6ff77);
  box-shadow: 0 0 12px rgba(198, 255, 119, 0.45);
}

.pf-milestone__icon {
  font-size: 40px;
  line-height: 1;
  filter: drop-shadow(0 8px 20px rgba(0, 0, 0, 0.45));
}

.pf-milestone__headline {
  font-size: 26px;
  font-family: 'Days One', 'Lato', sans-serif;
  letter-spacing: 0.04em;
  text-transform: uppercase;
}

.pf-milestone__caption {
  font-size: 13px;
  color: var(--pf-text-secondary);
  opacity: 0.85;
}

.pf-milestone__spark,
.pf-milestone__star,
.pf-milestone__confetti,
.pf-milestone__light,
.pf-milestone__beam,
.pf-milestone__halo,
.pf-milestone__ring,
.pf-milestone__ribbon {
  position: absolute;
  pointer-events: none;
  transform-origin: center;
}

.pf-milestone__spark {
  width: 10px;
  height: 18px;
  border-radius: 999px;
  background: var(--pf-milestone-accent, #c6ff77);
  opacity: 0;
}

.pf-milestone__star {
  width: 14px;
  height: 14px;
  background: var(--pf-milestone-accent, #c6ff77);
  clip-path: polygon(50% 0%, 63% 35%, 100% 38%, 72% 60%, 82% 100%, 50% 78%, 18% 100%, 28% 60%, 0% 38%, 37% 35%);
  opacity: 0;
}

.pf-milestone__confetti {
  width: 8px;
  height: 16px;
  border-radius: 2px;
  background: var(--pf-milestone-accent, #47fff4);
  opacity: 0;
}

.pf-milestone__light {
  width: 12px;
  height: 80px;
  border-radius: 999px;
  background: linear-gradient(180deg, rgba(236, 195, 255, 0.6), rgba(236, 195, 255, 0));
  bottom: 18px;
  opacity: 0;
}

.pf-milestone__beam {
  width: 24px;
  height: 140px;
  border-radius: 999px;
  background: linear-gradient(180deg, rgba(255, 206, 26, 0.65), rgba(255, 206, 26, 0));
  opacity: 0;
}

.pf-milestone__halo {
  width: 220px;
  height: 220px;
  border-radius: 50%;
  border: 2px solid rgba(236, 195, 255, 0.35);
  opacity: 0;
}

.pf-milestone__ring {
  width: 200px;
  height: 200px;
  border-radius: 50%;
  border: 2px dashed rgba(236, 195, 255, 0.35);
  opacity: 0;
}

.pf-milestone__ribbon {
  width: 120px;
  height: 32px;
  border-radius: 999px;
  background: linear-gradient(135deg, rgba(236, 195, 255, 0.48), rgba(236, 195, 255, 0.12));
  opacity: 0;
}

.pf-milestone__ribbon--left {
  transform-origin: right center;
}

.pf-milestone__ribbon--right {
  transform-origin: left center;
}

/* Note: Primary loader styles are defined later in the file */

.pf-spinner {
  width: 48px;
  height: 48px;
  border: 4px solid rgba(236, 195, 255, 0.16);
  border-top-color: var(--pf-brand-accent-primary);
  border-radius: 50%;
}

.pf-spinner.is-animating {
  animation: pf-spinner 1s linear infinite;
}

.pf-spinner--dual-ring {
  position: relative;
}

.pf-spinner--dual-ring::after {
  content: '';
  position: absolute;
  width: 36px;
  height: 36px;
  top: 2px;
  left: 2px;
  border: 3px solid rgba(198,255,119,0.2);
  border-bottom-color: #c6ff77;
  border-radius: 50%;
  animation: spin-reverse 1.2s linear infinite;
}

.pf-spinner--orbital {
  position: relative;
  border: none;
  background: transparent;
}

.pf-spinner--orbital::before {
  content: '';
  position: absolute;
  width: 12px;
  height: 12px;
  background: #c47ae5;
  border-radius: 50%;
  top: -2px;
  left: calc(50% - 6px);
  box-shadow: 0 0 10px rgba(196,122,229,0.8);
}

.pf-spinner--galaxy {
  position: relative;
  background: radial-gradient(circle, rgba(236,195,255,0.1) 0%, transparent 70%);
  border-width: 2px;
  box-shadow: 0 0 20px rgba(196,122,229,0.3);
}

.pf-spinner--galaxy::before,
.pf-spinner--galaxy::after {
  content: '';
  position: absolute;
  border-radius: 50%;
}

.pf-spinner--galaxy::before {
  width: 8px;
  height: 8px;
  background: #c6ff77;
  top: 8px;
  left: 8px;
}

.pf-spinner--galaxy::after {
  width: 6px;
  height: 6px;
  background: #47fff4;
  bottom: 10px;
  right: 10px;
}

@keyframes spin-reverse {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(-360deg); }
}

@keyframes pf-skeleton-shimmer {
  0% {
    background-position: 200% 50%;
  }
  100% {
    background-position: -200% 50%;
  }
}

@keyframes pf-spinner {
  to {
    transform: rotate(360deg);
  }
}

.pf-demo-placeholder { color: var(--pf-text-tertiary); font-size: 13px; }
/* Modal content shells */
.pf-modal-list {
  display: grid;
  gap: 10px;
}

.pf-modal-list-item {
  padding: 10px 12px;
  border-radius: var(--pf-radius-sm);
  background: rgba(236, 195, 255, 0.08);
  border: 1px solid rgba(236, 195, 255, 0.12);
}

.pf-modal-form {
  display: grid;
  gap: 12px;
}

.pf-modal-field {
  display: grid;
  gap: 6px;
}

.pf-modal-field label {
  font-size: 12px;
  color: var(--pf-text-tertiary);
}

.pf-modal-field input {
  padding: 8px 12px;
  border-radius: var(--pf-radius-sm);
  border: 1px solid rgba(236, 195, 255, 0.18);
  background: rgba(236, 195, 255, 0.06);
  color: var(--pf-text-secondary);
}

.pf-modal-feedback {
  padding: 12px;
  border-radius: var(--pf-radius-md);
  background: rgba(250, 17, 79, 0.16);
  border: 1px solid rgba(250, 17, 79, 0.32);
  color: var(--pf-white);
}


.pf-wizard {
  width: 100%;
  display: grid;
  gap: 12px;
}

.pf-wizard__panels {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.pf-wizard__steps {
  display: flex;
  gap: 8px;
}

.pf-wizard__step {
  flex: 1;
  padding: 8px 12px;
  border-radius: var(--pf-radius-pill);
  background: rgba(236, 195, 255, 0.1);
  border: 1px solid rgba(236, 195, 255, 0.16);
  text-align: center;
  font-size: 12px;
  color: var(--pf-text-secondary);
  transition: transform 200ms ease;
}

.pf-wizard__panel {
  position: relative;
  padding: 16px;
  border-radius: var(--pf-radius-md);
  background: rgba(236, 195, 255, 0.08);
  border: 1px solid rgba(236, 195, 255, 0.12);
  color: var(--pf-text-secondary);
}

/* Loader styles */
.pf-loader {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 80px;
  width: 100%;
}

.pf-skeleton {
  display: flex;
  flex-direction: column;
  gap: 8px;
  width: 100%;
}

.pf-skeleton--horizontal {
  flex-direction: column;
}

.pf-skeleton--vertical {
  flex-direction: column;
  gap: 8px;
}

.pf-skeleton--grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
}

.pf-skeleton--card {
  flex-direction: column;
  gap: 8px;
  padding: 12px;
  background: rgba(236, 195, 255, 0.03);
  border-radius: var(--pf-radius-sm);
}

.pf-skeleton__line,
.pf-skeleton__tile {
  display: block;
  width: 100%;
  height: 12px;
  border-radius: var(--pf-radius-xs);
  background: linear-gradient(90deg, rgba(236, 195, 255, 0.05) 0%, rgba(236, 195, 255, 0.18) 40%, rgba(236, 195, 255, 0.05) 100%);
  background-size: 200% 100%;
  background-position: 200% 0;
  min-height: 12px;
}

.pf-skeleton__tile {
  height: 60px;
  min-height: 60px;
}

.pf-skeleton__tile {
  height: 80px;
  min-height: 80px;
}

.pf-skeleton.is-animating .pf-skeleton__line,
.pf-skeleton.is-animating .pf-skeleton__tile {
  animation: pf-skeleton-shimmer 1.4s ease-in-out infinite;
}

.pf-skeleton--vertical .pf-skeleton__line:nth-child(1) { width: 90%; }
.pf-skeleton--vertical .pf-skeleton__line:nth-child(2) { width: 75%; }
.pf-skeleton--vertical .pf-skeleton__line:nth-child(3) { width: 85%; }
.pf-skeleton--vertical .pf-skeleton__line:nth-child(4) { width: 70%; }
.pf-skeleton--vertical .pf-skeleton__line:nth-child(5) { width: 95%; }
.pf-skeleton--vertical .pf-skeleton__line:nth-child(6) { width: 80%; }

.pf-skeleton--card .pf-skeleton__line:first-child {
  height: 18px;
  width: 60%;
  margin-bottom: 12px;
}
.pf-skeleton--card .pf-skeleton__line:nth-child(2) { width: 85%; }
.pf-skeleton--card .pf-skeleton__line:nth-child(3) { width: 75%; }
.pf-skeleton--card .pf-skeleton__line:nth-child(4) { width: 90%; }

.pf-spinner {
  width: 48px;
  height: 48px;
  border-radius: 50%;
  border: 4px solid rgba(236, 195, 255, 0.16);
  border-top-color: var(--pf-brand-accent-primary);
}

.pf-spinner.is-animating {
  animation: pf-spinner 1s linear infinite;
}

.pf-spinner--orbital::after {
  content: '';
  position: absolute;
  inset: 8px;
  border-radius: 50%;
  border: 2px dashed rgba(236, 195, 255, 0.4);
}

.pf-dots {
  display: flex;
  gap: 8px;
}

.pf-dots span {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: rgba(236, 195, 255, 0.45);
}

.pf-dots.is-animating span {
  animation: pf-dots 1.2s ease-in-out infinite;
}

.pf-ring {
  position: relative;
  width: 60px;
  height: 60px;
  border-radius: 50%;
  border: 3px solid rgba(236, 195, 255, 0.18);
}

.pf-ring.is-animating {
  animation: pf-spinner 1.4s linear forwards;
}

.pf-ring__segment {
  position: absolute;
  inset: 8px;
  border-radius: 50%;
  border: 2px solid rgba(236, 195, 255, 0.3);
}


/* Celebration canvas */
.pf-celebration {
  position: relative;
  width: 100%;
  height: 220px;
  border-radius: var(--pf-radius-lg);
  background: radial-gradient(circle at 50% 0%, rgba(236, 195, 255, 0.18), rgba(29, 9, 47, 0.92));
  border: 1px solid rgba(236, 195, 255, 0.12);
  overflow: hidden;
}

.pf-celebration__layer {
  position: absolute;
  inset: 0;
  pointer-events: none;
}

.pf-celebration__confetti,
.pf-celebration__coin,
.pf-celebration__firework,
.pf-celebration__ring,
.pf-celebration__beam,
.pf-celebration__glow,
.pf-celebration__pulse {
  position: absolute;
  pointer-events: none;
  animation-fill-mode: forwards;
  animation-duration: var(--duration, 900ms);
  animation-delay: var(--delay, 0ms);
}

.pf-celebration__confetti {
  width: var(--size, 8px);
  height: var(--length, 16px);
  border-radius: 2px;
  opacity: 0;
}

.pf-celebration__coin {
  left: 50%;
  top: 60%;
  width: 22px;
  height: 22px;
  border-radius: 50%;
  background: var(--coin-color, var(--pf-gold-gradient));
  transform: translate(-50%, -50%);
  opacity: 0;
}

.pf-celebration__firework,
.pf-celebration__ring {
  left: 50%;
  top: 50%;
  border-radius: 50%;
  transform: translate(-50%, -50%) scale(0);
  opacity: 0;
}

.pf-celebration__firework {
  width: var(--size, 18px);
  height: var(--size, 18px);
  border: 2px solid var(--color, #ffce1a);
}

.pf-celebration__ring {
  width: 20px;
  height: 20px;
  border: 2px dashed rgba(236, 195, 255, 0.7);
}

.pf-celebration__beam {
  bottom: -20%;
  width: 80px;
  height: 240px;
  background: linear-gradient(180deg, rgba(198, 255, 119, 0.5), rgba(198, 255, 119, 0));
  transform-origin: bottom center;
  opacity: 0;
  filter: blur(1px);
  transform: rotate(var(--rotate, 0deg)) scaleY(0.2) translateY(30px);
}

.pf-celebration__glow {
  left: 50%;
  top: 60%;
  width: 160px;
  height: 160px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(255, 206, 26, 0.5), rgba(255, 206, 26, 0));
  transform: translate(-50%, -50%);
  opacity: 0.2;
}

.pf-celebration__pulse {
  left: 50%;
  top: 50%;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 2px solid rgba(236, 195, 255, 0.6);
  transform: translate(-50%, -50%) scale(0.2);
  opacity: 0;
}

.pf-celebration__stage {
  position: absolute;
  left: 50%;
  bottom: 12%;
  width: var(--stage-width, 140px);
  height: var(--stage-height, 44px);
  border-radius: 50%;
  background:
    radial-gradient(circle at 50% 28%, rgba(255, 255, 255, 0.75), rgba(255, 255, 255, 0))
    ,radial-gradient(circle at 50% 100%, var(--stage-color, rgba(198, 255, 119, 0.28)), rgba(198, 255, 119, 0));
  transform: translate(-50%, 26px) scale(0.72);
  opacity: 0;
  box-shadow: 0 22px 38px rgba(8, 0, 26, 0.5);
  overflow: hidden;
  mix-blend-mode: screen;
  animation: celebration-stage-rise 520ms cubic-bezier(0.17, 0.82, 0.26, 1.1) forwards;
}

.pf-celebration__stage::after {
  content: '';
  position: absolute;
  inset: 18% 18% 36% 18%;
  border-radius: inherit;
  background: radial-gradient(circle, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0));
  opacity: 0.85;
}

.pf-celebration__stage-inner {
  position: absolute;
  inset: 28% 24% 42% 24%;
  border-radius: inherit;
  background: radial-gradient(circle, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0));
  filter: blur(2px);
}

.pf-celebration__stage-glow {
  position: absolute;
  left: 50%;
  bottom: 26%;
  width: var(--stage-glow-width, 124px);
  height: var(--stage-glow-height, 200px);
  transform: translate(-50%, 24px) scale(0.8);
  background: radial-gradient(circle at 50% 0%, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));
  filter: blur(14px);
  mix-blend-mode: screen;
  opacity: 0;
  animation: celebration-stage-glow var(--duration, 1600ms) ease forwards;
}

.pf-celebration__stage-glow--emerald {
  background: radial-gradient(circle at 50% 0%, rgba(198, 255, 119, 0.9), rgba(198, 255, 119, 0));
}

.pf-celebration__stage-glow--gold {
  background: radial-gradient(circle at 50% 0%, rgba(255, 206, 26, 0.92), rgba(255, 206, 26, 0));
}

.pf-celebration__sparkle {
  position: absolute;
  width: var(--size, 8px);
  height: var(--size, 8px);
  border-radius: 50%;
  background: radial-gradient(circle, var(--sparkle-color, rgba(255, 255, 255, 0.95)) 0%, rgba(255, 255, 255, 0));
  opacity: 0;
  transform: translate(-50%, -50%) scale(0.6);
  mix-blend-mode: screen;
  animation-fill-mode: forwards;
  animation-duration: var(--duration, 1200ms);
  animation-delay: var(--delay, 0ms);
}

.pf-celebration__sparkle--rise {
  animation-name: celebration-sparkle-rise;
}

.pf-celebration__sparkle--pop {
  animation-name: celebration-sparkle-pop;
}

.pf-celebration--confetti-burst .pf-celebration__confetti { animation-name: celebration-confetti-burst; }
.pf-celebration--confetti-fan .pf-celebration__confetti { animation-name: celebration-confetti-fan; }
.pf-celebration--confetti-spiral .pf-celebration__confetti { animation-name: celebration-confetti-spiral; }
.pf-celebration--confetti-rain .pf-celebration__confetti { animation-name: celebration-confetti-rain; }
.pf-celebration--confetti-pulse .pf-celebration__confetti { animation-name: celebration-confetti-burst; }

.pf-celebration--coins-arc .pf-celebration__coin { animation-name: celebration-coin-arc; }
.pf-celebration--coins-fountain .pf-celebration__coin { animation-name: celebration-coin-fountain; }
.pf-celebration--coins-swirl .pf-celebration__coin { animation-name: celebration-coin-swirl; }

.pf-celebration--fireworks-triple .pf-celebration__firework { animation-name: celebration-firework-pop; }
.pf-celebration--fireworks-ring .pf-celebration__ring { animation-name: celebration-firework-ring; }
.pf-celebration--reward-spotlight .pf-celebration__beam { animation-name: celebration-spotlight; }
.pf-celebration--reward-spotlight .pf-celebration__stage {
  --stage-color: rgba(198, 255, 119, 0.36);
  --stage-width: 152px;
  --stage-height: 48px;
}
.pf-celebration--reward-spotlight .pf-celebration__stage-glow {
  --stage-glow-width: 156px;
  --stage-glow-height: 224px;
}
.pf-celebration--reward-spotlight .pf-celebration__sparkle {
  --sparkle-color: rgba(255, 255, 255, 0.95);
}
.pf-celebration--jackpot-celebration .pf-celebration__glow { animation-name: celebration-jackpot-glow; }
.pf-celebration--jackpot-celebration .pf-celebration__stage {
  --stage-color: rgba(255, 206, 26, 0.52);
  --stage-width: 180px;
  --stage-height: 56px;
}
.pf-celebration--jackpot-celebration .pf-celebration__stage-glow {
  --stage-glow-width: 178px;
  --stage-glow-height: 232px;
}
.pf-celebration--jackpot-celebration .pf-celebration__sparkle {
  --sparkle-color: rgba(255, 206, 26, 0.95);
}
.pf-celebration--jackpot-celebration .pf-celebration__coin { animation-name: celebration-coin-fountain; }
.pf-celebration--confetti-pulse .pf-celebration__pulse { animation-name: celebration-pulse; }

@keyframes celebration-confetti-burst {
  0% { transform: translate(0, 0) scale(0.6) rotate(0deg); opacity: 0; }
  20% { opacity: 1; }
  100% { transform: translate(var(--tx, 0px), var(--ty, -160px)) scale(1) rotate(var(--rot, 0deg)); opacity: 0; }
}

@keyframes celebration-confetti-fan {
  0% { transform: translate(0, 0) scale(0.6); opacity: 0; }
  20% { opacity: 1; }
  100% { transform: translate(var(--tx, 0px), var(--ty, 160px)) scale(1) rotate(var(--rot, 0deg)); opacity: 0; }
}

@keyframes celebration-confetti-spiral {
  0% { transform: rotate(var(--angle, 0deg)) translateX(0) scale(0.4); opacity: 0; }
  20% { opacity: 1; }
  100% { transform: rotate(calc(var(--angle, 0deg) + var(--spin, 360deg))) translateX(var(--radius, 120px)) scale(1); opacity: 0; }
}

@keyframes celebration-confetti-rain {
  0% { transform: translateY(-160px) translateX(var(--dx, 0px)); opacity: 0; }
  15% { opacity: 1; }
  100% { transform: translateY(220px) translateX(calc(var(--dx, 0px) + var(--drift, 0px))); opacity: 0; }
}

@keyframes celebration-coin-arc {
  0% { transform: translate(-50%, -50%) translate(0, 0) scale(0.6); opacity: 0; }
  15% { opacity: 1; }
  100% { transform: translate(-50%, -50%) translate(var(--tx, 0px), var(--ty, -140px)) scale(1); opacity: 0; }
}

@keyframes celebration-coin-fountain {
  0% { transform: translate(-50%, -50%) translate(0, 0) scale(0.6); opacity: 0; }
  20% { opacity: 1; }
  60% { transform: translate(-50%, -50%) translate(var(--tx, 0px), var(--ty, -160px)) scale(1); opacity: 1; }
  100% { transform: translate(-50%, -50%) translate(calc(var(--tx, 0px) * 0.6), -20px) scale(0.7); opacity: 0; }
}

@keyframes celebration-coin-swirl {
  0% { transform: translate(-50%, -50%) rotate(var(--start-angle, 0deg)) translateX(0) scale(0.5); opacity: 0; }
  20% { opacity: 1; }
  100% { transform: translate(-50%, -50%) rotate(calc(var(--start-angle, 0deg) + var(--spin, 360deg))) translateX(var(--radius, 90px)) scale(1); opacity: 0; }
}

@keyframes celebration-firework-pop {
  0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
  30% { opacity: 1; }
  100% { transform: translate(-50%, -50%) scale(var(--scale, 1.6)); opacity: 0; }
}

@keyframes celebration-firework-ring {
  0% { transform: translate(-50%, -50%) scale(0.4); opacity: 0; }
  20% { opacity: 0.9; }
  100% { transform: translate(-50%, -50%) scale(var(--scale, 2.6)); opacity: 0; }
}

@keyframes celebration-spotlight {
  0% { transform: rotate(var(--rotate, 0deg)) scaleY(0.2) translateY(36px); opacity: 0; }
  35% { opacity: var(--beam-opacity, 0.95); }
  70% { transform: rotate(calc(var(--rotate, 0deg) + var(--swing, 8deg))) scaleY(1.05) translateY(0); opacity: var(--beam-opacity, 0.95); }
  100% { transform: rotate(calc(var(--rotate, 0deg) + var(--swing, 6deg))) scaleY(0.9) translateY(0); opacity: 0; }
}

@keyframes celebration-stage-rise {
  0% { transform: translate(-50%, 30px) scale(0.6); opacity: 0; }
  60% { transform: translate(-50%, 4px) scale(1.04); opacity: 1; }
  100% { transform: translate(-50%, 0) scale(1); opacity: 1; }
}

@keyframes celebration-stage-glow {
  0% { transform: translate(-50%, 24px) scale(0.7); opacity: 0; }
  40% { opacity: 0.85; }
  100% { transform: translate(-50%, 0) scale(1); opacity: 0.35; }
}

@keyframes celebration-sparkle-rise {
  0% { transform: translate(-50%, -20%) scale(0.6); opacity: 0; }
  40% { opacity: 1; }
  100% { transform: translate(-50%, -80%) scale(1.3); opacity: 0; }
}

@keyframes celebration-sparkle-pop {
  0% { transform: translate(-50%, -40%) scale(0.4); opacity: 0; }
  30% { opacity: 1; }
  100% { transform: translate(-50%, -120%) scale(1.4); opacity: 0; }
}

@keyframes celebration-jackpot-glow {
  0% { opacity: 0.2; transform: translate(-50%, -50%) scale(0.8); }
  50% { opacity: 0.7; transform: translate(-50%, -50%) scale(1.2); }
  100% { opacity: 0.2; transform: translate(-50%, -50%) scale(1); }
}

@keyframes celebration-pulse {
  0% { transform: translate(-50%, -50%) scale(0.2); opacity: 0.8; }
  100% { transform: translate(-50%, -50%) scale(2.8); opacity: 0; }
}

/* Navigation preview */
/* Navigation preview */
.pf-nav-preview {
  display: grid;
  grid-template-columns: 1fr 2fr;
  gap: 12px;
  align-items: center;
  width: 100%;
}

.pf-nav-preview__menu {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 12px;
  border-radius: var(--pf-radius-md);
  background: rgba(236, 195, 255, 0.06);
}

.pf-nav-preview__menu button {
  padding: 8px 10px;
  border-radius: var(--pf-radius-sm);
  background: rgba(236, 195, 255, 0.12);
  border: 1px solid transparent;
  color: var(--pf-text-secondary);
  text-align: left;
}

.pf-nav-preview__menu button.is-active {
  border-color: rgba(236, 195, 255, 0.24);
  background: rgba(198, 255, 119, 0.16);
}

.pf-nav-preview__content {
  min-height: 140px;
  border-radius: var(--pf-radius-md);
  background: rgba(236, 195, 255, 0.04);
  border: 1px solid rgba(236, 195, 255, 0.1);
  position: relative;
  overflow: hidden;
}

.pf-nav-preview__indicator {
  position: absolute;
  bottom: 12px;
  left: 12px;
  width: 64px;
  height: 4px;
  border-radius: var(--pf-radius-pill);
  background: var(--pf-brand-accent-secondary);
  transform-origin: left;
}

/* Page transitions */
.pf-page-transition {
  display: grid;
  gap: 12px;
}

.pf-page-transition__hero {
  height: 80px;
  border-radius: var(--pf-radius-md);
  background: rgba(236, 195, 255, 0.12);
  display: grid;
  place-items: center;
  color: var(--pf-text-secondary);
}

.pf-page-transition__body {
  display: grid;
  gap: 10px;
}

.pf-page-transition__block {
  height: 18px;
  border-radius: var(--pf-radius-xs);
  background: rgba(236, 195, 255, 0.09);
}

.pf-page-transition.is-animating[data-pattern="page-wipe"] .pf-page-transition__hero {
  animation: pf-wipe 0.7s ease forwards;
}

/* Navigation complex */
.pf-nav-complex {
  display: grid;
  gap: 12px;
}

.pf-nav-complex__header {
  font-size: 18px;
  font-weight: 600;
  color: var(--pf-base-60);
}

.pf-nav-complex__panels {
  display: grid;
  gap: 8px;
}

.pf-nav-complex__panel {
  height: 60px;
  border-radius: var(--pf-radius-md);
  background: rgba(236, 195, 255, 0.08);
  border: 1px solid rgba(236, 195, 255, 0.14);
}

/* Layout shift */
.pf-layout-shift {
  width: 100%;
}

.pf-layout-shift__grid {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 12px;
}

.pf-layout-shift__tile {
  padding: 14px;
  border-radius: var(--pf-radius-md);
  background: rgba(236, 195, 255, 0.08);
  border: 1px solid rgba(236, 195, 255, 0.12);
  color: var(--pf-text-secondary);
  text-align: center;
}

.pf-layout-shift__tile.is-highlighted {
  outline: 2px solid var(--pf-brand-accent-secondary);
}

/* Reward basics */
.pf-reward-basic {
  display: flex;
  align-items: center;
  gap: 14px;
  padding: 14px 16px;
  border-radius: var(--pf-radius-md);
  background: rgba(236, 195, 255, 0.08);
  border: 1px solid rgba(236, 195, 255, 0.12);
  color: var(--pf-text-secondary);
}

.pf-reward-basic__icon {
  width: 56px;
  height: 56px;
  border-radius: var(--pf-radius-lg);
  display: grid;
  place-items: center;
  font-size: 28px;
  font-weight: 700;
  color: var(--pf-base-60);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.18);
  transition: transform var(--pf-transition-base) ease;
}

.pf-reward-basic__label {
  font-weight: 600;
  color: var(--pf-base-60);
  letter-spacing: 0.01em;
}

/* Micro interactions */
.pf-micro {
  display: grid;
  gap: 10px;
}

.pf-micro__button,
.pf-reward-feedback__button {
  padding: 12px 16px;
  border-radius: var(--pf-radius-pill);
  border: 1px solid rgba(236, 195, 255, 0.2);
  background: rgba(236, 195, 255, 0.1);
  color: var(--pf-base-50);
  font-weight: 600;
  cursor: pointer;
}

.pf-micro__link {
  font-size: 14px;
  color: var(--pf-brand-accent-primary);
}

.pf-micro__input input {
  width: 100%;
  padding: 10px 12px;
  border-radius: var(--pf-radius-sm);
  border: 1px solid rgba(236, 195, 255, 0.18);
  background: rgba(236, 195, 255, 0.06);
  color: var(--pf-text-secondary);
}

.pf-micro__checkbox {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  color: var(--pf-text-secondary);
}

.pf-micro__icon {
  font-size: 24px;
}

.pf-micro__button.is-animating[data-pattern="button-hover-glint"] {
  animation: pf-glint 0.7s ease forwards;
}

.pf-micro__button.is-animating[data-pattern="button-press"] {
  animation: pf-press 0.4s ease forwards;
}

.pf-micro__link.is-animating[data-pattern="link-underline-slide"] {
  background-image: linear-gradient( to right, rgba(236,195,255,0) 0%, rgba(236,195,255,0.8) 50%, rgba(236,195,255,0) 100%);
  background-size: 200% 2px;
  background-repeat: no-repeat;
  background-position: 100% 100%;
  animation: pf-underline 0.6s ease forwards;
}

.pf-micro__input.is-animating[data-pattern="input-focus-glow"] input {
  animation: pf-input-glow 0.6s ease forwards;
}

.pf-micro__checkbox.is-animating[data-pattern="checkbox-check"] input {
  animation: pf-checkbox 0.4s ease forwards;
}

/* Micro state */
.pf-micro-state__card {
  padding: 16px;
  border-radius: var(--pf-radius-md);
  background: rgba(236, 195, 255, 0.08);
  border: 1px solid rgba(236, 195, 255, 0.12);
  color: var(--pf-text-secondary);
}

.pf-micro-state__card.is-animating[data-pattern="error-to-success"] {
  animation: pf-card-state 0.6s ease forwards;
}

/* Micro advanced */
.pf-micro-advanced__surface {
  position: relative;
  width: 100%;
  height: 120px;
  border-radius: var(--pf-radius-md);
  border: 1px dashed rgba(236, 195, 255, 0.18);
  display: grid;
  place-items: center;
}

.pf-micro-advanced__card {
  padding: 14px 18px;
  border-radius: var(--pf-radius-md);
  background: rgba(236, 195, 255, 0.18);
  color: var(--pf-base-60);
}

/* Data visualisations */
.pf-data-basic {
  display: grid;
  place-items: center;
  width: 100%;
  position: relative;
}

.pf-chart__bar {
  width: 100%;
  border-radius: var(--pf-radius-sm);
  background: linear-gradient(180deg, rgba(236, 195, 255, 0.9) 0%, rgba(78, 24, 124, 0.8) 100%);
  transform-origin: bottom;
}

.pf-chart__line {
  position: absolute;
  inset: 16px 16px 24px 16px;
  border-radius: var(--pf-radius-sm);
  border: 1px dashed rgba(236, 195, 255, 0.24);
  overflow: hidden;
}

.pf-chart__line polyline {
  fill: none;
  stroke: var(--pf-brand-accent-primary);
  stroke-width: 2;
  stroke-linecap: round;
  stroke-linejoin: round;
}
.pf-chart__pie {
  position: relative;
  width: 140px;
  height: 140px;
  display: grid;
  place-items: center;
}

.pf-chart__pie-svg {
  width: 100%;
  height: 100%;
  transform: rotate(-90deg);
}

.pf-chart__pie-track {
  fill: none;
  stroke: rgba(236,195,255,0.18);
  stroke-width: 6;
}

.pf-chart__pie-value {
  fill: none;
  stroke: rgba(71,255,244,0.9);
  stroke-width: 6;
  stroke-dasharray: 100;
  stroke-dashoffset: 100;
  stroke-linecap: round;
}

.pf-chart__stat {
  font-size: 28px;
  font-weight: 700;
  color: var(--pf-base-60);
}

.pf-chart__block {
  width: 40px;
  border-radius: var(--pf-radius-sm);
  background: linear-gradient(180deg, rgba(236,195,255,0.8) 0%, rgba(78,24,124,0.8) 100%);
}


.pf-data-interactive {
  position: relative;
  width: 100%;
  height: 160px;
}

.pf-data-interactive__stage {
  position: absolute;
  inset: 0;
  display: grid;
  place-items: center;
  gap: 12px;
  grid-template-columns: repeat(4, minmax(0, 1fr));
}

.pf-data-interactive__bracket {
  width: 80px;
  height: 20px;
  border-radius: var(--pf-radius-sm);
  border: 2px solid rgba(236, 195, 255, 0.4);
}

.pf-data-interactive__cell {
  width: 20px;
  height: 20px;
  border-radius: var(--pf-radius-xs);
  background: rgba(236, 195, 255, 0.14);
}

.pf-data-interactive__radar {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  border: 2px solid rgba(236, 195, 255, 0.3);
}
.pf-data-interactive__node {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: rgba(71,255,244,0.6);
}

.pf-data-interactive__score {
  background: rgba(236,195,255,0.1);
  padding: 6px 10px;
  border-radius: var(--pf-radius-pill);
  color: var(--pf-base-60);
  font-weight: 600;
}

.pf-data-interactive__curve svg {
  width: 160px;
  height: 60px;
  fill: none;
  stroke: rgba(71,255,244,0.8);
  stroke-width: 3;
}

.pf-data-interactive__flash {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(255, 206, 26, 0.7), rgba(255, 206, 26, 0));
  opacity: 0;
}

.pf-data-interactive__surge {
  width: 18px;
  background: linear-gradient(180deg, rgba(255, 89, 129, 0.75), rgba(71, 255, 244, 0.45));
  border-radius: var(--pf-radius-xs);
}

.pf-data-interactive__rung {
  width: 80px;
  height: 12px;
  border-radius: var(--pf-radius-xs);
  background: rgba(236,195,255,0.16);
}

.pf-data-interactive__loop {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  border: 2px dashed rgba(236,195,255,0.24);
}

.pf-data-interactive__stream {
  width: 6px;
  height: 140px;
  background: linear-gradient(180deg, rgba(71,255,244,0), rgba(71,255,244,0.6), rgba(71,255,244,0));
}

.pf-data-interactive__ticker-row {
  grid-column: span 4;
  width: 100%;
  overflow: hidden;
}

.pf-data-interactive__ticker {
  white-space: nowrap;
  color: var(--pf-base-60);
}


.pf-data-interactive__block {
  width: 60px;
  height: 20px;
  border-radius: var(--pf-radius-xs);
  background: rgba(236, 195, 255, 0.12);
}

/* Ambient */
.pf-ambient {
  width: 100%;
  height: 160px;
  border-radius: var(--pf-radius-lg);
  position: relative;
  overflow: hidden;
  background: rgba(33, 15, 49, 0.6);
}

.pf-ambient__layer {
  position: absolute;
  inset: 0;
}
.pf-ambient__band {
  position: absolute;
  left: 0;
  width: 100%;
  height: 40px;
  background: linear-gradient(90deg, rgba(236,195,255,0.25), rgba(236,195,255,0));
  opacity: 0.5;
}


.pf-ambient__layer.is-animating[data-pattern="gradient-shift"] {
  animation: pf-gradient 6s ease forwards;
}

.pf-ambient__particle {
  position: absolute;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(236, 195, 255, 0.8), rgba(236, 195, 255, 0));
}

/* Keyframes */
@keyframes pf-modal-entrance {
  0% {
    transform: translate(-50%, -50%) translate(var(--pf-modal-tx-start), var(--pf-modal-ty-start)) scale(var(--pf-modal-scale-start));
    opacity: 0;
    filter: blur(var(--pf-modal-blur-start));
  }
  65% {
    transform: translate(-50%, -50%) translate(var(--pf-modal-tx-mid), var(--pf-modal-ty-mid)) scale(var(--pf-modal-scale-mid));
    opacity: 1;
    filter: blur(var(--pf-modal-blur-mid));
  }
  100% {
    transform: translate(-50%, -50%) scale(var(--pf-modal-scale-end));
    opacity: 1;
    filter: blur(var(--pf-modal-blur-end));
  }
}

@keyframes pf-overlay-fade {
  0% {
    background-color: rgba(29, 9, 47, 0);
  }
  100% {
    background-color: rgba(29, 9, 47, var(--pf-overlay-opacity));
  }
}

@keyframes pf-modal-scale-pop {
  0% {
    transform: translate(-50%, -50%) scale(0.85);
    opacity: 0;
  }
  70% {
    transform: translate(-50%, -50%) scale(1.05);
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }
}

@keyframes pf-toast-enter {
  0% {
    transform: translate(var(--pf-toast-tx-start), var(--pf-toast-ty-start)) scale(var(--pf-toast-scale-start));
    opacity: 0;
  }
  80% {
    transform: translate(var(--pf-toast-tx-overshoot), var(--pf-toast-ty-overshoot)) scale(1.02);
    opacity: 1;
  }
  100% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
}

@keyframes pf-toast-progress {
  0% { transform: scaleX(1); }
  100% { transform: scaleX(0); }
}

@keyframes pf-progress-fill {
  0% { transform: scaleX(0); }
  100% { transform: scaleX(1); }
}

@keyframes pf-progress-pulse {
  0%, 100% { transform: scaleY(1); }
  50% { transform: scaleY(1.1); }
}

@keyframes pf-spinner {
  to {
    transform: rotate(360deg);
  }
}

@keyframes pf-dots {
  0%, 80%, 100% {
    transform: translateY(0);
    opacity: 0.4;
  }
  40% {
    transform: translateY(-6px);
    opacity: 1;
  }
}

@keyframes pf-glow-pulse {
  0% {
    opacity: 0;
    transform: scale(0.8);
  }
  50% {
    opacity: 1;
    transform: scale(1.05);
  }
  100% {
    opacity: 0;
    transform: scale(1);
  }
}

@keyframes pf-badge-pop {
  0% {
    transform: scale(0.8);
    opacity: 0;
  }
  60% {
    transform: scale(1.1);
    opacity: 1;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

@keyframes pf-text-rise {
  0% {
    transform: translateY(12px);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes pf-dot-burst {
  0% {
    box-shadow: 0 0 0 0 rgba(198, 255, 119, 0.4);
  }
  100% {
    box-shadow: 0 0 0 12px rgba(198, 255, 119, 0);
  }
}

@keyframes pf-wipe {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(0);
  }
}

@keyframes pf-glint {
  0% {
    background-position: -120% 0;
  }
  100% {
    background-position: 220% 0;
  }
}

@keyframes pf-press {
  0% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(4px);
  }
  100% {
    transform: translateY(0);
  }
}

@keyframes pf-underline {
  0% {
    background-position: 100% 100%;
  }
  100% {
    background-position: 0% 100%;
  }
}

@keyframes pf-input-glow {
  0% {
    box-shadow: 0 0 0 0 rgba(198, 255, 119, 0);
  }
  100% {
    box-shadow: 0 0 0 6px rgba(198, 255, 119, 0.16);
  }
}

@keyframes pf-checkbox {
  0% {
    transform: scale(0.8);
  }
  100% {
    transform: scale(1);
  }
}

@keyframes pf-card-state {
  0% {
    border-color: rgba(250, 17, 79, 0.4);
  }
  100% {
    border-color: rgba(198, 255, 119, 0.4);
  }
}

@keyframes pf-gradient {
  0% {
    background: rgba(33, 15, 49, 0.6);
  }
  100% {
    background: radial-gradient(circle at 20% 20%, rgba(198, 255, 119, 0.24), rgba(33, 15, 49, 0.9));
  }
}

[data-reduced-motion="true"] .pf-demo-canvas * {
  animation-duration: 1ms !important;
  animation-iteration-count: 1 !important;
  transition-duration: 1ms !important;
}

@media (max-width: 1220px) {
  .pf-app {
    padding: 20px;
  }
  .pf-main {
    grid-template-columns: 1fr;
  }
  .pf-sidebar {
    position: relative;
    top: auto;
    max-height: none;
    overflow: visible;
  }
  .pf-sidebar__nav {
    max-height: none;
    overflow: visible;
  }
}

@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 1ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 1ms !important;
  }
}

</style>
</head>
<body>
  <div class="pf-app" data-tech-filter="all">
    <main class="pf-main">
      <aside class="pf-sidebar">
        <div class="pf-sidebar__intro">
          <div class="pf-logo">PlayFame Animation Codex</div>
          <p class="pf-tagline">300 production-ready motion patterns aligned with our animation principles</p>
        </div>
        <div class="pf-sidebar__controls">
          <button class="pf-button" data-role="play-all">Replay All</button>
          <label class="pf-toggle">
            <input type="checkbox" data-role="reduced-motion" />
            <span>Reduced Motion</span>
          </label>
          <div class="pf-tech-filter">
            <button class="pf-chip pf-chip--active" data-tech="all">All</button>
            <button class="pf-chip" data-tech="css">CSS</button>
            <button class="pf-chip" data-tech="framer">Framer Motion</button>
          </div>
        </div>
        <div class="pf-sidebar__nav" data-role="sidebar-nav"></div>
      </aside>
      <section class="pf-catalog" data-role="catalog"></section>
    </main>
  </div>
  <script type="module">

import { animate, timeline, stagger, spring } from 'https://cdn.jsdelivr.net/npm/motion@10.16.4/+esm';

const durations = {
  xs: 180,
  sm: 240,
  md: 320,
  lg: 420,
  xl: 520,
  xxl: 680,
  celebration: 2600
};

const easingCurves = {
  standard: 'cubic-bezier(0.22, 0.61, 0.36, 1)',
  entrance: 'cubic-bezier(0.12, 0.75, 0.4, 1)',
  vibrant: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
  bounce: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
  gentle: 'cubic-bezier(0.4, 0, 0.2, 1)',
  pop: 'cubic-bezier(0.34, 1.25, 0.64, 1)',
  snap: 'cubic-bezier(0.16, 1, 0.3, 1)',
  expressive: 'cubic-bezier(0.33, 1.53, 0.67, 1)'
};

const easingLabels = {
  standard: 'Standard ease-out',
  entrance: 'Gentle entrance',
  vibrant: 'Vibrant overshoot',
  bounce: 'Bounce easing',
  gentle: 'Material smooth',
  pop: 'Pop emphasis',
  snap: 'Crisp snap',
  expressive: 'Expressive arc'
};

const randBetween = (min, max) => Math.random() * (max - min) + min;

const formatMs = (value) => `${Math.round(value)}ms`;

const toPercent = (value) => `${Math.round(value * 100)}%`;

const createEl = (tag, className, attrs = {}) => {
  const el = document.createElement(tag);
  if (className) {
    el.className = className;
  }
  Object.entries(attrs).forEach(([key, value]) => {
    if (value === undefined || value === null) return;
    if (key === 'text') {
      el.textContent = value;
    } else if (key === 'html') {
      el.innerHTML = value;
    } else {
      el.setAttribute(key, value);
    }
  });
  return el;
};

const setCssVars = (el, vars) => {
  Object.entries(vars).forEach(([key, value]) => {
    el.style.setProperty(key, value);
  });
};

const animationKeyframes = (() => {
  const styleEl = document.createElement('style');
  styleEl.id = 'pf-dynamic-keyframes';
  document.head.appendChild(styleEl);
  const sheet = styleEl.sheet;

  const ensureRule = (name, frames) => {
    if (!name || !frames) return name;
    const existingIndex = Array.from(sheet.cssRules).findIndex((rule) => rule.name === name);
    if (existingIndex >= 0) {
      sheet.deleteRule(existingIndex);
    }
    sheet.insertRule(`@keyframes ${name} { ${frames} }`, sheet.cssRules.length);
    return name;
  };

  return { ensureRule };
})();

const prefersReducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');

const state = {
  reducedMotion: prefersReducedMotionQuery.matches,
  techFilter: 'all',
  playables: new Map(),
  cards: new Map()
};

prefersReducedMotionQuery.addEventListener?.('change', (event) => {
  state.reducedMotion = event.matches;
  document.body.toggleAttribute('data-reduced-motion', state.reducedMotion);
});


const describeModalBase = (variant) => {
  const { mode, scaleFrom = 1, scaleMid = 1, scaleTo = 1, overlayOpacity = 0.68, blurStart = 0, blurMid = 0, blurEnd = 0, axis = 'none', distance = 0 } = variant.options;
  const overlay = Math.round(overlayOpacity * 100);
  if (mode === 'scale') {
    return `Scale entrance from ${toPercent(scaleFrom)} up to ${toPercent(scaleMid)} settling at ${toPercent(scaleTo)} with ${overlay}% overlay fade and ${blurStart}px${blurEnd}px blur.`;
  }
  if (mode === 'slide') {
    const direction = axis === 'x' ? (distance > 0 ? 'right' : 'left') : (distance > 0 ? 'down' : 'up');
    return `Slides in from the ${direction} by ${Math.abs(distance)}px with ${overlay}% overlay fade and soft blur ${blurStart}px.`;
  }
  return `Fade-in entrance with ${overlay}% overlay support and vertical shift ${Math.abs(distance)}px.`;
};

const describeModalContent = (variant) => {
  const { layout } = variant.options;
  switch (layout) {
    case 'buttons':
      return `Staggers ${variant.options.count} primary actions with ${variant.options.baseDelay}ms cadence and lift ${variant.options.distance}px.`;
    case 'buttons-wave':
      return `Wave pattern for ${variant.options.count} buttons with oscillating translate ${variant.options.distance}px.`;
    case 'list':
      return `Sequential list reveal (${variant.options.items} items) using ${variant.options.baseDelay}ms offsets.`;
    case 'list-wipe':
      return `Vertical panel wipe across ${variant.options.items} list items for crisp onboarding.`;
    case 'form':
      return `Form fields slide in from the ${variant.options.direction} with gentle ${variant.options.duration}ms pacing.`;
    case 'form-gradient':
      return `Gradient sweep across ${variant.options.fields} fields emphasising focus and order.`;
    case 'feedback':
      return variant.options.type === 'error'
        ? `Error shake amplitude ${variant.options.amplitude}px with ${variant.options.frequency} oscillations.`
        : `Success bounce with ${Math.round(variant.options.bounce * 100)}% overshoot for celebratory feedback.`;
    default:
      return 'Content choreography inside the modal.';
  }
};

const describeModalDismiss = (variant) => {
  if (variant.options.direction === 'fade') {
    return 'Soft fade-to-dismiss with synchronized progress depletion.';
  }
  if (variant.options.direction === 'wipe') {
    return 'Snackbar wipes along the horizontal axis with progress tracking overlay.';
  }
  if (variant.options.direction === 'scale') {
    return 'Dismiss pulse that scales and recedes while the timer empties.';
  }
  if (variant.options.direction === 'burst') {
    return 'High-energy burst dismissal with spark highlight and timed exit.';
  }
  const axis = variant.options.direction === 'left' || variant.options.direction === 'right' ? 'horizontal' : 'vertical';
  return `Toast slides along the ${axis} axis with auto-dismiss at ${variant.options.autoDismiss}ms.`;
};

const describeProgressBar = (variant) => {
  switch (variant.options.style) {
    case 'soft':
      return 'Smooth easing fill with subtle light bloom at completion.';
    case 'striped':
      return 'Animated stripes communicate momentum during fill.';
    case 'pulse':
      return 'Momentum pulse on update emphasising change events.';
    case 'milestones':
      return 'Milestone markers light up as progress crosses thresholds.';
    case 'segmented':
      return 'Segments fill sequentially for discrete progress feedback.';
    case 'gradient':
      return 'Gradient sweep along the bar for premium polish.';
    case 'bounce':
      return 'Elastic finish emphasises completion state.';
    case 'thick':
      return 'High contrast thick bar with gentle pulse loop.';
    case 'thin':
      return 'Slim tracker for compact UI contexts.';
    case 'surge':
      return 'Acceleration surge with overshoot to draw attention.';
    case 'spark':
      return 'Spark trail glides along the bar to show live updates.';
    case 'wave':
      return 'Wave pattern ripples across the filled area.';
    default:
      return 'Progress indicator animation.';
  }
};

const describeLoadingState = (variant) => {
  const { style = 'skeleton', layout } = variant.options;
  if (layout === 'horizontal') return 'Horizontal skeleton shimmer for content placeholders.';
  if (layout === 'vertical') return 'Vertical skeleton stack simulating cards.';
  if (layout === 'grid') return 'Grid skeleton effect for gallery loading.';
  if (layout === 'card') return 'Card skeleton with layered shimmer lines.';
  if (style === 'dual-ring') return 'Dual ring spinner with consistent velocity.';
  if (style === 'orbital') return 'Orbital spinner around centre mass.';
  if (style === 'galaxy') return 'Galaxy spinner with layered opacity twirls.';
  if (style === 'rise') return 'Three-dot rise cadence for subtle loading feedback.';
  if (style === 'wave') return 'Three-dot wave for rhythmic pacing.';
  if (style === 'portal') return 'Dots fold into portal centre to indicate processing.';
  if (style === 'ring') return 'Progress ring fills from 0 to 100%.';
  if (style === 'multi-ring') return 'Nested rings oscillate asynchronously.';
  return 'Loading placeholder animation.';
};

const describeDynamicProgress = (variant) => {
  switch (variant.options.style) {
    case 'number-pop':
      return 'XP gain count-up with pop easing and glow.';
    case 'bar-flare':
      return 'Bar flares with additive highlight on level change.';
    case 'breakthrough':
      return 'Level breakthrough shakes frame with surge lines.';
    case 'meter-spin':
      return 'Meter needle spins to new value with spring easing.';
    case 'banner-rise':
      return 'Victory banner rises with confetti burst accent.';
    case 'ring-fill':
      return 'Achievement ring fills from 0 to 360 degrees.';
    case 'card-slide':
      return 'Achievement card slides in with depth shadow.';
    case 'quest-chain':
      return 'Quest chain nodes glow sequentially to completion.';
    default:
      return 'Dynamic progress celebration.';
  }
};

const describeMilestone = (variant) => {
  return `Milestone celebration style: ${variant.options.style.replace(/-/g, ' ')} emphasising reward moments.`;
};

const describeTimerEffect = (variant) => {
  switch (variant.options.style) {
    case 'color-shift':
      return 'Countdown shifts colour from calm to urgency.';
    case 'pulse':
      return 'Last seconds pulse to draw focus.';
    case 'flash':
      return 'Flashing state at expiry to warn users.';
    case 'tick':
      return 'Analog clock tick translation on digits.';
    case 'underline':
      return 'Underline sweeps as time elapses.';
    case 'arc':
      return 'Circular arc traces remaining time.';
    case 'breathe':
      return 'Breathing halo to keep timer alive in background.';
    case 'flip':
      return 'Mechanical flip digits animate per second.';
    case 'glow':
      return 'Glow intensity increases as deadline nears.';
    case 'pop':
      return 'Digits pop at the end to confirm completion.';
    default:
      return 'Timer treatment.';
  }
};

const describeUpdateIndicator = (variant) => {
  switch (variant.options.style) {
    case 'badge-pop':
      return 'Notification badge pops in with quick overshoot.';
    case 'badge-pulse':
      return 'Badge pulsates to signal unseen content.';
    case 'live-ping':
      return 'Live indicator ping loop for streams.';
    case 'notification-dot':
      return 'Dot ripple communicating unread state.';
    case 'counter-increment':
      return 'Numeric counter ticks upwards with scale.';
    case 'ticker-scroll':
      return 'Ticker text scrolls horizontally with mask.';
    case 'update-slide':
      return 'Content preview slides into view.';
    case 'update-flip':
      return 'Card flips to reveal updated data.';
    default:
      return 'Update signal animation.';
  }
};

const describeRewardBasic = (variant) => `Reward flourish: ${variant.options.style.replace(/-/g, ' ')}.`;

const describeRewardFeedback = (variant) => `Action feedback state: ${variant.options.style.replace(/-/g, ' ')}.`;

const describeNavigation = (variant) => `Navigation treatment: ${variant.options.style.replace(/-/g, ' ')}.`;

const describeMicroInteractive = (variant) => `Micro-interaction style: ${variant.options.style.replace(/-/g, ' ')}.`;

const describeMicroState = (variant) => `State choreography: ${variant.options.style.replace(/-/g, ' ')}.`;

const describeAmbient = (variant) => `Atmospheric effect: ${variant.options.style.replace(/-/g, ' ')}.`;


const modalBaseVariants = () => {
  const make = (key, title, options) => ({ key, title, description: describeModalBase({ options, key }), options: { ...options, easingLabel: easingLabels[options.easingKey] || 'Custom' } });
  const scale = [
    ['scale-gentle-pop', 'Gentle Scale Pop', { mode: 'scale', scaleFrom: 0.88, scaleMid: 1.05, scaleTo: 1, duration: durations.lg, easing: easingCurves.entrance, easingKey: 'entrance', overlayOpacity: 0.72, blurStart: 12, blurMid: 3, blurEnd: 0 }],
    ['scale-crisp', 'Crisp Snap', { mode: 'scale', scaleFrom: 0.95, scaleMid: 1, scaleTo: 1, duration: durations.sm, easing: easingCurves.snap, easingKey: 'snap', overlayOpacity: 0.64, blurStart: 0, blurMid: 0, blurEnd: 0 }],
    ['scale-hero', 'Hero Bounce', { mode: 'scale', scaleFrom: 0.78, scaleMid: 1.08, scaleTo: 1, duration: durations.xl, easing: easingCurves.bounce, easingKey: 'bounce', overlayOpacity: 0.76, blurStart: 18, blurMid: 6, blurEnd: 0 }],
    ['scale-lift', 'Lift Arrival', { mode: 'scale', scaleFrom: 0.72, scaleMid: 1.03, scaleTo: 1, duration: 560, easing: easingCurves.vibrant, easingKey: 'vibrant', overlayOpacity: 0.72, blurStart: 16, blurMid: 5, blurEnd: 0 }]
  ];
  const slide = [
    { key: 'slide-up-soft', title: 'Slide Up Soft', options: { mode: 'slide', axis: 'y', distance: -64, overshoot: 8, duration: durations.lg, easing: easingCurves.standard, easingKey: 'standard', overlayOpacity: 0.7, blurStart: 8, blurMid: 2, blurEnd: 0 } },
    { key: 'slide-up-crisp', title: 'Slide Up Crisp', options: { mode: 'slide', axis: 'y', distance: -72, overshoot: 12, duration: durations.md, easing: easingCurves.snap, easingKey: 'snap', overlayOpacity: 0.62, blurStart: 6, blurMid: 1, blurEnd: 0 } },
    { key: 'slide-down-soft', title: 'Slide Down Welcome', options: { mode: 'slide', axis: 'y', distance: 60, overshoot: -10, duration: durations.lg, easing: easingCurves.entrance, easingKey: 'entrance', overlayOpacity: 0.68, blurStart: 8, blurMid: 2, blurEnd: 0 } },
    { key: 'slide-down-hero', title: 'Slide Down Hero Drop', options: { mode: 'slide', axis: 'y', distance: 92, overshoot: -18, duration: durations.xl, easing: easingCurves.vibrant, easingKey: 'vibrant', overlayOpacity: 0.72, blurStart: 12, blurMid: 4, blurEnd: 0 } },
    { key: 'slide-left-drift', title: 'Slide Left Drift', options: { mode: 'slide', axis: 'x', distance: 68, overshoot: -12, duration: durations.lg, easing: easingCurves.standard, easingKey: 'standard', overlayOpacity: 0.68, blurStart: 7, blurMid: 2, blurEnd: 0 } },
    { key: 'slide-right-drift', title: 'Slide Right Drift', options: { mode: 'slide', axis: 'x', distance: -68, overshoot: 12, duration: durations.lg, easing: easingCurves.standard, easingKey: 'standard', overlayOpacity: 0.68, blurStart: 7, blurMid: 2, blurEnd: 0 } }
  ];
  const fades = [
    { key: 'fade-soft', title: 'Fade & Blur Soft', options: { mode: 'fade', axis: 'none', distance: 0, duration: durations.md, easing: easingCurves.gentle, easingKey: 'gentle', overlayOpacity: 0.72, blurStart: 20, blurMid: 8, blurEnd: 0 } },
    { key: 'fade-glow', title: 'Fade & Glow Sweep', options: { mode: 'fade', axis: 'none', distance: 0, duration: durations.xl, easing: easingCurves.entrance, easingKey: 'entrance', overlayOpacity: 0.78, blurStart: 18, blurMid: 4, blurEnd: 0 } },
    { key: 'fade-zoom', title: 'Fade with Zoom', options: { mode: 'fade', axis: 'none', distance: 0, duration: durations.lg, easing: easingCurves.standard, easingKey: 'standard', overlayOpacity: 0.68, blurStart: 8, blurMid: 2, blurEnd: 0 } },
    { key: 'fade-shift', title: 'Fade & Vertical Shift', options: { mode: 'fade', axis: 'y', distance: -32, duration: durations.lg, easing: easingCurves.entrance, easingKey: 'entrance', overlayOpacity: 0.7, blurStart: 12, blurMid: 4, blurEnd: 0 } }
  ];
  return [
    ...scale.map(([key, title, options]) => make(key, title, options)),
    ...slide.map(({ key, title, options }) => make(key, title, options)),
    ...fades.map(({ key, title, options }) => make(key, title, options))
  ];
};

const modalContentVariants = () => {
  const variants = [];
  const buttonCounts = [2, 3, 4];
  buttonCounts.forEach((count) => {
    variants.push({
      key: `buttons-stagger-${count}`,
      title: `Button Stagger ${count}`,
      description: `Button cluster stagger with ${count} actions.`,
      options: {
        layout: 'buttons',
        count,
        baseDelay: 70,
        distance: 16 + count * 4,
        duration: durations.md + count * 20,
        easing: easingCurves.entrance,
        easingKey: 'entrance',
        startScale: 0.94,
        endScale: 1
      }
    });
    variants.push({
      key: `buttons-wave-${count}`,
      title: `Button Wave ${count}`,
      description: `Button wave oscillation across ${count} actions.`,
      options: {
        layout: 'buttons-wave',
        count,
        baseDelay: 60,
        distance: 12 + count * 3,
        duration: durations.lg,
        easing: easingCurves.vibrant,
        easingKey: 'vibrant'
      }
    });
  });
  const listConfigs = [
    ['list-soft-stagger', 'List Soft Stagger', { layout: 'list', items: 5, baseDelay: 60, distance: 20, duration: durations.md, easing: easingCurves.gentle, easingKey: 'gentle' }],
    ['list-emphatic-stagger', 'List Emphatic Stagger', { layout: 'list', items: 4, baseDelay: 80, distance: 28, duration: durations.lg, easing: easingCurves.vibrant, easingKey: 'vibrant' }],
    ['list-vertical-wipe', 'List Vertical Wipe', { layout: 'list-wipe', items: 4, duration: durations.lg, easing: easingCurves.entrance, easingKey: 'entrance' }],
    ['list-spotlight', 'List Spotlight Sweep', { layout: 'list-spotlight', items: 3, duration: durations.lg, easing: easingCurves.entrance, easingKey: 'entrance' }]
  ];
  listConfigs.forEach(([key, title, options]) => {
    variants.push({ key, title, description: describeModalContent({ options }), options });
  });
  const formConfigs = [
    ['form-field-left-reveal', 'Form Fields From Left', { layout: 'form', fields: 3, direction: 'left', duration: durations.lg, easing: easingCurves.standard, easingKey: 'standard' }],
    ['form-field-right-reveal', 'Form Fields From Right', { layout: 'form', fields: 4, direction: 'right', duration: durations.lg, easing: easingCurves.standard, easingKey: 'standard' }],
    ['form-field-gradient', 'Form Gradient Sweep', { layout: 'form-gradient', fields: 3, duration: durations.lg, easing: easingCurves.entrance, easingKey: 'entrance' }],
    ['form-field-stack', 'Form Stack Pop', { layout: 'form-stack', fields: 4, duration: durations.lg, easing: easingCurves.vibrant, easingKey: 'vibrant' }]
  ];
  formConfigs.forEach(([key, title, options]) => {
    variants.push({ key, title, description: describeModalContent({ options }), options });
  });
  const feedbackConfigs = [
    ['error-shake-gentle', 'Error Shake Gentle', { layout: 'feedback', type: 'error', amplitude: 12, frequency: 5, duration: 420, easing: easingCurves.snap, easingKey: 'snap' }],
    ['error-shake-intent', 'Error Shake Intentional', { layout: 'feedback', type: 'error', amplitude: 16, frequency: 6, duration: 460, easing: easingCurves.vibrant, easingKey: 'vibrant' }],
    ['success-bounce-soft', 'Success Bounce Soft', { layout: 'feedback', type: 'success', bounce: 0.12, duration: 520, easing: easingCurves.bounce, easingKey: 'bounce' }],
    ['success-bounce-energetic', 'Success Bounce Energetic', { layout: 'feedback', type: 'success', bounce: 0.18, duration: 620, easing: easingCurves.vibrant, easingKey: 'vibrant' }]
  ];
  feedbackConfigs.forEach(([key, title, options]) => {
    variants.push({ key, title, description: describeModalContent({ options }), options });
  });
  return variants.filter((variant) => !['buttons-wave-2', 'buttons-wave-3', 'list-emphatic-stagger', 'form-field-stack'].includes(variant.key));
};

const modalDismissVariants = () => {
  const base = [
    { key: 'toast-slide-left', title: 'Toast Slide Left', options: { direction: 'left', duration: durations.md, easing: easingCurves.standard, easingKey: 'standard', autoDismiss: 3800 } },
    { key: 'toast-slide-right', title: 'Toast Slide Right', options: { direction: 'right', duration: durations.md, easing: easingCurves.standard, easingKey: 'standard', autoDismiss: 3800 } },
    { key: 'toast-drop', title: 'Toast Drop Down', options: { direction: 'down', duration: durations.md, easing: easingCurves.entrance, easingKey: 'entrance', autoDismiss: 3600 } },
    { key: 'toast-raise', title: 'Toast Rise Up', options: { direction: 'up', duration: durations.md, easing: easingCurves.entrance, easingKey: 'entrance', autoDismiss: 3600 } },
    { key: 'toast-fade-progress', title: 'Toast Fade Progress', options: { direction: 'fade', duration: durations.lg, easing: easingCurves.gentle, easingKey: 'gentle', autoDismiss: 4600, progress: true } },
    { key: 'snackbar-wipe', title: 'Snackbar Wipe', options: { direction: 'wipe', duration: durations.lg, easing: easingCurves.entrance, easingKey: 'entrance', autoDismiss: 4200, progress: true } },
    { key: 'snackbar-scale', title: 'Snackbar Scale Pulse', options: { direction: 'scale', duration: durations.md, easing: easingCurves.pop, easingKey: 'pop', autoDismiss: 4000, progress: true } },
    { key: 'notification-burst', title: 'Notification Burst', options: { direction: 'burst', duration: durations.lg, easing: easingCurves.vibrant, easingKey: 'vibrant', autoDismiss: 4800, progress: true } }
  ];
  return base.map((variant) => ({ ...variant, description: describeModalDismiss(variant) }));
};

const modalOrchestrationVariants = () => [
  { key: 'wizard-slide-stack', title: 'Wizard Slide Stack', options: { steps: 3, pattern: 'slide-stack', duration: durations.xl, easing: easingCurves.entrance, easingKey: 'entrance' } },
  { key: 'wizard-fade-cross', title: 'Wizard Fade Cross', options: { steps: 4, pattern: 'cross-fade', duration: durations.xl, easing: easingCurves.gentle, easingKey: 'gentle' } },
  { key: 'wizard-scale-rotate', title: 'Wizard Scale Rotate', options: { steps: 3, pattern: 'scale-rotate', duration: durations.xl, easing: easingCurves.vibrant, easingKey: 'vibrant' } },
  { key: 'tab-morph', title: 'Tab Content Morph', options: { tabs: 4, pattern: 'morph', duration: durations.lg, easing: easingCurves.entrance, easingKey: 'entrance' } },
  { key: 'selection-grid', title: 'Selection Grid Cascade', options: { items: 6, pattern: 'grid-cascade', duration: durations.lg, easing: easingCurves.entrance, easingKey: 'entrance' } },
  { key: 'multi-step-progressive', title: 'Progressive Flow', options: { steps: 5, pattern: 'progressive', duration: durations.xxl, easing: easingCurves.entrance, easingKey: 'entrance' } },
  { key: 'tab-slide', title: 'Tab Slide Swap', options: { tabs: 3, pattern: 'slide-swap', duration: durations.lg, easing: easingCurves.standard, easingKey: 'standard' } },
  { key: 'grid-highlight', title: 'Highlight Sweep', options: { items: 5, pattern: 'highlight-sweep', duration: durations.lg, easing: easingCurves.entrance, easingKey: 'entrance' } },
  { key: 'comparison-morph', title: 'Comparison Morph', options: { panes: 2, pattern: 'morph', duration: durations.xl, easing: easingCurves.vibrant, easingKey: 'vibrant' } },
  { key: 'timeline-progress', title: 'Timeline Progress', options: { steps: 4, pattern: 'timeline', duration: durations.xl, easing: easingCurves.standard, easingKey: 'standard' } }
];

const modalCelebrationVariants = () => [
  { key: 'confetti-burst', title: 'Confetti Burst', options: { style: 'confetti-burst', particles: 32, duration: durations.celebration } },
  { key: 'confetti-fan', title: 'Confetti Fan', options: { style: 'confetti-fan', particles: 28, duration: durations.celebration - 200 } },
  { key: 'confetti-spiral', title: 'Confetti Spiral', options: { style: 'confetti-spiral', particles: 36, duration: durations.celebration } },
  { key: 'confetti-rain', title: 'Confetti Rainfall', options: { style: 'confetti-rain', particles: 60, duration: durations.celebration + 200 } },
  { key: 'coins-arc', title: 'Coin Arc Fountain', options: { style: 'coins-arc', particles: 24, duration: 2000 } },
  { key: 'coins-fountain', title: 'Coin Fountain', options: { style: 'coins-fountain', particles: 32, duration: 2200 } },
  { key: 'coins-swirl', title: 'Coin Swirl', options: { style: 'coins-swirl', particles: 28, duration: 2200 } },
  { key: 'fireworks-triple', title: 'Fireworks Triple Burst', options: { style: 'fireworks-triple', bursts: 3, duration: durations.celebration } },
  { key: 'fireworks-ring', title: 'Fireworks Halo', options: { style: 'fireworks-ring', bursts: 2, duration: durations.celebration } },
  { key: 'reward-spotlight', title: 'Reward Spotlight', options: { style: 'reward-spotlight', beams: 5, duration: durations.celebration } },
  { key: 'jackpot-celebration', title: 'Jackpot Celebration', options: { style: 'jackpot-celebration', bursts: 4, duration: durations.celebration + 200 } },
  { key: 'confetti-pulse', title: 'Confetti Pulse Wave', options: { style: 'confetti-pulse', particles: 40, duration: durations.celebration } }
];


const progressBarVariants = () => [
  { key: 'progress-soft-fill', title: 'Soft Fill', description: describeProgressBar({ options: { style: 'soft' } }), options: { style: 'soft', stripes: false, duration: durations.lg, easing: easingCurves.entrance, easingKey: 'entrance' } },
  { key: 'progress-striped', title: 'Striped Flow', description: describeProgressBar({ options: { style: 'striped' } }), options: { style: 'striped', stripes: true, duration: durations.lg, easing: easingCurves.standard, easingKey: 'standard' } },
  { key: 'progress-pulse', title: 'Pulse Update', description: describeProgressBar({ options: { style: 'pulse' } }), options: { style: 'pulse', stripes: false, duration: durations.md, easing: easingCurves.pop, easingKey: 'pop' } },
  { key: 'progress-milestones', title: 'Milestone Markers', description: describeProgressBar({ options: { style: 'milestones' } }), options: { style: 'milestones', stripes: false, duration: durations.lg, easing: easingCurves.entrance, easingKey: 'entrance' } },
  { key: 'progress-segmented', title: 'Segmented Sweep', description: describeProgressBar({ options: { style: 'segmented' } }), options: { style: 'segmented', stripes: false, duration: durations.lg, easing: easingCurves.standard, easingKey: 'standard' } },
  { key: 'progress-gradient', title: 'Gradient Glide', description: describeProgressBar({ options: { style: 'gradient' } }), options: { style: 'gradient', stripes: false, duration: durations.lg, easing: easingCurves.gentle, easingKey: 'gentle' } },
  { key: 'progress-bounce', title: 'Bounce Finish', description: describeProgressBar({ options: { style: 'bounce' } }), options: { style: 'bounce', stripes: false, duration: durations.lg, easing: easingCurves.bounce, easingKey: 'bounce' } },
  { key: 'progress-thick', title: 'Thick Pulse', description: describeProgressBar({ options: { style: 'thick' } }), options: { style: 'thick', stripes: false, duration: durations.md, easing: easingCurves.standard, easingKey: 'standard' } },
  { key: 'progress-thin', title: 'Thin Glide', description: describeProgressBar({ options: { style: 'thin' } }), options: { style: 'thin', stripes: false, duration: durations.sm, easing: easingCurves.standard, easingKey: 'standard' } },
  { key: 'progress-surge', title: 'Surge Finale', description: describeProgressBar({ options: { style: 'surge' } }), options: { style: 'surge', stripes: false, duration: durations.lg, easing: easingCurves.vibrant, easingKey: 'vibrant' } },
  { key: 'progress-spark', title: 'Spark Trail', description: describeProgressBar({ options: { style: 'spark' } }), options: { style: 'spark', stripes: true, duration: durations.lg, easing: easingCurves.pop, easingKey: 'pop' } },
  { key: 'progress-wave', title: 'Wave Motion', description: describeProgressBar({ options: { style: 'wave' } }), options: { style: 'wave', stripes: true, duration: durations.xl, easing: easingCurves.entrance, easingKey: 'entrance' } }
];

const loadingStateVariants = () => [
  { key: 'skeleton-horizontal', title: 'Skeleton Horizontal', description: describeLoadingState({ options: { layout: 'horizontal' } }), options: { layout: 'horizontal', duration: durations.lg } },
  { key: 'skeleton-vertical', title: 'Skeleton Vertical', description: describeLoadingState({ options: { layout: 'vertical' } }), options: { layout: 'vertical', duration: durations.lg } },
  { key: 'skeleton-tile', title: 'Skeleton Tile Grid', description: describeLoadingState({ options: { layout: 'grid' } }), options: { layout: 'grid', duration: durations.lg } },
  { key: 'skeleton-card', title: 'Skeleton Card', description: describeLoadingState({ options: { layout: 'card' } }), options: { layout: 'card', duration: durations.lg } },
  { key: 'spinner-dual-ring', title: 'Spinner Dual Ring', description: describeLoadingState({ options: { style: 'dual-ring' } }), options: { style: 'dual-ring', duration: durations.md } },
  { key: 'spinner-orbital', title: 'Spinner Orbital', description: describeLoadingState({ options: { style: 'orbital' } }), options: { style: 'orbital', duration: durations.md } },
  { key: 'spinner-galaxy', title: 'Spinner Galaxy', description: describeLoadingState({ options: { style: 'galaxy' } }), options: { style: 'galaxy', duration: durations.lg } },
  { key: 'dots-rise', title: 'Dots Rise', description: describeLoadingState({ options: { style: 'rise' } }), options: { style: 'rise', duration: durations.sm } },
  { key: 'dots-wave', title: 'Dots Wave', description: describeLoadingState({ options: { style: 'wave' } }), options: { style: 'wave', duration: durations.sm } },
  { key: 'dots-portal', title: 'Dots Portal', description: describeLoadingState({ options: { style: 'portal' } }), options: { style: 'portal', duration: durations.md } },
  { key: 'ring-progress', title: 'Ring Progress', description: describeLoadingState({ options: { style: 'ring' } }), options: { style: 'ring', duration: durations.lg } },
  { key: 'ring-multi', title: 'Multi Ring', description: describeLoadingState({ options: { style: 'multi-ring' } }), options: { style: 'multi-ring', duration: durations.lg } }
];

const dynamicProgressMotionVariants = () => [
  { key: 'xp-number-pop', title: 'XP Number Pop', description: describeDynamicProgress({ options: { style: 'number-pop' } }), options: { style: 'number-pop', duration: durations.md } },
  { key: 'xp-bar-flare', title: 'XP Bar Flare', description: describeDynamicProgress({ options: { style: 'bar-flare' } }), options: { style: 'bar-flare', duration: durations.lg } },
  { key: 'level-breakthrough', title: 'Level Breakthrough', description: describeDynamicProgress({ options: { style: 'breakthrough' } }), options: { style: 'breakthrough', duration: durations.xl } },
  { key: 'level-meter', title: 'Level Meter Spin', description: describeDynamicProgress({ options: { style: 'meter-spin' } }), options: { style: 'meter-spin', duration: durations.lg } },
  { key: 'level-banner', title: 'Level Banner Rise', description: describeDynamicProgress({ options: { style: 'banner-rise' } }), options: { style: 'banner-rise', duration: durations.lg } },
  { key: 'achievement-ring', title: 'Achievement Ring', description: describeDynamicProgress({ options: { style: 'ring-fill' } }), options: { style: 'ring-fill', duration: durations.lg } },
  { key: 'achievement-card', title: 'Achievement Card', description: describeDynamicProgress({ options: { style: 'card-slide' } }), options: { style: 'card-slide', duration: durations.lg } },
  { key: 'quest-chain', title: 'Quest Chain', description: describeDynamicProgress({ options: { style: 'quest-chain' } }), options: { style: 'quest-chain', duration: durations.xl } }
];

const milestoneCelebrationVariants = () => [
  { key: 'quest-burst', title: 'Quest Burst', description: describeMilestone({ options: { style: 'quest-burst' } }), options: { style: 'quest-burst', duration: durations.xl } },
  { key: 'loyalty-tier', title: 'Loyalty Tier Upgrade', description: describeMilestone({ options: { style: 'loyalty-tier' } }), options: { style: 'loyalty-tier', duration: durations.xl } },
  { key: 'level-breakthrough-flare', title: 'Breakthrough Flare', description: describeMilestone({ options: { style: 'level-flare' } }), options: { style: 'level-flare', duration: durations.xl } },
  { key: 'achievement-burst', title: 'Achievement Burst', description: describeMilestone({ options: { style: 'achievement-burst' } }), options: { style: 'achievement-burst', duration: durations.lg } },
  { key: 'milestone-banner', title: 'Milestone Banner', description: describeMilestone({ options: { style: 'milestone-banner' } }), options: { style: 'milestone-banner', duration: durations.lg } },
  { key: 'tier-up-lights', title: 'Tier Up Lights', description: describeMilestone({ options: { style: 'tier-lights' } }), options: { style: 'tier-lights', duration: durations.lg } },
  { key: 'badge-glow', title: 'Badge Glow', description: describeMilestone({ options: { style: 'badge-glow' } }), options: { style: 'badge-glow', duration: durations.lg } },
  { key: 'progress-fireworks', title: 'Progress Fireworks', description: describeMilestone({ options: { style: 'progress-fireworks' } }), options: { style: 'progress-fireworks', duration: durations.xl } }
];

const timerEffectsVariants = () => [
  { key: 'timer-color-shift', title: 'Color Shift', description: describeTimerEffect({ options: { style: 'color-shift' } }), options: { style: 'color-shift', duration: durations.lg } },
  { key: 'timer-pulse', title: 'Pulse Urgency', description: describeTimerEffect({ options: { style: 'pulse' } }), options: { style: 'pulse', duration: durations.sm } },
  { key: 'timer-flash', title: 'Flash Expire', description: describeTimerEffect({ options: { style: 'flash' } }), options: { style: 'flash', duration: durations.md } },
  { key: 'timer-tick', title: 'Clock Tick', description: describeTimerEffect({ options: { style: 'tick' } }), options: { style: 'tick', duration: durations.md } },
  { key: 'timer-underline', title: 'Underline Sweep', description: describeTimerEffect({ options: { style: 'underline' } }), options: { style: 'underline', duration: durations.md } },
  { key: 'timer-arc', title: 'Arc Sweep', description: describeTimerEffect({ options: { style: 'arc' } }), options: { style: 'arc', duration: durations.lg } },
  { key: 'timer-breathe', title: 'Breathe Halo', description: describeTimerEffect({ options: { style: 'breathe' } }), options: { style: 'breathe', duration: durations.lg } },
  { key: 'timer-flip', title: 'Flip Digits', description: describeTimerEffect({ options: { style: 'flip' } }), options: { style: 'flip', duration: durations.lg } },
  { key: 'timer-glow', title: 'Glow Intensify', description: describeTimerEffect({ options: { style: 'glow' } }), options: { style: 'glow', duration: durations.lg } },
  { key: 'timer-pop', title: 'Completion Pop', description: describeTimerEffect({ options: { style: 'pop' } }), options: { style: 'pop', duration: durations.md } }
];

const updateIndicatorsVariants = () => [
  { key: 'badge-pop', title: 'Badge Pop', description: describeUpdateIndicator({ options: { style: 'badge-pop' } }), options: { style: 'badge-pop', duration: durations.sm } },
  { key: 'badge-pulse', title: 'Badge Pulse', description: describeUpdateIndicator({ options: { style: 'badge-pulse' } }), options: { style: 'badge-pulse', duration: durations.md } },
  { key: 'live-ping', title: 'Live Ping', description: describeUpdateIndicator({ options: { style: 'live-ping' } }), options: { style: 'live-ping', duration: durations.lg } },
  { key: 'notification-dot', title: 'Notification Dot', description: describeUpdateIndicator({ options: { style: 'notification-dot' } }), options: { style: 'notification-dot', duration: durations.lg } },
  { key: 'counter-increment', title: 'Counter Increment', description: describeUpdateIndicator({ options: { style: 'counter-increment' } }), options: { style: 'counter-increment', duration: durations.sm } },
  { key: 'ticker-scroll', title: 'Ticker Scroll', description: describeUpdateIndicator({ options: { style: 'ticker-scroll' } }), options: { style: 'ticker-scroll', duration: durations.lg } },
  { key: 'update-slide', title: 'Update Slide', description: describeUpdateIndicator({ options: { style: 'update-slide' } }), options: { style: 'update-slide', duration: durations.md } },
  { key: 'update-flip', title: 'Update Flip', description: describeUpdateIndicator({ options: { style: 'update-flip' } }), options: { style: 'update-flip', duration: durations.lg } }
];


const complexTimerMotionVariants = () => [
  { key: 'circular-countdown', title: 'Circular Countdown', options: { style: 'circular', duration: durations.xl } },
  { key: 'mode-switch', title: 'Mode Switch', options: { style: 'mode-switch', duration: durations.lg } },
  { key: 'generator-fill', title: 'Generator Fill', options: { style: 'generator-fill', duration: durations.lg } },
  { key: 'tournament-timer', title: 'Tournament Timer', options: { style: 'tournament-timer', duration: durations.xl } },
  { key: 'countdown-flip', title: 'Countdown Flip', options: { style: 'countdown-flip', duration: durations.xl } }
];

const realtimeDataMotionVariants = () => [
  { key: 'leaderboard-shift', title: 'Leaderboard Shift', options: { style: 'leaderboard-shift', duration: durations.lg } },
  { key: 'live-score-update', title: 'Live Score Update', options: { style: 'live-score', duration: durations.lg } },
  { key: 'win-ticker', title: 'Win Ticker', options: { style: 'win-ticker', duration: durations.lg } },
  { key: 'currency-update', title: 'Currency Update', options: { style: 'currency-update', duration: durations.md } },
  { key: 'stacked-realtime', title: 'Stacked Pulse', options: { style: 'stacked', duration: durations.lg } }
];

const rewardBasicCssVariants = () => [
  { key: 'coin-spin-soft', title: 'Coin Spin Soft', description: describeRewardBasic({ options: { style: 'coin-spin-soft' } }), options: { style: 'coin-spin-soft', duration: durations.md } },
  { key: 'coin-spin-fast', title: 'Coin Spin Fast', description: describeRewardBasic({ options: { style: 'coin-spin-fast' } }), options: { style: 'coin-spin-fast', duration: durations.sm } },
  { key: 'star-burst', title: 'Star Burst', description: describeRewardBasic({ options: { style: 'star-burst' } }), options: { style: 'star-burst', duration: durations.md } },
  { key: 'star-radiate', title: 'Star Radiate', description: describeRewardBasic({ options: { style: 'star-radiate' } }), options: { style: 'star-radiate', duration: durations.lg } },
  { key: 'glow-pulse', title: 'Glow Pulse', description: describeRewardBasic({ options: { style: 'glow-pulse' } }), options: { style: 'glow-pulse', duration: durations.lg } },
  { key: 'glow-orbit', title: 'Glow Orbit', description: describeRewardBasic({ options: { style: 'glow-orbit' } }), options: { style: 'glow-orbit', duration: durations.xl } },
  { key: 'bounce-soft', title: 'Bounce Soft', description: describeRewardBasic({ options: { style: 'bounce-soft' } }), options: { style: 'bounce-soft', duration: durations.md } },
  { key: 'bounce-energy', title: 'Bounce Energetic', description: describeRewardBasic({ options: { style: 'bounce-energy' } }), options: { style: 'bounce-energy', duration: durations.md } },
  { key: 'badge-glint', title: 'Badge Glint', description: describeRewardBasic({ options: { style: 'badge-glint' } }), options: { style: 'badge-glint', duration: durations.lg } },
  { key: 'badge-sweep', title: 'Badge Sweep', description: describeRewardBasic({ options: { style: 'badge-sweep' } }), options: { style: 'badge-sweep', duration: durations.lg } }
];

const rewardFeedbackCssVariants = () => [
  { key: 'button-success-pop', title: 'Button Success Pop', description: describeRewardFeedback({ options: { style: 'button-success' } }), options: { style: 'button-success', duration: durations.sm } },
  { key: 'button-success-spark', title: 'Button Success Spark', description: describeRewardFeedback({ options: { style: 'button-success-spark' } }), options: { style: 'button-success-spark', duration: durations.md } },
  { key: 'button-hover-tilt', title: 'Button Hover Tilt', description: describeRewardFeedback({ options: { style: 'button-hover-tilt' } }), options: { style: 'button-hover-tilt', duration: durations.sm } },
  { key: 'button-hover-glow', title: 'Button Hover Glow', description: describeRewardFeedback({ options: { style: 'button-hover-glow' } }), options: { style: 'button-hover-glow', duration: durations.sm } },
  { key: 'focus-ring', title: 'Focus Ring Pulse', description: describeRewardFeedback({ options: { style: 'focus-ring' } }), options: { style: 'focus-ring', duration: durations.md } },
  { key: 'click-ripple-soft', title: 'Click Ripple Soft', description: describeRewardFeedback({ options: { style: 'click-ripple-soft' } }), options: { style: 'click-ripple-soft', duration: durations.sm } },
  { key: 'click-ripple-strong', title: 'Click Ripple Strong', description: describeRewardFeedback({ options: { style: 'click-ripple-strong' } }), options: { style: 'click-ripple-strong', duration: durations.sm } },
  { key: 'tile-activate', title: 'Tile Activate', description: describeRewardFeedback({ options: { style: 'tile-activate' } }), options: { style: 'tile-activate', duration: durations.md } },
  { key: 'tile-press', title: 'Tile Press', description: describeRewardFeedback({ options: { style: 'tile-press' } }), options: { style: 'tile-press', duration: durations.md } },
  { key: 'glow-hover', title: 'Glow Hover', description: describeRewardFeedback({ options: { style: 'glow-hover' } }), options: { style: 'glow-hover', duration: durations.sm } }
];

const rewardMechanicsMotionVariants = () => [
  { key: 'wheel-spin', title: 'Wheel Spin', options: { style: 'wheel-spin', duration: 3200 } },
  { key: 'wheel-spin-fast', title: 'Wheel Spin Fast Stop', options: { style: 'wheel-spin-fast', duration: 2800 } },
  { key: 'chest-open', title: 'Chest Opening', options: { style: 'chest-open', duration: 2600 } },
  { key: 'chest-deluxe', title: 'Deluxe Chest', options: { style: 'chest-deluxe', duration: 2800 } },
  { key: 'card-flip', title: 'Card Flip', options: { style: 'card-flip', duration: 1800 } },
  { key: 'card-fan', title: 'Card Fan', options: { style: 'card-fan', duration: 2200 } },
  { key: 'scratch-card', title: 'Scratch Card', options: { style: 'scratch-card', duration: 2600 } },
  { key: 'slot-reels', title: 'Slot Reels', options: { style: 'slot-reels', duration: 3200 } },
  { key: 'dice-roll', title: 'Dice Roll', options: { style: 'dice-roll', duration: 2000 } },
  { key: 'mystery-box', title: 'Mystery Box', options: { style: 'mystery-box', duration: 2400 } },
  { key: 'map-path', title: 'Map Path', options: { style: 'map-path', duration: 2800 } },
  { key: 'collection-snap', title: 'Collection Snap', options: { style: 'collection-snap', duration: 2000 } },
  { key: 'loot-drop', title: 'Loot Drop', options: { style: 'loot-drop', duration: 2600 } },
  { key: 'jackpot-radiance', title: 'Jackpot Radiance', options: { style: 'jackpot-radiance', duration: 3000 } },
  { key: 'treasure-pulse', title: 'Treasure Pulse', options: { style: 'treasure-pulse', duration: 2300 } }
];

const rewardOrchestrationMotionVariants = () => [
  { key: 'coin-trail', title: 'Coin Trail', options: { style: 'coin-trail', duration: 2400 } },
  { key: 'coin-cascade', title: 'Coin Cascade', options: { style: 'coin-cascade', duration: 2600 } },
  { key: 'multi-coin', title: 'Multi Coin', options: { style: 'multi-coin', duration: 2600 } },
  { key: 'treasure-particles', title: 'Treasure Particles', options: { style: 'treasure-particles', duration: 2600 } },
  { key: 'unlock-chain', title: 'Unlock Chain', options: { style: 'unlock-chain', duration: 2600 } },
  { key: 'unlock-cascade', title: 'Unlock Cascade', options: { style: 'unlock-cascade', duration: 2600 } },
  { key: 'reward-path', title: 'Reward Path', options: { style: 'reward-path', duration: 2800 } },
  { key: 'jackpot-beam', title: 'Jackpot Beam', options: { style: 'jackpot-beam', duration: 2800 } },
  { key: 'map-travel', title: 'Map Travel', options: { style: 'map-travel', duration: 2800 } },
  { key: 'reward-celebration', title: 'Reward Celebration', options: { style: 'reward-celebration', duration: 3000 } }
];

const menuAnimationVariants = () => [
  { key: 'menu-drawer-slide', title: 'Drawer Slide', description: describeNavigation({ options: { style: 'drawer-slide' } }), options: { style: 'drawer-slide', duration: durations.lg } },
  { key: 'menu-drawer-scale', title: 'Drawer Scale', description: describeNavigation({ options: { style: 'drawer-scale' } }), options: { style: 'drawer-scale', duration: durations.lg } },
  { key: 'menu-dropdown', title: 'Dropdown Reveal', description: describeNavigation({ options: { style: 'dropdown' } }), options: { style: 'dropdown', duration: durations.md } },
  { key: 'menu-dropdown-soft', title: 'Dropdown Soft', description: describeNavigation({ options: { style: 'dropdown-soft' } }), options: { style: 'dropdown-soft', duration: durations.lg } },
  { key: 'menu-tab-ink', title: 'Tab Ink', description: describeNavigation({ options: { style: 'tab-ink' } }), options: { style: 'tab-ink', duration: durations.md } },
  { key: 'menu-tab-glide', title: 'Tab Glide', description: describeNavigation({ options: { style: 'tab-glide' } }), options: { style: 'tab-glide', duration: durations.lg } },
  { key: 'mobile-menu-transform', title: 'Mobile Transform', description: describeNavigation({ options: { style: 'mobile-transform' } }), options: { style: 'mobile-transform', duration: durations.lg } },
  { key: 'breadcrumb-flare', title: 'Breadcrumb Flare', description: describeNavigation({ options: { style: 'breadcrumb-flare' } }), options: { style: 'breadcrumb-flare', duration: durations.sm } },
  { key: 'breadcrumb-slide', title: 'Breadcrumb Slide', description: describeNavigation({ options: { style: 'breadcrumb-slide' } }), options: { style: 'breadcrumb-slide', duration: durations.md } },
  { key: 'sidebar-reveal', title: 'Sidebar Reveal', description: describeNavigation({ options: { style: 'sidebar-reveal' } }), options: { style: 'sidebar-reveal', duration: durations.lg } },
  { key: 'sidebar-floating', title: 'Sidebar Floating', description: describeNavigation({ options: { style: 'sidebar-floating' } }), options: { style: 'sidebar-floating', duration: durations.xl } },
  { key: 'nav-hover', title: 'Nav Hover Underline', description: describeNavigation({ options: { style: 'nav-hover' } }), options: { style: 'nav-hover', duration: durations.sm } }
];

const pageTransitionVariants = () => [
  { key: 'page-fade', title: 'Page Fade', description: describeNavigation({ options: { style: 'page-fade' } }), options: { style: 'page-fade', duration: durations.lg } },
  { key: 'page-slide-up', title: 'Page Slide Up', description: describeNavigation({ options: { style: 'page-slide-up' } }), options: { style: 'page-slide-up', duration: durations.lg } },
  { key: 'page-slide-right', title: 'Page Slide Right', description: describeNavigation({ options: { style: 'page-slide-right' } }), options: { style: 'page-slide-right', duration: durations.lg } },
  { key: 'page-scale', title: 'Page Scale', description: describeNavigation({ options: { style: 'page-scale' } }), options: { style: 'page-scale', duration: durations.lg } },
  { key: 'page-wipe', title: 'Page Wipe', description: describeNavigation({ options: { style: 'page-wipe' } }), options: { style: 'page-wipe', duration: durations.lg } },
  { key: 'section-reveal', title: 'Section Reveal', description: describeNavigation({ options: { style: 'section-reveal' } }), options: { style: 'section-reveal', duration: durations.md } },
  { key: 'section-rise', title: 'Section Rise', description: describeNavigation({ options: { style: 'section-rise' } }), options: { style: 'section-rise', duration: durations.md } },
  { key: 'lazy-entrance', title: 'Lazy Entrance', description: describeNavigation({ options: { style: 'lazy-entrance' } }), options: { style: 'lazy-entrance', duration: durations.lg } },
  { key: 'lazy-fade', title: 'Lazy Fade', description: describeNavigation({ options: { style: 'lazy-fade' } }), options: { style: 'lazy-fade', duration: durations.lg } },
  { key: 'scroll-reveal-soft', title: 'Scroll Reveal Soft', description: describeNavigation({ options: { style: 'scroll-reveal-soft' } }), options: { style: 'scroll-reveal-soft', duration: durations.lg } },
  { key: 'scroll-reveal-burst', title: 'Scroll Reveal Burst', description: describeNavigation({ options: { style: 'scroll-reveal-burst' } }), options: { style: 'scroll-reveal-burst', duration: durations.lg } },
  { key: 'hero-parallax', title: 'Hero Parallax', description: describeNavigation({ options: { style: 'hero-parallax' } }), options: { style: 'hero-parallax', duration: durations.xl } }
];

const complexNavMotionVariants = () => [
  { key: 'nav-morph', title: 'Nav Morph', options: { style: 'nav-morph', duration: durations.xl } },
  { key: 'nav-gesture', title: 'Gesture Menu', options: { style: 'nav-gesture', duration: durations.xl } },
  { key: 'nav-parallax', title: 'Nav Parallax', options: { style: 'nav-parallax', duration: durations.xl } },
  { key: 'nav-sticky', title: 'Sticky Transform', options: { style: 'nav-sticky', duration: durations.lg } },
  { key: 'nav-spotlight', title: 'Nav Spotlight', options: { style: 'nav-spotlight', duration: durations.lg } },
  { key: 'nav-orbit', title: 'Nav Orbit', options: { style: 'nav-orbit', duration: durations.xl } }
];

const layoutShiftMotionVariants = () => [
  { key: 'grid-reflow', title: 'Grid Reflow', options: { style: 'grid-reflow', duration: durations.xl } },
  { key: 'filter-flow', title: 'Filter Flow', options: { style: 'filter-flow', duration: durations.lg } },
  { key: 'sort-transition', title: 'Sort Transition', options: { style: 'sort-transition', duration: durations.lg } },
  { key: 'responsive-stack', title: 'Responsive Stack', options: { style: 'responsive-stack', duration: durations.xl } },
  { key: 'layout-panels', title: 'Layout Panels', options: { style: 'layout-panels', duration: durations.xl } }
];

const microInteractiveCssVariants = () => [
  'button-hover-glint','button-hover-rise','button-press','link-underline-slide','link-underline-fade','input-focus-glow','input-focus-slide','checkbox-check','checkbox-bounce','radio-fill','radio-bounce','toggle-slide','toggle-pulse','tooltip-fade','tooltip-pop','badge-pulse','badge-bounce','icon-hover-tilt','icon-hover-spin','tab-hover'
].map((style) => ({ key: style, title: style.replace(/-/g, ' ').replace(/\w/g, (m) => m.toUpperCase()), description: describeMicroInteractive({ options: { style } }), options: { style, duration: durations.sm } }));

const microStateCssVariants = () => [
  'loading-to-loaded','empty-to-populated','error-to-success','enable-disable','selected-state','validation-pass','validation-fail','tab-change','card-hover','card-select','list-item-activate','list-item-success','chip-entry','chip-exit','pill-glow','badge-complete','list-sort','avatar-online'
].map((style) => ({ key: style, title: style.replace(/-/g, ' ').replace(/\w/g, (m) => m.toUpperCase()), description: describeMicroState({ options: { style } }), options: { style, duration: style.includes('chip') ? durations.sm : durations.md } }));

const microAdvancedMotionVariants = () => [
  { key: 'drag-card', title: 'Drag Card Elastic', options: { style: 'drag-card', duration: durations.lg } },
  { key: 'drag-snap', title: 'Drag Snap Slot', options: { style: 'drag-snap', duration: durations.lg } },
  { key: 'swipe-dismiss', title: 'Swipe Dismiss', options: { style: 'swipe-dismiss', duration: durations.lg } },
  { key: 'pull-to-refresh', title: 'Pull To Refresh', options: { style: 'pull-to-refresh', duration: durations.xl } },
  { key: 'long-press', title: 'Long Press Ripple', options: { style: 'long-press', duration: durations.md } },
  { key: 'pinch-zoom', title: 'Pinch Zoom', options: { style: 'pinch-zoom', duration: durations.xl } },
  { key: 'magnetic-hover', title: 'Magnetic Hover', options: { style: 'magnetic-hover', duration: durations.xl } }
];

const basicChartCssVariants = () => [
  'bar-chart-rise','bar-chart-stack','line-chart-draw','line-chart-dash','pie-chart-slice','pie-chart-rotate','stat-count','stat-flip','delta-glow','rank-slide','trend-highlight','gauge-sweep'
].map((style) => ({ key: style, title: style.replace(/-/g, ' ').replace(/\w/g, (m) => m.toUpperCase()), description: `Data viz: ${style.replace(/-/g, ' ')}`, options: { style, duration: style.includes('stat') ? durations.md : durations.lg } }));

const interactiveDataMotionVariants = () => [
  { key: 'tournament-bracket', title: 'Tournament Bracket', options: { style: 'tournament-bracket', duration: durations.xl } },
  { key: 'heat-map', title: 'Heat Map', options: { style: 'heat-map', duration: durations.xl } },
  { key: 'network-graph', title: 'Network Graph', options: { style: 'network-graph', duration: durations.xl } },
  { key: 'comparison-charts', title: 'Comparison Chart', options: { style: 'comparison-charts', duration: durations.xl } },
  { key: 'live-stream', title: 'Live Data Stream', options: { style: 'live-stream', duration: durations.xxl } },
  { key: 'radar-sweep', title: 'Radar Sweep', options: { style: 'radar-sweep', duration: durations.xxl } },
  { key: 'bracket-highlight', title: 'Bracket Highlight', options: { style: 'bracket-highlight', duration: durations.xl } },
  { key: 'scoreboard-update', title: 'Scoreboard Update', options: { style: 'scoreboard-update', duration: durations.lg } },
  { key: 'payout-curve', title: 'Payout Curve', options: { style: 'payout-curve', duration: durations.xl } },
  { key: 'victory-flash', title: 'Victory Flash', options: { style: 'victory-flash', duration: durations.xl } },
  { key: 'combo-surge', title: 'Combo Surge', options: { style: 'combo-surge', duration: durations.xl } },
  { key: 'tier-ladder', title: 'Tier Ladder', options: { style: 'tier-ladder', duration: durations.xl } },
  { key: 'performance-loop', title: 'Performance Loop', options: { style: 'performance-loop', duration: durations.xxl } }
];

const ambientCssVariants = () => [
  { key: 'gradient-shift', title: 'Gradient Shift', description: describeAmbient({ options: { style: 'gradient-shift' } }), options: { style: 'gradient-shift', duration: durations.xxl } },
  { key: 'floating-particles', title: 'Floating Particles', description: describeAmbient({ options: { style: 'floating-particles' } }), options: { style: 'floating-particles', duration: durations.xxl } },
  { key: 'parallax-layers', title: 'Parallax Layers', description: describeAmbient({ options: { style: 'parallax-layers' } }), options: { style: 'parallax-layers', duration: durations.xxl } },
  { key: 'ken-burns', title: 'Ken Burns', description: describeAmbient({ options: { style: 'ken-burns' } }), options: { style: 'ken-burns', duration: durations.xxl } },
  { key: 'ambient-glow', title: 'Ambient Glow', description: describeAmbient({ options: { style: 'ambient-glow' } }), options: { style: 'ambient-glow', duration: durations.xxl } },
  { key: 'ambient-aurora', title: 'Ambient Aurora', description: describeAmbient({ options: { style: 'ambient-aurora' } }), options: { style: 'ambient-aurora', duration: durations.xxl } }
];

const ambientMotionVariants = () => [
  { key: 'confetti-loop', title: 'Confetti Loop', options: { style: 'confetti-loop', duration: durations.xxl } },
  { key: 'snowfall', title: 'Snowfall', options: { style: 'snowfall', duration: durations.xxl } },
  { key: 'rainfall', title: 'Rainfall', options: { style: 'rainfall', duration: durations.xxl } },
  { key: 'fireworks-grand', title: 'Fireworks Grand', options: { style: 'fireworks-grand', duration: durations.xxl } },
  { key: 'magic-sparkles', title: 'Magic Sparkles', options: { style: 'magic-sparkles', duration: durations.xxl } },
  { key: 'portal-rings', title: 'Portal Rings', options: { style: 'portal-rings', duration: durations.xxl } },
  { key: 'light-rays', title: 'Light Rays', options: { style: 'light-rays', duration: durations.xxl } },
  { key: 'smoke-plumes', title: 'Smoke Plumes', options: { style: 'smoke-plumes', duration: durations.xxl } },
  { key: 'water-ripples', title: 'Water Ripples', options: { style: 'water-ripples', duration: durations.xxl } },
  { key: 'fire-lift', title: 'Fire Lift', options: { style: 'fire-lift', duration: durations.xxl } },
  { key: 'spark-trail', title: 'Spark Trail', options: { style: 'spark-trail', duration: durations.xxl } },
  { key: 'nebula-swell', title: 'Nebula Swell', options: { style: 'nebula-swell', duration: durations.xxl } },
  { key: 'energy-orbit', title: 'Energy Orbit', options: { style: 'energy-orbit', duration: durations.xxl } },
  { key: 'stardust', title: 'Stardust Cascade', options: { style: 'stardust', duration: durations.xxl } },
  { key: 'aura-pulse', title: 'Aura Pulse', options: { style: 'aura-pulse', duration: durations.xxl } },
  { key: 'galaxy-spiral', title: 'Galaxy Spiral', options: { style: 'galaxy-spiral', duration: durations.xxl } }
];


const enrichVariant = (variant, context) => {
  const { categoryId, groupId, groupTitle, tech, demo } = context;
  const { options } = variant;
  const id = `${groupId}__${variant.key}`;
  const description = variant.description || `${groupTitle} pattern: ${variant.title}`;
  return {
    id,
    key: variant.key,
    title: variant.title,
    description,
    tech,
    demo,
    categoryId,
    groupId,
    options,
    durationMs: options?.duration ?? durations.md,
    easing: options?.easing,
    easingLabel: options?.easingKey ? easingLabels[options.easingKey] : undefined
  };
};

const createGroup = ({ categoryId, groupId, title, tech, demo, generator }) => {
  const variants = generator().map((variant) => enrichVariant(variant, { categoryId, groupId, groupTitle: title, tech, demo }));
  return {
    id: groupId,
    title,
    tech,
    demo,
    count: variants.length,
    variants
  };
};

const createCatalogData = () => {
  const categories = [];

  const dialogs = {
    id: 'dialogs',
    title: 'Dialog & Modal Animations',
    groups: [
      createGroup({ categoryId: 'dialogs', groupId: 'modal-base', title: 'Base modal animations', tech: 'css', demo: 'modalBase', generator: modalBaseVariants }),
      createGroup({ categoryId: 'dialogs', groupId: 'modal-content', title: 'Content choreography', tech: 'css', demo: 'modalContent', generator: modalContentVariants }),
      createGroup({ categoryId: 'dialogs', groupId: 'modal-dismiss', title: 'Auto-dismiss patterns', tech: 'css', demo: 'toast', generator: modalDismissVariants }),
      createGroup({ categoryId: 'dialogs', groupId: 'modal-orchestration', title: 'Complex orchestrations', tech: 'framer', demo: 'wizard', generator: modalOrchestrationVariants }),
      createGroup({ categoryId: 'dialogs', groupId: 'modal-celebrations', title: 'Celebration effects', tech: 'framer', demo: 'celebration', generator: modalCelebrationVariants })
    ]
  };

  const progress = {
    id: 'progress',
    title: 'Progress & Loading Animations',
    groups: [
      createGroup({ categoryId: 'progress', groupId: 'progress-bars', title: 'Progress bars', tech: 'css', demo: 'progressBar', generator: progressBarVariants }),
      createGroup({ categoryId: 'progress', groupId: 'loading-states', title: 'Loading states', tech: 'css', demo: 'loader', generator: loadingStateVariants }),
      createGroup({ categoryId: 'progress', groupId: 'progress-dynamic', title: 'Dynamic progress', tech: 'framer', demo: 'progressDynamic', generator: dynamicProgressMotionVariants }),
      createGroup({ categoryId: 'progress', groupId: 'milestone-celebrations', title: 'Milestone celebrations', tech: 'framer', demo: 'progressMilestone', generator: milestoneCelebrationVariants })
    ]
  };

  const realtime = {
    id: 'realtime',
    title: 'Real-time Updates & Timers',
    groups: [
      createGroup({ categoryId: 'realtime', groupId: 'timer-effects', title: 'Timer effects', tech: 'css', demo: 'timer', generator: timerEffectsVariants }),
      createGroup({ categoryId: 'realtime', groupId: 'update-indicators', title: 'Update indicators', tech: 'css', demo: 'updateIndicator', generator: updateIndicatorsVariants }),
      createGroup({ categoryId: 'realtime', groupId: 'complex-timers', title: 'Complex timers', tech: 'framer', demo: 'timerComplex', generator: complexTimerMotionVariants }),
      createGroup({ categoryId: 'realtime', groupId: 'realtime-data', title: 'Real-time data', tech: 'framer', demo: 'realtimeData', generator: realtimeDataMotionVariants })
    ]
  };

  const rewards = {
    id: 'rewards',
    title: 'Game Elements & Rewards',
    groups: [
      createGroup({ categoryId: 'rewards', groupId: 'reward-basic', title: 'Basic rewards', tech: 'css', demo: 'rewardBasic', generator: rewardBasicCssVariants }),
      createGroup({ categoryId: 'rewards', groupId: 'reward-feedback', title: 'UI feedback', tech: 'css', demo: 'rewardFeedback', generator: rewardFeedbackCssVariants }),
      createGroup({ categoryId: 'rewards', groupId: 'reward-mechanics', title: 'Reward mechanics', tech: 'framer', demo: 'rewardMechanic', generator: rewardMechanicsMotionVariants }),
      createGroup({ categoryId: 'rewards', groupId: 'reward-orchestrations', title: 'Reward orchestrations', tech: 'framer', demo: 'rewardOrchestration', generator: rewardOrchestrationMotionVariants })
    ]
  };

  const navigation = {
    id: 'navigation',
    title: 'Navigation & Layout',
    groups: [
      createGroup({ categoryId: 'navigation', groupId: 'menu-animations', title: 'Menu animations', tech: 'css', demo: 'navigationMenu', generator: menuAnimationVariants }),
      createGroup({ categoryId: 'navigation', groupId: 'page-transitions', title: 'Page transitions', tech: 'css', demo: 'pageTransition', generator: pageTransitionVariants }),
      createGroup({ categoryId: 'navigation', groupId: 'complex-navigation', title: 'Advanced navigation', tech: 'framer', demo: 'navigationComplex', generator: complexNavMotionVariants }),
      createGroup({ categoryId: 'navigation', groupId: 'layout-shifts', title: 'Layout shifts', tech: 'framer', demo: 'layoutShift', generator: layoutShiftMotionVariants })
    ]
  };

  const micro = {
    id: 'micro',
    title: 'Micro-interactions',
    groups: [
      createGroup({ categoryId: 'micro', groupId: 'interactive-feedback', title: 'Interactive feedback', tech: 'css', demo: 'microInteractive', generator: microInteractiveCssVariants }),
      createGroup({ categoryId: 'micro', groupId: 'state-changes', title: 'State changes', tech: 'css', demo: 'microState', generator: microStateCssVariants }),
      createGroup({ categoryId: 'micro', groupId: 'advanced-interactions', title: 'Advanced interactions', tech: 'framer', demo: 'microAdvanced', generator: microAdvancedMotionVariants })
    ]
  };

  const dataViz = {
    id: 'data',
    title: 'Data Visualization',
    groups: [
      createGroup({ categoryId: 'data', groupId: 'basic-charts', title: 'Basic charts', tech: 'css', demo: 'dataBasic', generator: basicChartCssVariants }),
      createGroup({ categoryId: 'data', groupId: 'interactive-visuals', title: 'Interactive visuals', tech: 'framer', demo: 'dataInteractive', generator: interactiveDataMotionVariants })
    ]
  };

  const ambient = {
    id: 'ambient',
    title: 'Special Effects & Atmosphere',
    groups: [
      createGroup({ categoryId: 'ambient', groupId: 'ambient-effects', title: 'Ambient effects', tech: 'css', demo: 'ambientBase', generator: ambientCssVariants }),
      createGroup({ categoryId: 'ambient', groupId: 'advanced-effects', title: 'Advanced effects', tech: 'framer', demo: 'ambientAdvanced', generator: ambientMotionVariants })
    ]
  };

  categories.push(dialogs, progress, realtime, rewards, navigation, micro, dataViz, ambient);
  const entries = categories.flatMap((category) => category.groups.flatMap((group) => group.variants));
  return { categories, entries };
};


const factoryMap = {};

const createModalShell = (titleText = 'Quest Victory', bodyLines = []) => {
  const overlay = createEl('div', 'pf-modal-overlay');
  const modal = createEl('div', 'pf-modal');
  const header = createEl('div', 'pf-modal__header');
  const title = createEl('h4', 'pf-modal__title', { text: titleText });
  const badge = createEl('span', 'pf-badge-tech', { text: 'Modal' });
  const body = createEl('div', 'pf-modal__body');
  bodyLines.forEach((line) => body.appendChild(createEl('p', '', { text: line })));
  const footer = createEl('div', 'pf-modal__footer');
  footer.appendChild(createEl('button', 'pf-button-primary', { text: 'Accept' }));
  footer.appendChild(createEl('button', 'pf-button-secondary', { text: 'Later' }));
  header.append(title, badge);
  modal.append(header, body, footer);
  overlay.appendChild(modal);
  return { overlay, modal, body, footer };
};

factoryMap.modalBase = (entry) => {
  const { overlay, modal } = createModalShell('New Creator Quest', ['Complete 3 live sessions to unlock rewards.']);
  const options = entry.options;
  const animationName = `pf-modal-${entry.id}`;
  const startX = options.axis === 'x' ? `${options.distance}px` : '0px';
  const startY = options.axis === 'y' ? `${options.distance}px` : '0px';
  const midX = options.axis === 'x' ? `${options.overshoot || 0}px` : '0px';
  const midY = options.axis === 'y' ? `${options.overshoot || 0}px` : '0px';
  const scaleStart = options.scaleFrom ?? 0.94;
  const scaleMid = options.scaleMid ?? 1.02;
  const scaleEnd = options.scaleTo ?? 1;
  const blurStart = `${options.blurStart || 0}px`;
  const blurMid = `${options.blurMid || 0}px`;
  const blurEnd = `${options.blurEnd || 0}px`;

  setCssVars(modal, {
    '--pf-modal-tx-start': startX,
    '--pf-modal-ty-start': startY,
    '--pf-modal-tx-mid': midX,
    '--pf-modal-ty-mid': midY,
    '--pf-modal-scale-start': scaleStart,
    '--pf-modal-scale-mid': scaleMid,
    '--pf-modal-scale-end': scaleEnd,
    '--pf-modal-blur-start': blurStart,
    '--pf-modal-blur-mid': blurMid,
    '--pf-modal-blur-end': blurEnd
  });

  overlay.style.setProperty('--pf-overlay-opacity', options.overlayOpacity ?? 0.72);

  animationKeyframes.ensureRule(animationName, `
    0% {
      transform: translate(-50%, -50%) translate(var(--pf-modal-tx-start), var(--pf-modal-ty-start)) scale(var(--pf-modal-scale-start));
      opacity: 0;
      filter: blur(var(--pf-modal-blur-start));
    }
    65% {
      transform: translate(-50%, -50%) translate(var(--pf-modal-tx-mid), var(--pf-modal-ty-mid)) scale(var(--pf-modal-scale-mid));
      opacity: 1;
      filter: blur(var(--pf-modal-blur-mid));
    }
    100% {
      transform: translate(-50%, -50%) scale(var(--pf-modal-scale-end));
      opacity: 1;
      filter: blur(var(--pf-modal-blur-end));
    }
  `);

  const play = () => {
    if (state.reducedMotion) {
      overlay.style.backgroundColor = 'rgba(29,9,47,' + (options.overlayOpacity ?? 0.72) + ')';
      modal.style.transform = 'translate(-50%, -50%) scale(1)';
      modal.style.opacity = '1';
      return;
    }
    overlay.style.animation = 'none';
    modal.style.animation = 'none';
    // force reflow
    void overlay.offsetWidth;
    overlay.style.animation = `pf-overlay-fade ${options.duration}ms ${options.easing} forwards`;
    modal.style.animation = `${animationName} ${options.duration}ms ${options.easing} both`;
  };

  return { element: overlay, play, height: "360px" };
};

factoryMap.modalContent = (entry) => {
  const lines = ['Build trust by sequencing content reveals.', 'Keep focus with 70ms cadence.'];
  const { overlay, modal, body, footer } = createModalShell('Sequence Control', lines);
  const bodyOptions = entry.options;

  // Create wrapper container to properly contain the modal for content choreography
  const wrapper = createEl('div', '');
  wrapper.style.position = 'relative';
  wrapper.style.width = '100%';
  wrapper.style.height = '420px';
  wrapper.style.overflow = 'hidden'; // This will clip any overflow
  wrapper.style.display = 'grid';
  wrapper.style.placeItems = 'center';

  // Keep overlay absolute positioning to work within wrapper
  overlay.style.position = 'absolute';
  overlay.style.inset = '0';

  // The modal will position absolutely within the wrapper boundaries
  wrapper.appendChild(overlay);

  const listContainer = createEl('div', '', {});

  const applyStagger = (elements, baseDelay, animationName, extra = {}) => {
    elements.forEach((el, index) => {
      const delay = baseDelay * index;
      el.style.animation = 'none';
      void el.offsetWidth;
      const finalName = `${animationName}-${entry.id}`;
      if (!extra.skipKeyframe) {
        animationKeyframes.ensureRule(finalName, extra.frames);
      }
      el.style.animation = `${finalName} ${bodyOptions.duration}ms ${bodyOptions.easing} ${extra.fill || 'forwards'} ${delay}ms`;
    });
  };

  if (bodyOptions.layout === 'buttons' || bodyOptions.layout === 'buttons-wave') {
    footer.innerHTML = '';
    for (let i = 0; i < bodyOptions.count; i += 1) {
      const btn = createEl('button', i === 0 ? 'pf-button-primary' : 'pf-button-secondary', { text: i === 0 ? 'Primary' : 'Secondary' });
      footer.appendChild(btn);
    }
    const frames = bodyOptions.layout === 'buttons-wave'
      ? `0% { transform: translateY(20px); opacity: 0; }
         50% { transform: translateY(-${bodyOptions.distance}px); opacity: 1; }
         100% { transform: translateY(0); opacity: 1; }`
      : `0% { transform: translateY(${bodyOptions.distance}px) scale(${bodyOptions.startScale}); opacity: 0; }
         60% { transform: translateY(-6px) scale(${bodyOptions.endScale + 0.06}); opacity: 1; }
         100% { transform: translateY(0) scale(${bodyOptions.endScale}); opacity: 1; }`;
    applyStagger(Array.from(footer.children), bodyOptions.baseDelay, 'pf-modal-button-stagger', { frames });
  } else if (bodyOptions.layout?.startsWith('list')) {
    listContainer.className = 'pf-modal-list';
    const total = bodyOptions.items || 4;
    for (let i = 0; i < total; i += 1) {
      listContainer.appendChild(createEl('div', 'pf-modal-list-item', { text: `Milestone ${i + 1}` }));
    }
    body.appendChild(listContainer);
    const frames = `0% { transform: translateY(16px); opacity: 0; }
                    70% { transform: translateY(-4px); opacity: 1; }
                    100% { transform: translateY(0); opacity: 1; }`;
    applyStagger(Array.from(listContainer.children), bodyOptions.baseDelay || 70, 'pf-modal-list-stagger', { frames });
  } else if (bodyOptions.layout === 'form' || bodyOptions.layout === 'form-gradient' || bodyOptions.layout === 'form-stack') {
    const form = createEl('div', 'pf-modal-form');
    for (let i = 0; i < (bodyOptions.fields || 3); i += 1) {
      const field = createEl('div', 'pf-modal-field');
      field.appendChild(createEl('label', '', { text: `Field ${i + 1}` }));
      field.appendChild(createEl('input', '', { type: 'text', value: 'Input' }));
      form.appendChild(field);
    }
    body.appendChild(form);
    const frames = `0% { transform: translate${bodyOptions.direction === 'left' ? 'X(32px)' : 'X(-32px)'}; opacity: 0; }
                    100% { transform: translateX(0); opacity: 1; }`;
    applyStagger(Array.from(form.children), 90, 'pf-modal-form-stagger', { frames });
  } else if (bodyOptions.layout === 'feedback') {
    const message = createEl('div', 'pf-modal-feedback', { text: bodyOptions.type === 'error' ? 'Incorrect token, try again.' : 'Profile saved successfully!' });
    body.appendChild(message);

    let frames;
    if (bodyOptions.type === 'error') {
      // Generate shake with correct number of oscillations
      const oscillations = bodyOptions.frequency || 5;
      const amplitude = bodyOptions.amplitude || 12;
      const keyframes = ['0% { transform: translateX(0); }'];

      for (let i = 1; i <= oscillations; i++) {
        const progress = (i / oscillations) * 100;
        const decayFactor = 1 - (i - 1) / oscillations; // Decay amplitude over time
        const currentAmplitude = amplitude * decayFactor;

        // Add both left and right shake for each oscillation
        const leftProgress = progress - (50 / oscillations);
        const rightProgress = progress;

        if (leftProgress > 0) {
          keyframes.push(`${leftProgress.toFixed(1)}% { transform: translateX(${currentAmplitude}px); }`);
        }
        keyframes.push(`${rightProgress.toFixed(1)}% { transform: translateX(-${currentAmplitude}px); }`);
      }
      keyframes.push('100% { transform: translateX(0); }');
      frames = keyframes.join('\n');
    } else {
      // Success bounce with proper translateY movement
      const bounceHeight = 30 + (bodyOptions.bounce * 100); // Base height + overshoot
      frames = `0% { transform: translateY(0); }
         25% { transform: translateY(-${bounceHeight}px); }
         50% { transform: translateY(0); }
         65% { transform: translateY(-${bounceHeight * 0.5}px); }
         80% { transform: translateY(0); }
         90% { transform: translateY(-${bounceHeight * 0.25}px); }
         100% { transform: translateY(0); }`;
    }

    animationKeyframes.ensureRule(`pf-modal-feedback-${entry.id}`, frames);
    message.style.animation = `${`pf-modal-feedback-${entry.id}` } ${bodyOptions.duration}ms ${bodyOptions.easing || easingCurves.pop}`;
  }

  const play = () => {
    if (state.reducedMotion) {
      Array.from(footer.children).forEach((btn) => {
        btn.style.opacity = '1';
        btn.style.transform = 'none';
      });
      Array.from(body.querySelectorAll('.pf-modal-list-item, .pf-modal-field, .pf-modal-feedback')).forEach((el) => {
        el.style.opacity = '1';
        el.style.transform = 'none';
      });
      return;
    }
    // Remove animations to restart
    Array.from(footer.children).forEach((btn) => { btn.style.animation = 'none'; void btn.offsetWidth; });
    Array.from(body.querySelectorAll('.pf-modal-list-item, .pf-modal-field, .pf-modal-feedback')).forEach((el) => { el.style.animation = 'none'; void el.offsetWidth; });
    // retrigger by calling same logic again via requestAnimationFrame
    requestAnimationFrame(() => {
      if (bodyOptions.layout === 'feedback') {
        const message = body.querySelector('.pf-modal-feedback');
        if (message) {
          let frames;
          if (bodyOptions.type === 'error') {
            // Generate shake with correct number of oscillations
            const oscillations = bodyOptions.frequency || 5;
            const amplitude = bodyOptions.amplitude || 12;
            const keyframes = ['0% { transform: translateX(0); }'];

            for (let i = 1; i <= oscillations; i++) {
              const progress = (i / oscillations) * 100;
              const decayFactor = 1 - (i - 1) / oscillations; // Decay amplitude over time
              const currentAmplitude = amplitude * decayFactor;

              // Add both left and right shake for each oscillation
              const leftProgress = progress - (50 / oscillations);
              const rightProgress = progress;

              if (leftProgress > 0) {
                keyframes.push(`${leftProgress.toFixed(1)}% { transform: translateX(${currentAmplitude}px); }`);
              }
              keyframes.push(`${rightProgress.toFixed(1)}% { transform: translateX(-${currentAmplitude}px); }`);
            }
            keyframes.push('100% { transform: translateX(0); }');
            frames = keyframes.join('\n');
          } else {
            // Success bounce with proper translateY movement
            const bounceHeight = 30 + (bodyOptions.bounce * 100); // Base height + overshoot
            frames = `0% { transform: translateY(0); }
               25% { transform: translateY(-${bounceHeight}px); }
               50% { transform: translateY(0); }
               65% { transform: translateY(-${bounceHeight * 0.5}px); }
               80% { transform: translateY(0); }
               90% { transform: translateY(-${bounceHeight * 0.25}px); }
               100% { transform: translateY(0); }`;
          }
          animationKeyframes.ensureRule(`pf-modal-feedback-${entry.id}`, frames);
          message.style.animation = `pf-modal-feedback-${entry.id} ${bodyOptions.duration}ms ${bodyOptions.easing || easingCurves.pop}`;
        }
      }
      if (bodyOptions.layout === 'buttons' || bodyOptions.layout === 'buttons-wave') {
        const frames = bodyOptions.layout === 'buttons-wave'
          ? `0% { transform: translateY(20px); opacity: 0; }
             50% { transform: translateY(-${bodyOptions.distance}px); opacity: 1; }
             100% { transform: translateY(0); opacity: 1; }`
          : `0% { transform: translateY(${bodyOptions.distance}px) scale(${bodyOptions.startScale}); opacity: 0; }
             60% { transform: translateY(-6px) scale(${bodyOptions.endScale + 0.06}); opacity: 1; }
             100% { transform: translateY(0) scale(${bodyOptions.endScale}); opacity: 1; }`;
        applyStagger(Array.from(footer.children), bodyOptions.baseDelay, 'pf-modal-button-stagger', { frames });
      }
      if (bodyOptions.layout?.startsWith('list')) {
        const frames = `0% { transform: translateY(16px); opacity: 0; }
                        70% { transform: translateY(-4px); opacity: 1; }
                        100% { transform: translateY(0); opacity: 1; }`;
        applyStagger(Array.from(body.querySelectorAll('.pf-modal-list-item')), bodyOptions.baseDelay || 70, 'pf-modal-list-stagger', { frames });
      }
      if (bodyOptions.layout?.startsWith('form')) {
        const frames = `0% { transform: translate${bodyOptions.direction === 'left' ? 'X(32px)' : 'X(-32px)'}; opacity: 0; }
                        100% { transform: translateX(0); opacity: 1; }`;
        applyStagger(Array.from(body.querySelectorAll('.pf-modal-field')), 90, 'pf-modal-form-stagger', { frames });
      }
    });
  };

  return { element: wrapper, play, height: "420px" };
};


const createToast = (entry) => {
  const wrap = createEl('div', 'pf-toast');
  wrap.appendChild(createEl('div', 'pf-toast__title', { text: 'Reward ready' }));
  wrap.appendChild(createEl('p', '', { text: 'Your bonus credits are unlocked.' }));
  const progress = createEl('div', 'pf-toast__progress');
  const progressBar = createEl('div', 'pf-toast__progress-bar');
  progress.appendChild(progressBar);
  wrap.appendChild(progress);
  return { wrap, progressBar };
};

factoryMap.toast = (entry) => {
  const { wrap, progressBar } = createToast(entry);
  const opts = entry.options || {};
  const direction = opts.direction || 'left';
  const autoDismissMs = opts.autoDismiss ?? 4000;
  const entryDuration = opts.duration ?? durations.md;
  const exitDuration = Math.min(360, Math.max(220, Math.round(entryDuration * 0.75)));
  const shouldAnimateProgress = opts.progress !== false;
  const hasSparkHighlight = direction === 'burst';
  const hasScalePulse = direction === 'scale';

  const burstOverlay = hasSparkHighlight ? createEl('span', 'pf-toast__burst-overlay') : null;
  if (burstOverlay) {
    wrap.appendChild(burstOverlay);
  }

  let dismissTimer = null;

  const resetBurstOverlay = () => {
    if (!burstOverlay) return;
    burstOverlay.style.opacity = '0';
    burstOverlay.innerHTML = '';
  };

  const playBurstOverlay = () => {
    if (!burstOverlay) return;
    burstOverlay.innerHTML = '';
    if (state.reducedMotion) {
      burstOverlay.style.opacity = '0.35';
      burstOverlay.appendChild(createEl('span', 'pf-toast__burst-halo'));
      wrap.style.boxShadow = '0 12px 28px rgba(200, 53, 88, 0.24)';
      return;
    }

    burstOverlay.style.opacity = '1';
    wrap.style.boxShadow = '0 18px 40px rgba(200, 53, 88, 0.32)';

    const halo = createEl('span', 'pf-toast__burst-halo');
    burstOverlay.appendChild(halo);
    halo.animate(
      [
        { transform: 'translate(-50%, -50%) scale(0.3)', opacity: 0 },
        { transform: 'translate(-50%, -50%) scale(1)', opacity: 0.6, filter: 'blur(0px)', offset: 0.45 },
        { transform: 'translate(-50%, -50%) scale(1.45)', opacity: 0, filter: 'blur(10px)' }
      ],
      { duration: entryDuration + 140, easing: easingCurves.vibrant }
    );

    for (let i = 0; i < 6; i += 1) {
      const spark = createEl('span', 'pf-toast__burst-spark');
      const angle = i * 60;
      spark.style.transform = `translate(-50%, -50%) rotate(${angle}deg) scaleY(0.2)`;
      burstOverlay.appendChild(spark);
      spark.animate(
        [
          { opacity: 0, transform: `translate(-50%, -50%) rotate(${angle}deg) scaleY(0.2)` },
          { opacity: 1, transform: `translate(-50%, -50%) rotate(${angle}deg) scaleY(1)` , offset: 0.35 },
          { opacity: 0, transform: `translate(-50%, -50%) rotate(${angle}deg) scaleY(0.2)` }
        ],
        { duration: entryDuration + 120, easing: easingCurves.vibrant, delay: i * 60 }
      );
    }

    for (let i = 0; i < 4; i += 1) {
      const dot = createEl('span', 'pf-toast__burst-dot');
      const angle = (Math.PI / 2) * i;
      const radius = 70;
      const tx = Math.cos(angle) * radius;
      const ty = Math.sin(angle) * radius;
      dot.style.transform = `translate(-50%, -50%) translate(${tx}px, ${ty}px)`;
      burstOverlay.appendChild(dot);
      dot.animate(
        [
          { opacity: 0, transform: `translate(-50%, -50%) translate(${tx}px, ${ty}px) scale(0.6)` },
          { opacity: 1, transform: `translate(-50%, -50%) translate(${tx}px, ${ty}px) scale(1.1)`, offset: 0.4 },
          { opacity: 0, transform: `translate(-50%, -50%) translate(${tx * 1.25}px, ${ty * 1.25}px) scale(0.6)` }
        ],
        { duration: entryDuration + 200, easing: easingCurves.gentle, delay: 120 + i * 80 }
      );
    }
  };

  const clearTimers = () => {
    if (dismissTimer) {
      clearTimeout(dismissTimer);
      dismissTimer = null;
    }
  };

  const clearAnimations = () => {
    wrap.getAnimations().forEach((anim) => anim.cancel());
    progressBar.getAnimations().forEach((anim) => anim.cancel());
    if (burstOverlay) {
      burstOverlay.getAnimations().forEach((anim) => anim.cancel());
      burstOverlay.querySelectorAll('*').forEach((node) => node.getAnimations().forEach((anim) => anim.cancel()));
    }
  };

  const setBaseState = () => {
    wrap.style.opacity = '0';
    wrap.style.transform = 'translate3d(0, 0, 0) scale(1)';
    wrap.style.removeProperty('clipPath');
    progressBar.style.transform = 'scaleX(1)';
    resetBurstOverlay();
  };

  setBaseState();
  wrap.style.transformOrigin = 'center';

  const directionalEnter = (axis, start, overshoot) => [
    { transform: axis === 'x' ? `translate3d(${start}, 0, 0) scale(0.96)` : `translate3d(0, ${start}, 0) scale(0.96)`, opacity: 0 },
    { transform: axis === 'x' ? `translate3d(${overshoot}, 0, 0) scale(1.02)` : `translate3d(0, ${overshoot}, 0) scale(1.02)`, opacity: 1, offset: 0.7 },
    { transform: 'translate3d(0, 0, 0) scale(1)', opacity: 1 }
  ];

  const directionalExit = (axis, mid, end) => [
    { transform: 'translate3d(0, 0, 0) scale(1)', opacity: 1 },
    { transform: axis === 'x' ? `translate3d(${mid}, 0, 0) scale(0.98)` : `translate3d(0, ${mid}, 0) scale(0.98)`, opacity: 0.9, offset: 0.5 },
    { transform: axis === 'x' ? `translate3d(${end}, 0, 0) scale(0.9)` : `translate3d(0, ${end}, 0) scale(0.9)`, opacity: 0 }
  ];

  const getEnterAnimation = () => {
    switch (direction) {
      case 'left':
        return { keyframes: directionalEnter('x', '-140%', '8%'), options: { duration: entryDuration, easing: opts.easing || easingCurves.standard } };
      case 'right':
        return { keyframes: directionalEnter('x', '140%', '-6%'), options: { duration: entryDuration, easing: opts.easing || easingCurves.standard } };
      case 'down':
        return { keyframes: directionalEnter('y', '-120%', '10%'), options: { duration: entryDuration, easing: opts.easing || easingCurves.entrance } };
      case 'up':
        return { keyframes: directionalEnter('y', '120%', '-8%'), options: { duration: entryDuration, easing: opts.easing || easingCurves.entrance } };
      case 'wipe':
        return {
          keyframes: [
            { transform: 'translate3d(0, 24px, 0) scale(0.96)', opacity: 0, clipPath: 'inset(0 0 0 100%)' },
            { transform: 'translate3d(0, -4px, 0) scale(1.02)', opacity: 1, clipPath: 'inset(0 0 0 0)', offset: 0.7 },
            { transform: 'translate3d(0, 0, 0) scale(1)', opacity: 1, clipPath: 'inset(0 0 0 0)' }
          ],
          options: { duration: entryDuration, easing: opts.easing || easingCurves.entrance }
        };
      case 'scale':
        return {
          keyframes: [
            { transform: 'translate3d(0, 16px, 0) scale(0.84)', opacity: 0 },
            { transform: 'translate3d(0, -6px, 0) scale(1.08)', opacity: 1, offset: 0.6 },
            { transform: 'translate3d(0, 0, 0) scale(1)', opacity: 1 }
          ],
          options: { duration: entryDuration, easing: opts.easing || easingCurves.pop }
        };
      case 'burst':
        return {
          keyframes: [
            { transform: 'translate3d(0, 18px, 0) scale(0.78)', opacity: 0 },
            { transform: 'translate3d(0, -8px, 0) scale(1.15)', opacity: 1, offset: 0.55 },
            { transform: 'translate3d(0, 0, 0) scale(1)', opacity: 1 }
          ],
          options: { duration: entryDuration, easing: opts.easing || easingCurves.vibrant }
        };
      case 'fade':
      default:
        return {
          keyframes: [
            { transform: 'translate3d(0, 18px, 0) scale(0.94)', opacity: 0 },
            { transform: 'translate3d(0, 0, 0) scale(1)', opacity: 1 }
          ],
          options: { duration: entryDuration, easing: opts.easing || easingCurves.gentle }
        };
    }
  };

  const getExitAnimation = () => {
    switch (direction) {
      case 'left':
        return { keyframes: directionalExit('x', '-8%', '-160%'), options: { duration: exitDuration, easing: opts.easing || easingCurves.standard } };
      case 'right':
        return { keyframes: directionalExit('x', '8%', '160%'), options: { duration: exitDuration, easing: opts.easing || easingCurves.standard } };
      case 'down':
        return { keyframes: directionalExit('y', '-12%', '120%'), options: { duration: exitDuration, easing: opts.easing || easingCurves.entrance } };
      case 'up':
        return { keyframes: directionalExit('y', '12%', '-120%'), options: { duration: exitDuration, easing: opts.easing || easingCurves.entrance } };
      case 'wipe':
        return {
          keyframes: [
            { transform: 'translate3d(0, 0, 0) scale(1)', opacity: 1, clipPath: 'inset(0 0 0 0)' },
            { transform: 'translate3d(0, 6px, 0) scale(0.96)', opacity: 0.6, clipPath: 'inset(0 0 0 0)', offset: 0.55 },
            { transform: 'translate3d(0, 0, 0) scale(0.96)', opacity: 0, clipPath: 'inset(0 0 0 100%)' }
          ],
          options: { duration: exitDuration, easing: opts.easing || easingCurves.entrance }
        };
      case 'scale':
        return {
          keyframes: [
            { transform: 'translate3d(0, 0, 0) scale(1)', opacity: 1 },
            { transform: 'translate3d(0, 6px, 0) scale(0.92)', opacity: 0.4, offset: 0.6 },
            { transform: 'translate3d(0, 16px, 0) scale(0.8)', opacity: 0 }
          ],
          options: { duration: exitDuration, easing: opts.easing || easingCurves.pop }
        };
      case 'burst':
        return {
          keyframes: [
            { transform: 'translate3d(0, 0, 0) scale(1)', opacity: 1 },
            { transform: 'translate3d(0, -6px, 0) scale(1.12)', opacity: 0.7, offset: 0.5 },
            { transform: 'translate3d(0, 12px, 0) scale(0.9)', opacity: 0 }
          ],
          options: { duration: exitDuration, easing: opts.easing || easingCurves.vibrant }
        };
      case 'fade':
      default:
        return {
          keyframes: [
            { transform: 'translate3d(0, 0, 0) scale(1)', opacity: 1 },
            { transform: 'translate3d(0, -8px, 0) scale(0.96)', opacity: 0 }
          ],
          options: { duration: exitDuration, easing: opts.easing || easingCurves.gentle }
        };
    }
  };

  const finishAndReset = () => {
    clearAnimations();
    wrap.style.opacity = '0';
    wrap.style.transform = 'translate3d(0, 0, 0) scale(1)';
    if (direction === 'wipe') {
      wrap.style.clipPath = 'inset(0 0 0 0)';
    } else {
      wrap.style.removeProperty('clipPath');
    }
    wrap.style.removeProperty('boxShadow');
    wrap.style.removeProperty('filter');
    if (shouldAnimateProgress) {
      progressBar.style.transform = 'scaleX(1)';
    }
    resetBurstOverlay();
  };

  const playExit = () => {
    const { keyframes, options } = getExitAnimation();
    if (state.reducedMotion) {
      finishAndReset();
      return;
    }
    const exitAnim = wrap.animate(keyframes, { ...options, fill: 'forwards' });
    exitAnim.addEventListener('finish', () => {
      finishAndReset();
    }, { once: true });
  };

  const startProgress = () => {
    if (!shouldAnimateProgress) return;
    if (state.reducedMotion) {
      progressBar.style.transform = 'scaleX(0)';
      return;
    }
    const progressAnim = progressBar.animate(
      [
        { transform: 'scaleX(1)' },
        { transform: 'scaleX(0)' }
      ],
      { duration: autoDismissMs, easing: 'linear', fill: 'forwards' }
    );
    if (hasSparkHighlight) {
      const outer = progressBar.querySelector('.pf-toast__progress-outer') || (() => {
        const wrapper = createEl('span', 'pf-toast__progress-outer');
        progressBar.appendChild(wrapper);
        return wrapper;
      })();
      const spark = outer.querySelector('.pf-toast__progress-spark') || (() => {
        const node = createEl('span', 'pf-toast__progress-spark');
        outer.appendChild(node);
        return node;
      })();
      spark.getAnimations().forEach((anim) => anim.cancel());
      spark.animate(
        [
          { opacity: 1, transform: 'translate(50%, -50%) scale(0.6)' },
          { opacity: 1, transform: 'translate(-40%, -50%) scale(1.05)', offset: 0.7 },
          { opacity: 0, transform: 'translate(-170%, -50%) scale(0.2)' }
        ],
        { duration: autoDismissMs, easing: easingCurves.vibrant, fill: 'forwards' }
      );
      progressAnim.addEventListener('finish', () => spark.remove(), { once: true });
    }
  };

  const scheduleExit = () => {
    if (!autoDismissMs) return;
    dismissTimer = setTimeout(() => {
      dismissTimer = null;
      playExit();
    }, state.reducedMotion ? 0 : autoDismissMs);
  };

  const play = () => {
    clearTimers();
    clearAnimations();
    setBaseState();

    const { keyframes, options } = getEnterAnimation();

    if (hasSparkHighlight) {
      playBurstOverlay();
    }

    if (state.reducedMotion) {
      const finalFrame = keyframes[keyframes.length - 1];
      setImmediateStyles(wrap, finalFrame);
      wrap.style.opacity = '1';
      startProgress();
      scheduleExit();
      return;
    }

    const enterAnim = wrap.animate(keyframes, { ...options, fill: 'forwards' });
    startProgress();

    if (hasScalePulse) {
      wrap.animate(
        [
          { transform: 'translate3d(0,0,0) scale(1)', filter: 'brightness(1)', opacity: 1 },
          { transform: 'translate3d(0,-4px,0) scale(1.05)', filter: 'brightness(1.12)', opacity: 1, offset: 0.18 },
          { transform: 'translate3d(0,6px,0) scale(0.96)', filter: 'brightness(0.95)', opacity: 0.92, offset: 0.55 },
          { transform: 'translate3d(0,12px,0) scale(0.9)', filter: 'brightness(0.88)', opacity: 0.85 }
        ],
        { duration: autoDismissMs, easing: easingCurves.gentle, fill: 'forwards' }
      );
    }

    scheduleExit();
    enterAnim.addEventListener('finish', () => {
      wrap.style.opacity = '1';
      if (direction === 'wipe') {
        wrap.style.clipPath = 'inset(0 0 0 0)';
      }
    }, { once: true });
  };

  return { element: wrap, play };
};


const clearChildren = (element) => {
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
};

const setImmediateStyles = (target, styles = {}) => {
  Object.entries(styles).forEach(([prop, value]) => {
    target.style[prop] = value;
  });
};

const playMotion = (target, keyframes, options = {}) => {
  if (!target) return null;
  if (state.reducedMotion) {
    const lastFrame = Array.isArray(keyframes) ? keyframes[keyframes.length - 1] : keyframes;
    setImmediateStyles(target, lastFrame || {});
    return null;
  }
  // Use native Web Animations API
  try {
    return target.animate(keyframes, options);
  } catch (e) {
    console.error('Animation error:', e);
    return null;
  }
};

const playTimeline = (config = [], options = {}) => {
  if (state.reducedMotion) {
    config.forEach(([target, keyframes]) => {
      if (target) {
        const last = Array.isArray(keyframes) ? keyframes[keyframes.length - 1] : keyframes;
        setImmediateStyles(target, last || {});
      }
    });
    return null;
  }
  return timeline(config, options);
};

const playWAAPI = (target, keyframes, options = {}) => {
  if (!target) return null;
  if (state.reducedMotion) {
    const last = Array.isArray(keyframes) ? keyframes[keyframes.length - 1] : keyframes;
    setImmediateStyles(target, last || {});
    return null;
  }
  return target.animate(keyframes, options);
};

const numberTween = (start, end, duration, onUpdate) => {
  if (state.reducedMotion) {
    onUpdate(end);
    return null;
  }
  return animate(start, end, {
    duration: duration / 1000,
    onUpdate,
    ease: easingCurves.gentle
  });
};

const hexToRgba = (hex, alpha = 1) => {
  const clean = hex.replace('#', '');
  const bigint = parseInt(clean, 16);
  const r = (bigint >> 16) & 255;
  const g = (bigint >> 8) & 255;
  const b = bigint & 255;
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
};

const formatTitle = (text) => text.replace(/-/g, ' ').replace(/\w/g, (m) => m.toUpperCase());

const layeredBackground = (colors = []) => {
  if (!colors.length) return 'none';
  return `radial-gradient(circle at 50% 0%, ${colors.join(', ')})`;
};


factoryMap.wizard = (entry) => {
  const { pattern, steps = entry.options.tabs || 3 } = entry.options;
  const container = createEl('div', 'pf-wizard');
  const stepsBar = createEl('div', 'pf-wizard__steps');
  const panelsWrap = createEl('div', 'pf-wizard__panels');

  const stepEls = [];
  const panelEls = [];
  for (let i = 0; i < steps; i += 1) {
    const step = createEl('div', 'pf-wizard__step', { text: `Step ${i + 1}` });
    const panel = createEl('div', 'pf-wizard__panel');
    panel.appendChild(createEl('h5', '', { text: `Stage ${i + 1}` }));
    panel.appendChild(createEl('p', '', { text: 'Guided content placeholder to illustrate flow animation.' }));
    stepsBar.appendChild(step);
    panelsWrap.appendChild(panel);
    stepEls.push(step);
    panelEls.push(panel);
  }

  container.append(stepsBar, panelsWrap);

  const reset = () => {
    stepEls.forEach((step, index) => {
      step.classList.toggle('is-active', index === 0);
      step.style.opacity = index === 0 ? '1' : '0.3';
      step.style.transform = 'scale(1)';
    });
    panelEls.forEach((panel, index) => {
      panel.style.opacity = index === 0 ? '1' : '0';
      panel.style.transform = 'translate3d(0, 0, 0) scale(1)';
      panel.style.rotate = '0deg';
    });
  };

  const play = () => {
    reset();
    if (state.reducedMotion) {
      stepEls.forEach((step, idx) => step.classList.toggle('is-active', idx === steps - 1));
      panelEls.forEach((panel, idx) => {
        panel.style.opacity = idx === steps - 1 ? '1' : '0';
        panel.style.transform = 'translate3d(0, 0, 0) scale(1)';
        panel.style.rotate = '0deg';
      });
      return;
    }
    const animations = [];
    const distance = pattern.includes('slide') ? 48 : 20;
    panelEls.forEach((panel, index) => {
      const delay = index * 0.26;
      if (pattern === 'slide-stack' || pattern === 'slide-swap') {
        animations.push([
          panel,
          { transform: [`translateX(${distance}px) scale(0.94)`, 'translateX(0px) scale(1)'], opacity: [0, 1] },
          { at: delay, duration: entry.options.duration / 1000 * 0.6, easing: entry.options.easing }
        ]);
      } else if (pattern === 'cross-fade' || pattern === 'progressive') {
        animations.push([
          panel,
          { opacity: [0, 1], transform: ['translateY(16px)', 'translateY(0)'] },
          { at: delay, duration: entry.options.duration / 1000 * 0.5, easing: entry.options.easing }
        ]);
      } else if (pattern === 'scale-rotate' || pattern === 'morph') {
        animations.push([
          panel,
          { transform: ['rotate(-6deg) scale(0.82)', 'rotate(0deg) scale(1)'], opacity: [0, 1] },
          { at: delay, duration: entry.options.duration / 1000 * 0.6, easing: entry.options.easing }
        ]);
      } else {
        animations.push([
          panel,
          { opacity: [0, 1], transform: ['translateY(16px)', 'translateY(0)'] },
          { at: delay, duration: entry.options.duration / 1000 * 0.5, easing: entry.options.easing }
        ]);
      }
    });

    const stepAnimation = [];
    stepEls.forEach((step, index) => {
      stepAnimation.push([
        step,
        { scale: [0.9, 1.06, 1], opacity: [0.3, 1, 1] },
        { at: index * 0.26, duration: 0.46, easing: easingCurves.pop }
      ]);
    });

    playTimeline([...animations, ...stepAnimation]);
  };

  return { element: container, play, height: "360px" };
};


const celebrationPalettes = {
  confetti: ['#ff5981', '#c6ff77', '#47fff4', '#ffce1a', '#ecc3ff'],
  confettiWarm: ['#ff5981', '#ffce1a', '#ffcaca', '#ffd966'],
  coins: ['linear-gradient(135deg, #ffd966 0%, #ffb300 100%)', 'linear-gradient(135deg, #ffe066 0%, #f59e00 100%)'],
  fireworks: ['#ffce1a', '#ff5981', '#47fff4', '#c6ff77'],
};

const createConfettiPiece = (layer, config, reduced) => {
  const piece = createEl('span', 'pf-celebration__confetti');
  piece.dataset.anim = 'confetti';
  piece.style.left = config.left || '50%';
  piece.style.top = config.top || '50%';
  if (config.size) piece.style.setProperty('--size', config.size);
  if (config.length) piece.style.setProperty('--length', config.length);
  if (config.tx) piece.style.setProperty('--tx', config.tx);
  if (config.ty) piece.style.setProperty('--ty', config.ty);
  if (config.rot) piece.style.setProperty('--rot', config.rot);
  if (config.dx) piece.style.setProperty('--dx', config.dx);
  if (config.drift) piece.style.setProperty('--drift', config.drift);
  if (config.angle) piece.style.setProperty('--angle', config.angle);
  if (config.spin) piece.style.setProperty('--spin', config.spin);
  if (config.radius) piece.style.setProperty('--radius', config.radius);
  if (config.delay) piece.style.setProperty('--delay', config.delay);
  if (config.duration) piece.style.setProperty('--duration', config.duration);
  piece.style.background = config.color || '#ecc3ff';
  layer.appendChild(piece);
  if (reduced) {
    piece.style.animation = 'none';
    piece.style.opacity = '1';
  }
};

const createCoinPiece = (layer, config, reduced) => {
  const coin = createEl('span', 'pf-celebration__coin');
  coin.dataset.anim = 'coin';
  if (config.tx) coin.style.setProperty('--tx', config.tx);
  if (config.ty) coin.style.setProperty('--ty', config.ty);
  if (config.spin) coin.style.setProperty('--spin', config.spin);
  if (config.radius) coin.style.setProperty('--radius', config.radius);
  if (config.startAngle) coin.style.setProperty('--start-angle', config.startAngle);
  if (config.delay) coin.style.setProperty('--delay', config.delay);
  if (config.duration) coin.style.setProperty('--duration', config.duration);
  coin.style.setProperty('--coin-color', config.color || celebrationPalettes.coins[0]);
  layer.appendChild(coin);
  if (reduced) {
    coin.style.animation = 'none';
    coin.style.opacity = '1';
  }
};

const createFirework = (layer, config, reduced) => {
  const spark = createEl('span', config.type === 'ring' ? 'pf-celebration__ring' : 'pf-celebration__firework');
  spark.dataset.anim = 'firework';
  if (config.size) spark.style.setProperty('--size', config.size);
  if (config.scale) spark.style.setProperty('--scale', config.scale);
  if (config.delay) spark.style.setProperty('--delay', config.delay);
  if (config.color) spark.style.setProperty('--color', config.color);
  layer.appendChild(spark);
  if (reduced) {
    spark.style.animation = 'none';
    spark.style.opacity = '1';
  }
};

const createBeam = (layer, config = {}, reduced) => {
  const beam = createEl('span', 'pf-celebration__beam');
  beam.dataset.anim = 'beam';
  if (config.left) beam.style.left = config.left;
  if (config.top) beam.style.top = config.top;
  if (config.delay) beam.style.setProperty('--delay', config.delay);
  if (config.rotate) beam.style.setProperty('--rotate', config.rotate);
  if (config.swing) beam.style.setProperty('--swing', config.swing);
  if (config.width) beam.style.width = config.width;
  if (config.height) beam.style.height = config.height;
  if (config.gradient) beam.style.background = config.gradient;
  if (config.opacity !== undefined) beam.style.setProperty('--beam-opacity', config.opacity);
  if (config.origin) beam.style.transformOrigin = config.origin;
  if (config.blur) beam.style.filter = `blur(${config.blur})`;
  if (config.className) beam.classList.add(config.className);
  layer.appendChild(beam);
  if (reduced) {
    beam.style.animation = 'none';
    beam.style.opacity = `${config.opacity !== undefined ? config.opacity : 0.6}`;
  }
  return beam;
};

const createPulse = (layer, config, reduced) => {
  const pulse = createEl('span', 'pf-celebration__pulse');
  pulse.dataset.anim = 'pulse';
  if (config.delay) pulse.style.setProperty('--delay', config.delay);
  if (config.color) pulse.style.borderColor = config.color;
  if (config.duration) pulse.style.setProperty('--duration', config.duration);
  layer.appendChild(pulse);
  if (reduced) {
    pulse.style.animation = 'none';
    pulse.style.opacity = '0.4';
  }
};

const createStage = (layer, config = {}, reduced) => {
  const stage = createEl('span', 'pf-celebration__stage');
  if (config.width) stage.style.setProperty('--stage-width', config.width);
  if (config.height) stage.style.setProperty('--stage-height', config.height);
  if (config.color) stage.style.setProperty('--stage-color', config.color);
  if (config.className) stage.classList.add(config.className);
  if (config.opacity) stage.style.opacity = config.opacity;
  layer.appendChild(stage);
  if (config.inner !== false) {
    stage.appendChild(createEl('span', 'pf-celebration__stage-inner'));
  }
  if (reduced) {
    stage.style.animation = 'none';
    stage.style.opacity = '1';
    stage.style.transform = 'translate(-50%, 0) scale(1)';
  }
  return stage;
};

const createStageGlow = (layer, config = {}, reduced) => {
  const glow = createEl('span', 'pf-celebration__stage-glow');
  if (config.width) glow.style.setProperty('--stage-glow-width', config.width);
  if (config.height) glow.style.setProperty('--stage-glow-height', config.height);
  if (config.duration) glow.style.setProperty('--duration', config.duration);
  if (config.className) glow.classList.add(`pf-celebration__stage-glow--${config.className}`);
  if (config.background) glow.style.background = config.background;
  if (config.delay) glow.style.animationDelay = config.delay;
  layer.appendChild(glow);
  if (reduced) {
    glow.style.animation = 'none';
    glow.style.opacity = '0.5';
    glow.style.transform = 'translate(-50%, 0) scale(1)';
  }
  return glow;
};

const createSparkle = (layer, config = {}, reduced) => {
  const sparkle = createEl('span', 'pf-celebration__sparkle');
  if (config.className) sparkle.classList.add(`pf-celebration__sparkle--${config.className}`);
  sparkle.style.left = config.left || '50%';
  sparkle.style.top = config.top || '50%';
  if (config.duration) sparkle.style.setProperty('--duration', config.duration);
  if (config.delay) sparkle.style.setProperty('--delay', config.delay);
  if (config.size) sparkle.style.setProperty('--size', config.size);
  if (config.color) sparkle.style.setProperty('--sparkle-color', config.color);
  layer.appendChild(sparkle);
  if (reduced) {
    sparkle.style.animation = 'none';
    sparkle.style.opacity = '0.8';
  }
  return sparkle;
};

const celebrationBuilders = {
  'confetti-burst': (layer, reduced) => {
    const colors = celebrationPalettes.confetti;
    for (let i = 0; i < 32; i += 1) {
      createConfettiPiece(layer, {
        left: '50%',
        top: '60%',
        tx: `${randBetween(-160, 160).toFixed(0)}px`,
        ty: `${randBetween(-210, -80).toFixed(0)}px`,
        rot: `${randBetween(-260, 260).toFixed(0)}deg`,
        delay: `${i * 12}ms`,
        duration: `${randBetween(600, 900).toFixed(0)}ms`,
        color: colors[i % colors.length],
      }, reduced);
    }
  },
  'confetti-fan': (layer, reduced) => {
    const colors = celebrationPalettes.confettiWarm;
    for (let i = 0; i < 30; i += 1) {
      createConfettiPiece(layer, {
        left: '50%',
        top: '55%',
        tx: `${randBetween(-160, 160).toFixed(0)}px`,
        ty: `${randBetween(120, 180).toFixed(0)}px`,
        rot: `${randBetween(-140, 140).toFixed(0)}deg`,
        delay: `${i * 14}ms`,
        duration: '820ms',
        color: colors[i % colors.length],
      }, reduced);
    }
  },
  'confetti-spiral': (layer, reduced) => {
    const colors = celebrationPalettes.confetti;
    for (let i = 0; i < 26; i += 1) {
      createConfettiPiece(layer, {
        left: '50%',
        top: '50%',
        angle: `${randBetween(0, 360).toFixed(0)}deg`,
        spin: `${randBetween(360, 540).toFixed(0)}deg`,
        radius: `${randBetween(90, 140).toFixed(0)}px`,
        delay: `${i * 18}ms`,
        duration: '1000ms',
        color: colors[i % colors.length],
      }, reduced);
    }
  },
  'confetti-rain': (layer, reduced) => {
    const colors = celebrationPalettes.confetti;
    for (let i = 0; i < 28; i += 1) {
      createConfettiPiece(layer, {
        left: `${randBetween(10, 90).toFixed(0)}%`,
        top: '-10%',
        dx: '0px',
        drift: `${randBetween(-40, 40).toFixed(0)}px`,
        rot: `${randBetween(-90, 90).toFixed(0)}deg`,
        delay: `${randBetween(0, 400).toFixed(0)}ms`,
        duration: '1200ms',
        color: colors[i % colors.length],
      }, reduced);
    }
  },
  'confetti-pulse': (layer, reduced) => {
    const colors = celebrationPalettes.confetti;
    for (let i = 0; i < 3; i += 1) {
      createPulse(layer, { delay: `${i * 180}ms`, color: colors[i % colors.length], duration: '1400ms' }, reduced);
    }
    for (let i = 0; i < 20; i += 1) {
      createConfettiPiece(layer, {
        left: '50%',
        top: '55%',
        tx: `${randBetween(-120, 120).toFixed(0)}px`,
        ty: `${randBetween(-160, -60).toFixed(0)}px`,
        rot: `${randBetween(-220, 220).toFixed(0)}deg`,
        delay: `${i * 20}ms`,
        duration: '780ms',
        color: colors[i % colors.length],
      }, reduced);
    }
  },
  'coins-arc': (layer, reduced) => {
    for (let i = 0; i < 14; i += 1) {
      createCoinPiece(layer, {
        tx: `${randBetween(-120, 120).toFixed(0)}px`,
        ty: `${randBetween(-160, -60).toFixed(0)}px`,
        delay: `${i * 40}ms`,
        duration: '900ms',
        color: celebrationPalettes.coins[i % celebrationPalettes.coins.length],
      }, reduced);
    }
  },
  'coins-fountain': (layer, reduced) => {
    for (let i = 0; i < 12; i += 1) {
      createCoinPiece(layer, {
        tx: `${randBetween(-80, 80).toFixed(0)}px`,
        ty: `${randBetween(-200, -120).toFixed(0)}px`,
        delay: `${i * 50}ms`,
        duration: '1100ms',
        color: celebrationPalettes.coins[i % celebrationPalettes.coins.length],
      }, reduced);
    }
  },
  'coins-swirl': (layer, reduced) => {
    for (let i = 0; i < 10; i += 1) {
      createCoinPiece(layer, {
        startAngle: `${randBetween(0, 360).toFixed(0)}deg`,
        spin: `${randBetween(240, 360).toFixed(0)}deg`,
        radius: `${randBetween(60, 110).toFixed(0)}px`,
        delay: `${i * 70}ms`,
        duration: '1200ms',
        color: celebrationPalettes.coins[i % celebrationPalettes.coins.length],
      }, reduced);
    }
  },
  'fireworks-triple': (layer, reduced) => {
    celebrationPalettes.fireworks.forEach((color, index) => {
      createFirework(layer, { size: `${18 + index * 8}px`, scale: `${1.6 + index * 0.4}`, delay: `${index * 160}ms`, color }, reduced);
    });
  },
  'fireworks-ring': (layer, reduced) => {
    createFirework(layer, { type: 'ring', scale: '3.2', delay: '0ms' }, reduced);
    createFirework(layer, { type: 'ring', scale: '2.2', delay: '120ms' }, reduced);
  },
  'reward-spotlight': (layer, reduced) => {
    createStage(layer, { width: '152px', height: '48px', color: 'rgba(198, 255, 119, 0.36)' }, reduced);
    createStageGlow(layer, { className: 'emerald', duration: '1800ms' }, reduced);
    createPulse(layer, { delay: '0ms', color: 'rgba(198,255,119,0.55)', duration: '1600ms' }, reduced);
    createPulse(layer, { delay: '260ms', color: 'rgba(71,255,244,0.45)', duration: '1800ms' }, reduced);

    const beamConfigs = [
      { left: '16%', rotate: '-30deg', width: '90px', height: '260px', gradient: 'linear-gradient(180deg, rgba(198,255,119,0.05) 0%, rgba(198,255,119,0.82) 32%, rgba(198,255,119,0))', opacity: 0.9, swing: '14deg', blur: '1.2px' },
      { left: '32%', rotate: '-12deg', width: '100px', height: '280px', gradient: 'linear-gradient(180deg, rgba(71,255,244,0.06) 0%, rgba(71,255,244,0.78) 42%, rgba(71,255,244,0))', opacity: 0.88, swing: '8deg', blur: '1px' },
      { left: '50%', rotate: '0deg', width: '132px', height: '300px', gradient: 'linear-gradient(180deg, rgba(255,255,255,0.16) 0%, rgba(198,255,119,0.9) 35%, rgba(71,255,244,0.75) 65%, rgba(255,255,255,0))', opacity: 0.96, swing: '0deg', origin: 'bottom center', blur: '0.8px' },
      { left: '68%', rotate: '12deg', width: '100px', height: '280px', gradient: 'linear-gradient(180deg, rgba(71,255,244,0.06) 0%, rgba(71,255,244,0.78) 42%, rgba(71,255,244,0))', opacity: 0.88, swing: '-8deg', blur: '1px' },
      { left: '84%', rotate: '30deg', width: '90px', height: '260px', gradient: 'linear-gradient(180deg, rgba(198,255,119,0.05) 0%, rgba(198,255,119,0.82) 32%, rgba(198,255,119,0))', opacity: 0.86, swing: '-14deg', blur: '1.2px' },
    ];

    beamConfigs.forEach((config, index) => {
      createBeam(layer, { ...config, delay: `${index * 90}ms` }, reduced);
    });

    for (let i = 0; i < 14; i += 1) {
      createSparkle(layer, {
        className: 'rise',
        left: `${randBetween(32, 68).toFixed(0)}%`,
        top: `${randBetween(18, 52).toFixed(0)}%`,
        delay: `${i * 90}ms`,
        size: `${randBetween(6, 11).toFixed(0)}px`,
        color: 'rgba(255, 255, 255, 0.95)',
      }, reduced);
    }

    for (let i = 0; i < 6; i += 1) {
      createSparkle(layer, {
        className: 'rise',
        left: `${randBetween(36, 64).toFixed(0)}%`,
        top: `${randBetween(8, 18).toFixed(0)}%`,
        delay: `${400 + i * 120}ms`,
        size: `${randBetween(8, 14).toFixed(0)}px`,
        color: 'rgba(198, 255, 249, 0.95)',
      }, reduced);
    }
  },
  'jackpot-celebration': (layer, reduced) => {
    createStage(layer, { width: '180px', height: '56px', color: 'rgba(255, 206, 26, 0.52)' }, reduced);
    createStageGlow(layer, { className: 'gold', duration: '2000ms' }, reduced);

    createPulse(layer, { delay: '0ms', color: 'rgba(255,206,26,0.6)', duration: '1700ms' }, reduced);
    createPulse(layer, { delay: '220ms', color: 'rgba(255,143,69,0.5)', duration: '1900ms' }, reduced);
    createPulse(layer, { delay: '520ms', color: 'rgba(255,255,255,0.45)', duration: '2100ms' }, reduced);

    const glow = createEl('span', 'pf-celebration__glow');
    glow.dataset.anim = 'glow';
    layer.appendChild(glow);
    if (reduced) {
      glow.style.animation = 'none';
      glow.style.opacity = '0.6';
    }

    celebrationPalettes.fireworks.forEach((color, index) => {
      createFirework(layer, { size: `${24 + index * 10}px`, scale: `${1.8 + index * 0.5}`, delay: `${index * 140}ms`, color }, reduced);
    });
    createFirework(layer, { type: 'ring', scale: '3.4', delay: '60ms' }, reduced);
    createFirework(layer, { type: 'ring', scale: '2.4', delay: '200ms' }, reduced);

    const beamConfigs = [
      { left: '18%', rotate: '-26deg', width: '90px', height: '270px', gradient: 'linear-gradient(180deg, rgba(255,206,26,0.06) 0%, rgba(255,206,26,0.88) 38%, rgba(255,206,26,0))', opacity: 0.92, swing: '16deg', blur: '1.4px' },
      { left: '34%', rotate: '-10deg', width: '110px', height: '300px', gradient: 'linear-gradient(180deg, rgba(255,216,133,0.08) 0%, rgba(255,184,56,0.88) 42%, rgba(255,184,56,0))', opacity: 0.9, swing: '10deg', blur: '1.1px' },
      { left: '50%', rotate: '0deg', width: '140px', height: '320px', gradient: 'linear-gradient(180deg, rgba(255,255,255,0.18) 0%, rgba(255,206,26,0.92) 38%, rgba(255,149,0,0.78) 58%, rgba(255,255,255,0))', opacity: 0.97, swing: '3deg', origin: 'bottom center', blur: '1px' },
      { left: '66%', rotate: '12deg', width: '110px', height: '300px', gradient: 'linear-gradient(180deg, rgba(255,216,133,0.08) 0%, rgba(255,184,56,0.88) 42%, rgba(255,184,56,0))', opacity: 0.9, swing: '-10deg', blur: '1.1px' },
      { left: '82%', rotate: '28deg', width: '90px', height: '270px', gradient: 'linear-gradient(180deg, rgba(255,206,26,0.06) 0%, rgba(255,206,26,0.88) 38%, rgba(255,206,26,0))', opacity: 0.92, swing: '-16deg', blur: '1.4px' },
    ];
    beamConfigs.forEach((config, index) => {
      createBeam(layer, { ...config, delay: `${index * 80}ms` }, reduced);
    });

    for (let i = 0; i < 12; i += 1) {
      createCoinPiece(layer, {
        tx: `${randBetween(-130, 130).toFixed(0)}px`,
        ty: `${randBetween(-220, -120).toFixed(0)}px`,
        delay: `${i * 50}ms`,
        duration: '1150ms',
        color: celebrationPalettes.coins[i % celebrationPalettes.coins.length],
      }, reduced);
    }

    for (let i = 0; i < 8; i += 1) {
      createCoinPiece(layer, {
        tx: `${randBetween(-120, 120).toFixed(0)}px`,
        ty: `${randBetween(-200, -140).toFixed(0)}px`,
        delay: `${300 + i * 60}ms`,
        duration: '1250ms',
        color: celebrationPalettes.coins[(i + 2) % celebrationPalettes.coins.length],
      }, reduced);
    }

    for (let i = 0; i < 18; i += 1) {
      createSparkle(layer, {
        className: 'pop',
        left: `${randBetween(30, 70).toFixed(0)}%`,
        top: `${randBetween(14, 54).toFixed(0)}%`,
        delay: `${i * 70}ms`,
        size: `${randBetween(6, 12).toFixed(0)}px`,
        color: 'rgba(255, 236, 179, 0.95)',
      }, reduced);
    }
  },
};

factoryMap.celebration = (entry) => {
  const style = entry.options.style;
  const container = createEl('div', 'pf-celebration');
  const layer = createEl('div', 'pf-celebration__layer');
  container.appendChild(layer);

  const build = (reduced) => {
    layer.innerHTML = '';
    container.className = `pf-celebration pf-celebration--${style}`;
    const builder = celebrationBuilders[style];
    if (builder) {
      builder(layer, reduced);
    }
  };

  const play = () => {
    build(state.reducedMotion);
  };

  return { element: container, play, height: "240px" };
};


factoryMap.progressBar = (entry) => {
  const wrapper = createEl('div', 'pf-progress-demo');
  const label = createEl('div', 'pf-progress-demo__label', { text: 'Level progress' });
  const trackContainer = createEl('div', '');
  trackContainer.style.position = 'relative';

  const track = createEl('div', 'pf-progress-track');
  track.style.position = 'relative';
  track.style.overflow = 'visible'; // Allow effects to extend beyond

  const fill = createEl('div', 'pf-progress-fill');
  fill.style.willChange = 'transform'; // Optimize for animation

  track.appendChild(fill);
  trackContainer.appendChild(track);
  wrapper.append(label, trackContainer);

  // Clean up any existing animations
  const cleanupAnimations = () => {
    const existingElements = wrapper.querySelectorAll('.animation-element');
    existingElements.forEach(el => el.remove());
  };

  const play = () => {
    cleanupAnimations();
    fill.style.transform = 'scaleX(0)';

    // Handle all 12 progress bar styles
    switch(entry.options.style) {
      case 'soft': {
        // SOFT FILL - Smooth easing fill with subtle light bloom at completion
        fill.style.background = 'linear-gradient(90deg, #c47ae5 0%, #d79af3 100%)';
        fill.style.transformOrigin = 'left center';

        // Create glow layer for bloom effect
        const softGlow = createEl('div', 'animation-element');
        softGlow.style.position = 'absolute';
        softGlow.style.inset = '-20px';
        softGlow.style.background = 'radial-gradient(ellipse at right center, rgba(236,195,255,0) 0%, rgba(236,195,255,0) 60%, rgba(236,195,255,0.4) 80%, rgba(236,195,255,0) 100%)';
        softGlow.style.opacity = '0';
        softGlow.style.pointerEvents = 'none';
        softGlow.style.transform = 'scaleX(0)';
        softGlow.style.transformOrigin = 'left center';
        softGlow.style.filter = 'blur(8px)';
        trackContainer.insertBefore(softGlow, track);

        // Create inner highlight for polish
        const innerHighlight = createEl('div', 'animation-element');
        innerHighlight.style.position = 'absolute';
        innerHighlight.style.inset = '0';
        innerHighlight.style.background = 'linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.1) 50%, transparent 100%)';
        innerHighlight.style.opacity = '0';
        innerHighlight.style.pointerEvents = 'none';
        fill.appendChild(innerHighlight);

        // Main fill animation with perfect easing
        const fillAnimation = fill.animate([
          { transform: 'scaleX(0)', opacity: 0.8 },
          { transform: 'scaleX(0.7)', opacity: 0.9, offset: 0.7 },
          { transform: 'scaleX(1)', opacity: 1 }
        ], {
          duration: entry.options.duration || 1200,
          fill: 'forwards',
          easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
        });

        // Glow animation synchronized
        const glowAnimation = softGlow.animate([
          { transform: 'scaleX(0)', opacity: 0 },
          { transform: 'scaleX(0.7)', opacity: 0, offset: 0.7 },
          { transform: 'scaleX(0.9)', opacity: 0.3, offset: 0.85 },
          { transform: 'scaleX(1)', opacity: 0.6, offset: 0.95 },
          { transform: 'scaleX(1)', opacity: 0 }
        ], {
          duration: entry.options.duration || 1200,
          fill: 'forwards',
          easing: 'ease-out'
        });

        // Inner highlight for extra polish
        innerHighlight.animate([
          { opacity: 0 },
          { opacity: 0, offset: 0.5 },
          { opacity: 0.5, offset: 0.8 },
          { opacity: 0 }  // Changed to 0 to remove persistent glow
        ], {
          duration: entry.options.duration || 1200,
          fill: 'forwards',
          easing: 'ease-out'
        });

        // Bloom effect at completion
        fillAnimation.finished.then(() => {
          const bloom = createEl('div', 'animation-element');
          bloom.style.position = 'absolute';
          bloom.style.right = '-10px';
          bloom.style.top = '50%';
          bloom.style.transform = 'translateY(-50%)';
          bloom.style.width = '60px';
          bloom.style.height = '60px';
          bloom.style.background = 'radial-gradient(circle, rgba(236,195,255,0.6) 0%, rgba(236,195,255,0.3) 30%, transparent 70%)';
          bloom.style.pointerEvents = 'none';
          bloom.style.filter = 'blur(2px)';
          trackContainer.appendChild(bloom);

          const bloomAnim = bloom.animate([
            { transform: 'translateY(-50%) scale(0)', opacity: 0 },
            { transform: 'translateY(-50%) scale(1.5)', opacity: 1, offset: 0.3 },
            { transform: 'translateY(-50%) scale(2)', opacity: 0 }
          ], { duration: 600, easing: 'cubic-bezier(0.4, 0, 0.6, 1)' });

          // Remove bloom element after animation completes
          bloomAnim.finished.then(() => {
            bloom.remove();
          });
        });
        break;
      }

      case 'striped': {
        // STRIPED FLOW - Animated stripes communicate momentum during fill
        fill.style.background = 'linear-gradient(90deg, #c47ae5 0%, #d79af3 100%)';
        fill.style.position = 'relative';
        fill.style.overflow = 'hidden';

        // Create high-quality animated stripes
        const stripesContainer = createEl('div', 'animation-element');
        stripesContainer.style.position = 'absolute';
        stripesContainer.style.inset = '0';
        stripesContainer.style.background = `repeating-linear-gradient(
          -45deg,
          transparent,
          transparent 8px,
          rgba(255,255,255,0.08) 8px,
          rgba(255,255,255,0.08) 16px
        )`;
        stripesContainer.style.backgroundSize = '32px 32px';
        stripesContainer.style.willChange = 'background-position';
        fill.appendChild(stripesContainer);

        // Add shimmer overlay for extra polish
        const shimmer = createEl('div', 'animation-element');
        shimmer.style.position = 'absolute';
        shimmer.style.inset = '0';
        shimmer.style.background = 'linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.2) 50%, transparent 100%)';
        shimmer.style.backgroundSize = '200% 100%';
        shimmer.style.opacity = '0';
        shimmer.style.pointerEvents = 'none';
        fill.appendChild(shimmer);

        // Main fill animation
        const fillAnim = fill.animate([
          { transform: 'scaleX(0)' },
          { transform: 'scaleX(1)' }
        ], {
          duration: entry.options.duration || 1400,
          fill: 'forwards',
          easing: 'cubic-bezier(0.4, 0, 0.6, 1)'
        });

        // Animate stripes with acceleration
        let stripeSpeed = 0;
        const animateStripes = () => {
          if (fillAnim.playState === 'finished') {
            stripeSpeed = Math.max(0, stripeSpeed - 0.5);
          } else {
            stripeSpeed = Math.min(20, stripeSpeed + 0.3);
          }

          if (stripeSpeed > 0) {
            const currentPos = parseFloat(stripesContainer.style.backgroundPositionX || '0');
            stripesContainer.style.backgroundPosition = `${currentPos + stripeSpeed}px 0`;
            requestAnimationFrame(animateStripes);
          }
        };
        animateStripes();

        // Shimmer effect during fill
        shimmer.animate([
          { backgroundPosition: '-100% 0', opacity: 0 },
          { backgroundPosition: '-100% 0', opacity: 0, offset: 0.3 },
          { backgroundPosition: '0% 0', opacity: 0.4, offset: 0.5 },
          { backgroundPosition: '100% 0', opacity: 0.4, offset: 0.7 },
          { backgroundPosition: '200% 0', opacity: 0 }
        ], {
          duration: entry.options.duration || 1400,
          fill: 'forwards',
          easing: 'ease-in-out'
        });
        break;
      }

      case 'pulse': {
        // PULSE UPDATE - Momentum pulse on update emphasizing change events
        fill.style.background = 'linear-gradient(90deg, #c47ae5 0%, #d79af3 100%)';
        fill.style.transformOrigin = 'left center';

        // Create pulse wave elements
        const pulseWaves = [];
        const pulseTimes = [0.25, 0.5, 0.75];

        pulseTimes.forEach((time, index) => {
          const wave = createEl('div', 'animation-element');
          wave.style.position = 'absolute';
          wave.style.left = `${time * 100}%`;
          wave.style.top = '50%';
          wave.style.transform = 'translate(-50%, -50%)';
          wave.style.width = '4px';
          wave.style.height = '200%';
          wave.style.background = 'radial-gradient(ellipse, rgba(198,255,119,0.8) 0%, transparent 70%)';
          wave.style.opacity = '0';
          wave.style.pointerEvents = 'none';
          wave.style.filter = 'blur(2px)';
          trackContainer.appendChild(wave);
          pulseWaves.push({ element: wave, time });
        });

        // Create energy trail
        const energyTrail = createEl('div', 'animation-element');
        energyTrail.style.position = 'absolute';
        energyTrail.style.inset = '0';
        energyTrail.style.background = 'linear-gradient(90deg, transparent 0%, rgba(198,255,119,0.2) 100%)';
        energyTrail.style.opacity = '0';
        energyTrail.style.pointerEvents = 'none';
        energyTrail.style.transform = 'scaleX(0)';
        energyTrail.style.transformOrigin = 'left center';
        fill.appendChild(energyTrail);

        // Main fill with smooth pulses
        const fillDuration = entry.options.duration || 1600;
        const fillAnim = fill.animate([
          { transform: 'scaleX(0)' },
          { transform: 'scaleX(0.25)', offset: 0.25 },
          { transform: 'scaleX(0.5)', offset: 0.5 },
          { transform: 'scaleX(0.75)', offset: 0.75 },
          { transform: 'scaleX(1)' }
        ], {
          duration: fillDuration,
          fill: 'forwards',
          easing: 'linear'
        });

        // Pulse effects at milestones
        pulseWaves.forEach(({ element, time }) => {
          setTimeout(() => {
            // Vertical pulse wave
            element.animate([
              { transform: 'translate(-50%, -50%) scaleY(0) scaleX(1)', opacity: 0 },
              { transform: 'translate(-50%, -50%) scaleY(1.2) scaleX(3)', opacity: 1, offset: 0.2 },
              { transform: 'translate(-50%, -50%) scaleY(1) scaleX(6)', opacity: 0 }
            ], { duration: 400, easing: 'cubic-bezier(0.4, 0, 0.6, 1)' });

            // Track pulse effect
            track.animate([
              { transform: 'scaleY(1)' },
              { transform: 'scaleY(1.15)', offset: 0.3 },
              { transform: 'scaleY(1)' }
            ], { duration: 300, easing: 'cubic-bezier(0.4, 0, 0.6, 1)' });
          }, fillDuration * time);
        });

        // Energy trail animation
        energyTrail.animate([
          { transform: 'scaleX(0)', opacity: 0 },
          { transform: 'scaleX(0.3)', opacity: 0.5, offset: 0.25 },
          { transform: 'scaleX(0.6)', opacity: 0.5, offset: 0.5 },
          { transform: 'scaleX(0.9)', opacity: 0.5, offset: 0.75 },
          { transform: 'scaleX(1)', opacity: 0.3 }
        ], {
          duration: fillDuration,
          fill: 'forwards',
          easing: 'ease-out'
        });

        // Final celebration pulse
        fillAnim.finished.then(() => {
          fill.animate([
            { transform: 'scaleX(1) scaleY(1)' },
            { transform: 'scaleX(1) scaleY(1.2)', offset: 0.3 },
            { transform: 'scaleX(1) scaleY(1)' }
          ], { duration: 400, easing: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)' });
        });
        break;
      }

      case 'milestones': {
        // MILESTONE MARKERS - Light up as progress crosses thresholds
        fill.style.background = 'linear-gradient(90deg, #c47ae5 0%, #d79af3 100%)';

        // Create milestone positions
        const milestonePositions = [0, 0.25, 0.5, 0.75, 1];
        const milestoneMarkers = [];

        // Create milestone markers
        milestonePositions.forEach((pos, index) => {
          const markerContainer = createEl('div', 'animation-element');
          markerContainer.style.position = 'absolute';
          markerContainer.style.left = `${pos * 100}%`;
          markerContainer.style.top = '50%';
          markerContainer.style.transform = 'translate(-50%, -50%)';
          markerContainer.style.width = '20px';
          markerContainer.style.height = '20px';
          markerContainer.style.pointerEvents = 'none';
          trackContainer.appendChild(markerContainer);

          // Diamond shape marker
          const marker = createEl('div', '');
          marker.style.position = 'absolute';
          marker.style.inset = '0';
          marker.style.background = 'rgba(78,24,124,0.8)';
          marker.style.border = '2px solid rgba(255,255,255,0.2)';
          marker.style.borderRadius = '50%';
          marker.style.transform = 'rotate(45deg) scale(0.5)';
          marker.style.transition = 'all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)';
          markerContainer.appendChild(marker);

          // Inner glow
          const innerGlow = createEl('div', '');
          innerGlow.style.position = 'absolute';
          innerGlow.style.inset = '20%';
          innerGlow.style.background = 'rgba(255,255,255,0.9)';
          innerGlow.style.borderRadius = '50%';
          innerGlow.style.opacity = '0';
          innerGlow.style.filter = 'blur(2px)';
          innerGlow.style.transition = 'all 0.3s ease';
          markerContainer.appendChild(innerGlow);

          // Outer ring pulse
          const ring = createEl('div', '');
          ring.style.position = 'absolute';
          ring.style.inset = '-10px';
          ring.style.border = '2px solid rgba(255,255,255,0.8)';
          ring.style.borderRadius = '50%';
          ring.style.opacity = '0';
          ring.style.pointerEvents = 'none';
          markerContainer.appendChild(ring);

          milestoneMarkers.push({
            container: markerContainer,
            marker,
            innerGlow,
            ring,
            position: pos
          });
        });

        // Add milestone labels
        const labelContainer = createEl('div', 'animation-element');
        labelContainer.style.position = 'absolute';
        labelContainer.style.inset = '0';
        labelContainer.style.top = '100%';
        labelContainer.style.marginTop = '8px';
        labelContainer.style.display = 'flex';
        labelContainer.style.justifyContent = 'space-between';
        labelContainer.style.fontSize = '10px';
        labelContainer.style.color = 'rgba(236,195,255,0.5)';
        labelContainer.style.pointerEvents = 'none';
        trackContainer.appendChild(labelContainer);

        ['Start', '25%', '50%', '75%', '100%'].forEach((label, i) => {
          const span = createEl('span', '');
          span.textContent = label;
          span.style.position = 'absolute';
          span.style.left = `${milestonePositions[i] * 100}%`;
          span.style.transform = 'translateX(-50%)';
          span.style.opacity = '0.5';
          span.style.transition = 'all 0.3s ease';
          labelContainer.appendChild(span);
          milestoneMarkers[i].label = span;
        });

        // Main fill animation
        const duration = 4000; // Fixed 4 seconds duration
        const fillAnim = fill.animate([
          { transform: 'scaleX(0)' },
          { transform: 'scaleX(1)' }
        ], {
          duration,
          fill: 'forwards',
          easing: 'linear' // Use linear for predictable milestone timing
        });

        // Track animation progress and activate milestones
        let activatedMilestones = new Set();
        const checkMilestones = () => {
          const progress = fillAnim.currentTime / duration;

          milestoneMarkers.forEach(({ marker, innerGlow, ring, position, label }, index) => {
            if (progress >= position && !activatedMilestones.has(index)) {
              activatedMilestones.add(index);

              // Activate marker
              marker.style.transform = 'rotate(45deg) scale(1)';
              marker.style.background = 'linear-gradient(135deg, rgba(255,255,255,0.9), rgba(236,195,255,1))';
              marker.style.borderColor = 'rgba(255,255,255,1)';
              marker.style.boxShadow = '0 0 25px rgba(255,255,255,0.9), 0 0 50px rgba(236,195,255,0.5)';

              // Glow effect
              innerGlow.style.opacity = '1';

              // Pulse ring
              ring.animate([
                { transform: 'scale(0.8)', opacity: 0 },
                { transform: 'scale(1.5)', opacity: 1, offset: 0.3 },
                { transform: 'scale(2)', opacity: 0 }
              ], { duration: 600, easing: 'ease-out' });

              // Highlight label
              if (label) {
                label.style.opacity = '1';
                label.style.color = 'rgba(255,255,255,1)';
                label.style.fontWeight = '600';
              }
            }
          });

          if (fillAnim.playState === 'running') {
            requestAnimationFrame(checkMilestones);
          }
        };

        requestAnimationFrame(checkMilestones);
        break;
      }

      case 'segmented': {
        // SEGMENTED SWEEP - Progress bar with segmented appearance and milestone animations
        // Create a continuous fill (no gaps in this element)
        fill.style.background = 'linear-gradient(90deg, #c47ae5 0%, #e8b4ff 100%)';
        fill.style.transformOrigin = 'left center';
        fill.style.borderRadius = '8px 0 0 8px'; // Only left side rounded initially
        fill.style.overflow = 'hidden'; // Ensure clean edges

        // Create gaps ABOVE the fill as static overlays
        const segmentCount = 4;
        const segmentGap = 4;

        // Create gap overlays that sit on top of the fill
        const gapOverlay = createEl('div', 'animation-element');
        gapOverlay.style.position = 'absolute';
        gapOverlay.style.inset = '0';
        gapOverlay.style.pointerEvents = 'none';
        gapOverlay.style.zIndex = '10';
        trackContainer.appendChild(gapOverlay);

        // Add vertical gap bars
        for (let i = 1; i < segmentCount; i++) {
          const gap = createEl('div', '');
          gap.style.position = 'absolute';
          gap.style.width = `${segmentGap}px`;
          gap.style.top = '0';
          gap.style.bottom = '0';
          gap.style.left = `calc(${(i * 100 / segmentCount)}% - ${segmentGap/2}px)`;
          gap.style.background = track.style.background || '#2a1040';
          gapOverlay.appendChild(gap);
        }

        // Create segment overlay for animations
        const segmentOverlay = createEl('div', 'animation-element');
        segmentOverlay.style.position = 'absolute';
        segmentOverlay.style.inset = '0';
        segmentOverlay.style.display = 'flex';
        segmentOverlay.style.gap = `${segmentGap}px`;
        segmentOverlay.style.pointerEvents = 'none';
        segmentOverlay.style.borderRadius = 'inherit';
        segmentOverlay.style.zIndex = '5';
        trackContainer.appendChild(segmentOverlay);

        // Create visual segments for animation purposes
        const segments = [];
        for (let i = 0; i < segmentCount; i++) {
          const segment = createEl('div', '');
          segment.style.flex = '1';
          segment.style.position = 'relative';
          // First and last segments get special border radius
          if (i === 0) {
            segment.style.borderRadius = '8px 2px 2px 8px';
          } else if (i === segmentCount - 1) {
            segment.style.borderRadius = '2px 8px 8px 2px';
          } else {
            segment.style.borderRadius = '2px';
          }
          segment.style.border = '1px solid rgba(196,122,229,0.3)';
          segment.style.background = 'rgba(78,24,124,0.1)';
          segment.style.overflow = 'hidden';

          // Bright glow overlay for when segment is filled
          const glowOverlay = createEl('div', '');
          glowOverlay.style.position = 'absolute';
          glowOverlay.style.inset = '0';
          glowOverlay.style.background = 'rgba(232,180,255,0.5)';
          glowOverlay.style.opacity = '0';
          segment.appendChild(glowOverlay);

          // Pulse ring effect
          const pulseRing = createEl('div', '');
          pulseRing.style.position = 'absolute';
          pulseRing.style.inset = '-10px';
          pulseRing.style.border = '2px solid #e8b4ff';
          pulseRing.style.borderRadius = segment.style.borderRadius;
          pulseRing.style.opacity = '0';
          pulseRing.style.pointerEvents = 'none';
          segment.appendChild(pulseRing);

          segmentOverlay.appendChild(segment);
          segments.push({
            element: segment,
            glowOverlay,
            pulseRing
          });
        }

        const duration = 4000; // Slower animation for better visibility

        // Main continuous fill animation (just scales the fill, gaps stay static)
        const fillAnim = fill.animate([
          { transform: 'scaleX(0.001)' }, // Start with tiny width to show left radius
          { transform: 'scaleX(0.99)', offset: 0.99 },
          { transform: 'scaleX(1)' }
        ], {
          duration,
          fill: 'forwards',
          easing: 'linear'
        });

        // Add right border radius only at the very end
        fillAnim.finished.then(() => {
          fill.style.borderRadius = '8px 8px 8px 8px';
        });

        // Trigger segment animations as fill passes each threshold
        segments.forEach((segment, i) => {
          const triggerPoint = (i + 1) / segmentCount; // When to trigger (25%, 50%, 75%, 100%)
          const triggerTime = duration * triggerPoint;

          setTimeout(() => {
            // Bright background flash
            segment.element.animate([
              {
                background: 'rgba(78,24,124,0.1)',
                boxShadow: 'none'
              },
              {
                background: 'rgba(232,180,255,0.4)',
                boxShadow: '0 0 20px rgba(232,180,255,0.6)',
                offset: 0.3
              },
              {
                background: 'rgba(78,24,124,0.1)',
                boxShadow: 'none'
              }
            ], {
              duration: 600,
              easing: 'ease-out'
            });

            // Glow overlay pulse
            segment.glowOverlay.animate([
              { opacity: 0 },
              { opacity: 1, offset: 0.3 },
              { opacity: 0 }
            ], {
              duration: 600,
              easing: 'ease-out'
            });

            // Expanding pulse ring
            segment.pulseRing.animate([
              {
                transform: 'scale(1)',
                opacity: 0
              },
              {
                transform: 'scale(1.15)',
                opacity: 1,
                offset: 0.3
              },
              {
                transform: 'scale(1.3)',
                opacity: 0
              }
            ], {
              duration: 800,
              easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
            });

            // Slight scale bounce on the segment
            segment.element.animate([
              { transform: 'scale(1)' },
              { transform: 'scale(1.08)', offset: 0.3 },
              { transform: 'scale(1)' }
            ], {
              duration: 400,
              easing: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)'
            });
          }, triggerTime);
        });
        break;
      }

      case 'gradient': {
        // GRADIENT GLIDE - Gradient sweep along the bar for premium polish
        fill.style.position = 'relative';
        fill.style.overflow = 'visible';

        // Create multi-layer gradient system
        const gradientBase = createEl('div', 'animation-element');
        gradientBase.style.position = 'absolute';
        gradientBase.style.inset = '0';
        gradientBase.style.background = 'linear-gradient(90deg, #4e187c 0%, #7a468e 25%, #c47ae5 50%, #d79af3 75%, #c6ff77 100%)';
        gradientBase.style.backgroundSize = '300% 100%';
        gradientBase.style.backgroundPosition = '100% 0';
        gradientBase.style.borderRadius = 'inherit';
        fill.appendChild(gradientBase);

        // Shimmer layer
        const shimmerLayer = createEl('div', 'animation-element');
        shimmerLayer.style.position = 'absolute';
        shimmerLayer.style.inset = '0';
        shimmerLayer.style.background = `linear-gradient(105deg,
          transparent 40%,
          rgba(255,255,255,0.7) 50%,
          transparent 60%)`;
        shimmerLayer.style.backgroundSize = '200% 100%';
        shimmerLayer.style.backgroundPosition = '-100% 0';
        shimmerLayer.style.opacity = '0';
        shimmerLayer.style.mixBlendMode = 'overlay';
        shimmerLayer.style.pointerEvents = 'none';
        fill.appendChild(shimmerLayer);

        // Aurora effect overlay
        const aurora = createEl('div', 'animation-element');
        aurora.style.position = 'absolute';
        aurora.style.inset = '-10px';
        aurora.style.background = `radial-gradient(ellipse at center,
          rgba(198,255,119,0) 0%,
          rgba(198,255,119,0.2) 50%,
          rgba(198,255,119,0) 100%)`;
        aurora.style.opacity = '0';
        aurora.style.filter = 'blur(10px)';
        aurora.style.pointerEvents = 'none';
        trackContainer.appendChild(aurora);

        // Leading edge glow
        const edgeGlow = createEl('div', 'animation-element');
        edgeGlow.style.position = 'absolute';
        edgeGlow.style.right = '0';
        edgeGlow.style.top = '50%';
        edgeGlow.style.transform = 'translateY(-50%)';
        edgeGlow.style.width = '40px';
        edgeGlow.style.height = '150%';
        edgeGlow.style.background = 'radial-gradient(ellipse at center, rgba(198,255,119,0.6) 0%, transparent 70%)';
        edgeGlow.style.opacity = '0';
        edgeGlow.style.pointerEvents = 'none';
        edgeGlow.style.filter = 'blur(4px)';
        fill.appendChild(edgeGlow);

        const duration = entry.options.duration || 1800;

        // Main fill animation
        fill.animate([
          { transform: 'scaleX(0)' },
          { transform: 'scaleX(1)' }
        ], { duration, fill: 'forwards', easing: 'cubic-bezier(0.4, 0, 0.2, 1)' });

        // Gradient position animation
        gradientBase.animate([
          { backgroundPosition: '100% 0' },
          { backgroundPosition: '0% 0' }
        ], { duration, fill: 'forwards', easing: 'ease-in-out' });

        // Shimmer sweep
        shimmerLayer.animate([
          { backgroundPosition: '-100% 0', opacity: 0 },
          { backgroundPosition: '-100% 0', opacity: 0, offset: 0.3 },
          { backgroundPosition: '0% 0', opacity: 0.6, offset: 0.5 },
          { backgroundPosition: '100% 0', opacity: 0.6, offset: 0.7 },
          { backgroundPosition: '200% 0', opacity: 0 }
        ], { duration, fill: 'forwards', easing: 'ease-in-out' });

        // Aurora pulse
        aurora.animate([
          { opacity: 0, transform: 'scale(0.8)' },
          { opacity: 0, transform: 'scale(0.8)', offset: 0.4 },
          { opacity: 0.5, transform: 'scale(1.1)', offset: 0.6 },
          { opacity: 0.3, transform: 'scale(1)', offset: 0.8 },
          { opacity: 0, transform: 'scale(0.9)' }
        ], { duration, fill: 'forwards', easing: 'ease-out' });

        // Edge glow animation
        edgeGlow.animate([
          { opacity: 0, transform: 'translateY(-50%) translateX(0)' },
          { opacity: 0.8, transform: 'translateY(-50%) translateX(-5px)', offset: 0.5 },
          { opacity: 0, transform: 'translateY(-50%) translateX(-10px)' }
        ], { duration: duration * 0.9, fill: 'forwards', easing: 'ease-out' });
        break;
      }

      case 'bounce': {
        // BOUNCE FINISH - Elastic finish emphasizes completion state
        fill.style.background = 'linear-gradient(90deg, #c47ae5 0%, #d79af3 100%)';
        fill.style.transformOrigin = 'left center';

        // Create squash and stretch container
        const bounceContainer = createEl('div', 'animation-element');
        bounceContainer.style.position = 'absolute';
        bounceContainer.style.inset = '0';
        bounceContainer.style.transformOrigin = 'right center';
        fill.appendChild(bounceContainer);

        // Impact waves
        const impactWaves = [];
        for (let i = 0; i < 3; i++) {
          const wave = createEl('div', 'animation-element');
          wave.style.position = 'absolute';
          wave.style.right = '0';
          wave.style.top = '50%';
          wave.style.transform = 'translateY(-50%)';
          wave.style.width = '4px';
          wave.style.height = '100%';
          wave.style.background = `rgba(198,255,119,${0.6 - i * 0.2})`;
          wave.style.opacity = '0';
          wave.style.pointerEvents = 'none';
          trackContainer.appendChild(wave);
          impactWaves.push(wave);
        }

        // Elastic deformation overlay
        const elasticOverlay = createEl('div', 'animation-element');
        elasticOverlay.style.position = 'absolute';
        elasticOverlay.style.inset = '0';
        elasticOverlay.style.background = 'radial-gradient(ellipse at right center, rgba(198,255,119,0.3) 0%, transparent 50%)';
        elasticOverlay.style.opacity = '0';
        elasticOverlay.style.pointerEvents = 'none';
        fill.appendChild(elasticOverlay);

        const duration = entry.options.duration || 1600;

        // Main fill with anticipation and overshoot
        const fillAnim = fill.animate([
          { transform: 'scaleX(0) scaleY(1)' },
          { transform: 'scaleX(0.7) scaleY(1)', offset: 0.5 },
          { transform: 'scaleX(0.7) scaleY(0.8)', offset: 0.55 }, // Anticipation squash
          { transform: 'scaleX(1.15) scaleY(0.85)', offset: 0.7 }, // Overshoot with squash
          { transform: 'scaleX(0.92) scaleY(1.08)', offset: 0.78 }, // First bounce
          { transform: 'scaleX(1.06) scaleY(0.96)', offset: 0.86 }, // Second bounce
          { transform: 'scaleX(0.97) scaleY(1.02)', offset: 0.92 }, // Third bounce
          { transform: 'scaleX(1.01) scaleY(0.99)', offset: 0.96 }, // Settle
          { transform: 'scaleX(1) scaleY(1)' }
        ], {
          duration,
          fill: 'forwards',
          easing: 'cubic-bezier(0.34, 1.56, 0.64, 1)'
        });

        // Track deformation
        track.animate([
          { transform: 'scaleY(1)' },
          { transform: 'scaleY(1)', offset: 0.55 },
          { transform: 'scaleY(1.2)', offset: 0.7 },
          { transform: 'scaleY(0.9)', offset: 0.78 },
          { transform: 'scaleY(1.1)', offset: 0.86 },
          { transform: 'scaleY(0.95)', offset: 0.92 },
          { transform: 'scaleY(1)' }
        ], { duration, fill: 'forwards', easing: 'ease-out' });

        // Impact waves animation
        setTimeout(() => {
          impactWaves.forEach((wave, i) => {
            setTimeout(() => {
              wave.animate([
                { transform: 'translateY(-50%) translateX(0) scaleX(1)', opacity: 0 },
                { transform: 'translateY(-50%) translateX(-10px) scaleX(2)', opacity: 1, offset: 0.2 },
                { transform: 'translateY(-50%) translateX(-30px) scaleX(0.5)', opacity: 0 }
              ], { duration: 400, easing: 'ease-out' });
            }, i * 50);
          });
        }, duration * 0.7);

        // Elastic overlay flash
        elasticOverlay.animate([
          { opacity: 0 },
          { opacity: 0, offset: 0.68 },
          { opacity: 1, offset: 0.72 },
          { opacity: 0, offset: 0.85 }
        ], { duration, fill: 'forwards', easing: 'ease-out' });

        // Celebration particles on completion
        fillAnim.finished.then(() => {
          for (let i = 0; i < 5; i++) {
            const particle = createEl('div', 'animation-element');
            particle.style.position = 'absolute';
            particle.style.right = '10px';
            particle.style.top = '50%';
            particle.style.width = '4px';
            particle.style.height = '4px';
            particle.style.background = i % 2 === 0 ? '#c6ff77' : '#c47ae5';
            particle.style.borderRadius = '50%';
            particle.style.pointerEvents = 'none';
            trackContainer.appendChild(particle);

            const angle = (i / 5) * Math.PI * 2;
            const distance = 30 + Math.random() * 20;

            const particleAnim = particle.animate([
              { transform: 'translate(0, -50%) scale(0)', opacity: 1 },
              {
                transform: `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance - 50}%) scale(1)`,
                opacity: 1,
                offset: 0.5
              },
              {
                transform: `translate(${Math.cos(angle) * distance * 1.5}px, ${Math.sin(angle) * distance * 1.5 - 50}%) scale(0)`,
                opacity: 0
              }
            ], { duration: 600, easing: 'cubic-bezier(0.4, 0, 0.6, 1)' });

            // Remove particle after animation
            particleAnim.finished.then(() => particle.remove());
          }
        });
        break;
      }

      case 'thick': {
        // THICK PULSE - High contrast thick bar with gentle pulse loop
        track.style.height = '24px';
        track.style.background = 'linear-gradient(180deg, rgba(78,24,124,0.6) 0%, rgba(78,24,124,0.4) 100%)';
        track.style.boxShadow = 'inset 0 2px 6px rgba(0,0,0,0.4), inset 0 -2px 4px rgba(0,0,0,0.3)';
        track.style.borderRadius = '12px';
        track.style.border = '1px solid rgba(196,122,229,0.2)';

        // Create thick fill with gradient
        fill.style.height = '100%';
        fill.style.background = 'linear-gradient(90deg, #c47ae5 0%, #d79af3 50%, #c6ff77 100%)';
        fill.style.borderRadius = 'inherit';
        fill.style.position = 'relative';
        fill.style.overflow = 'visible';

        // Inner glow layer
        const innerGlow = createEl('div', 'animation-element');
        innerGlow.style.position = 'absolute';
        innerGlow.style.inset = '2px';
        innerGlow.style.background = 'linear-gradient(180deg, rgba(255,255,255,0.3) 0%, transparent 50%, rgba(0,0,0,0.2) 100%)';
        innerGlow.style.borderRadius = 'inherit';
        innerGlow.style.pointerEvents = 'none';
        fill.appendChild(innerGlow);

        // Pulse overlay
        const pulseOverlay = createEl('div', 'animation-element');
        pulseOverlay.style.position = 'absolute';
        pulseOverlay.style.inset = '-4px';
        pulseOverlay.style.background = 'radial-gradient(ellipse at center, rgba(198,255,119,0) 0%, rgba(198,255,119,0.4) 60%, rgba(198,255,119,0) 100%)';
        pulseOverlay.style.opacity = '0';
        pulseOverlay.style.pointerEvents = 'none';
        pulseOverlay.style.filter = 'blur(4px)';
        trackContainer.insertBefore(pulseOverlay, track);

        // Energy core
        const energyCore = createEl('div', 'animation-element');
        energyCore.style.position = 'absolute';
        energyCore.style.inset = '4px';
        energyCore.style.background = 'linear-gradient(90deg, rgba(198,255,119,0.2) 0%, rgba(198,255,119,0.4) 50%, rgba(198,255,119,0.2) 100%)';
        energyCore.style.backgroundSize = '200% 100%';
        energyCore.style.borderRadius = 'inherit';
        energyCore.style.opacity = '0';
        energyCore.style.mixBlendMode = 'screen';
        energyCore.style.pointerEvents = 'none';
        fill.appendChild(energyCore);

        const duration = entry.options.duration || 1400;

        // Main fill with weight
        const fillAnim = fill.animate([
          { transform: 'scaleX(0) scaleY(1)', boxShadow: '0 0 0 rgba(198,255,119,0)' },
          { transform: 'scaleX(0.4) scaleY(1)', boxShadow: '0 0 20px rgba(198,255,119,0.3)', offset: 0.4 },
          { transform: 'scaleX(0.7) scaleY(1)', boxShadow: '0 0 30px rgba(198,255,119,0.5)', offset: 0.7 },
          { transform: 'scaleX(1) scaleY(1)', boxShadow: '0 0 40px rgba(198,255,119,0.6)' }
        ], { duration, fill: 'forwards', easing: 'cubic-bezier(0.4, 0, 0.6, 1)' });

        // Energy core animation
        energyCore.animate([
          { opacity: 0, backgroundPosition: '0% 0' },
          { opacity: 0.5, backgroundPosition: '-50% 0', offset: 0.5 },
          { opacity: 0.8, backgroundPosition: '-100% 0' }
        ], { duration, fill: 'forwards', easing: 'ease-in-out' });

        // Pulse overlay during fill
        pulseOverlay.animate([
          { opacity: 0, transform: 'scale(0.8)' },
          { opacity: 0.6, transform: 'scale(1)', offset: 0.5 },
          { opacity: 0.3, transform: 'scale(1.1)' }
        ], { duration, fill: 'forwards', easing: 'ease-out' });

        // Continuous pulse after completion
        fillAnim.finished.then(() => {
          // Gentle breathing pulse
          const breathe = fill.animate([
            { transform: 'scaleX(1) scaleY(1)', boxShadow: '0 0 40px rgba(198,255,119,0.6)' },
            { transform: 'scaleX(1) scaleY(1.08)', boxShadow: '0 0 50px rgba(198,255,119,0.8)', offset: 0.5 },
            { transform: 'scaleX(1) scaleY(1)', boxShadow: '0 0 40px rgba(198,255,119,0.6)' }
          ], { duration: 2000, iterations: Infinity, easing: 'ease-in-out' });

          // Energy flow
          energyCore.animate([
            { backgroundPosition: '-100% 0' },
            { backgroundPosition: '100% 0' }
          ], { duration: 3000, iterations: Infinity, easing: 'linear' });
        });
        break;
      }

      case 'thin': {
        // THIN GLIDE - Slim tracker for compact UI contexts
        track.style.height = '2px';
        track.style.background = 'linear-gradient(90deg, rgba(78,24,124,0.2) 0%, rgba(78,24,124,0.1) 100%)';
        track.style.overflow = 'visible';
        track.style.borderRadius = '1px';

        // Ultra-thin fill
        fill.style.height = '100%';
        fill.style.background = 'linear-gradient(90deg, #c47ae5 0%, #d79af3 60%, #c6ff77 100%)';
        fill.style.borderRadius = 'inherit';
        fill.style.position = 'relative';
        fill.style.overflow = 'visible';

        // Photon trail (leading light)
        const photonTrail = createEl('div', 'animation-element');
        photonTrail.style.position = 'absolute';
        photonTrail.style.right = '-20px';
        photonTrail.style.top = '50%';
        photonTrail.style.transform = 'translateY(-50%)';
        photonTrail.style.width = '60px';
        photonTrail.style.height = '1px';
        photonTrail.style.background = 'linear-gradient(90deg, rgba(198,255,119,0) 0%, rgba(198,255,119,0.6) 50%, rgba(198,255,119,1) 100%)';
        photonTrail.style.pointerEvents = 'none';
        photonTrail.style.filter = 'blur(0.5px)';
        photonTrail.style.opacity = '0';
        fill.appendChild(photonTrail);

        // Micro pulse dots
        const pulseDots = [];
        for (let i = 0; i < 3; i++) {
          const dot = createEl('div', 'animation-element');
          dot.style.position = 'absolute';
          dot.style.left = `${30 + i * 25}%`;
          dot.style.top = '50%';
          dot.style.transform = 'translate(-50%, -50%)';
          dot.style.width = '4px';
          dot.style.height = '4px';
          dot.style.background = 'rgba(198,255,119,0.8)';
          dot.style.borderRadius = '50%';
          dot.style.opacity = '0';
          dot.style.pointerEvents = 'none';
          trackContainer.appendChild(dot);
          pulseDots.push(dot);
        }

        // Subtle halo
        const halo = createEl('div', 'animation-element');
        halo.style.position = 'absolute';
        halo.style.inset = '-8px';
        halo.style.background = 'radial-gradient(ellipse at right center, rgba(198,255,119,0.2) 0%, transparent 70%)';
        halo.style.opacity = '0';
        halo.style.pointerEvents = 'none';
        halo.style.filter = 'blur(6px)';
        trackContainer.insertBefore(halo, track);

        const duration = entry.options.duration || 1200;

        // Main glide animation
        const fillAnim = fill.animate([
          { transform: 'scaleX(0)', opacity: 0.3 },
          { transform: 'scaleX(0.3)', opacity: 0.6, offset: 0.3 },
          { transform: 'scaleX(0.7)', opacity: 0.8, offset: 0.7 },
          { transform: 'scaleX(1)', opacity: 1 }
        ], { duration, fill: 'forwards', easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)' });

        // Photon trail glide
        photonTrail.animate([
          { opacity: 0, transform: 'translateY(-50%) translateX(20px)' },
          { opacity: 0, transform: 'translateY(-50%) translateX(20px)', offset: 0.2 },
          { opacity: 1, transform: 'translateY(-50%) translateX(0)', offset: 0.5 },
          { opacity: 0.5, transform: 'translateY(-50%) translateX(-10px)', offset: 0.9 },
          { opacity: 0, transform: 'translateY(-50%) translateX(-20px)' }
        ], { duration, fill: 'forwards', easing: 'ease-out' });

        // Pulse dots sequence
        pulseDots.forEach((dot, i) => {
          setTimeout(() => {
            dot.animate([
              { opacity: 0, transform: 'translate(-50%, -50%) scale(0)' },
              { opacity: 1, transform: 'translate(-50%, -50%) scale(1.5)', offset: 0.3 },
              { opacity: 0, transform: 'translate(-50%, -50%) scale(0)' }
            ], { duration: 400, easing: 'ease-out' });
          }, duration * 0.3 + i * 100);
        });

        // Halo fade
        halo.animate([
          { opacity: 0 },
          { opacity: 0, offset: 0.3 },
          { opacity: 0.5, offset: 0.6 },
          { opacity: 0.3, offset: 0.9 },
          { opacity: 0 }
        ], { duration, fill: 'forwards', easing: 'ease-out' });

        // Completion flash
        fillAnim.finished.then(() => {
          const flash = createEl('div', 'animation-element');
          flash.style.position = 'absolute';
          flash.style.inset = '-4px';
          flash.style.background = 'linear-gradient(90deg, transparent 0%, rgba(198,255,119,0.4) 100%)';
          flash.style.pointerEvents = 'none';
          trackContainer.appendChild(flash);

          const flashAnim = flash.animate([
            { opacity: 0, transform: 'scaleX(0.8)' },
            { opacity: 1, transform: 'scaleX(1)', offset: 0.3 },
            { opacity: 0, transform: 'scaleX(1)' }
          ], { duration: 300, easing: 'ease-out' });

          // Remove flash after animation
          flashAnim.finished.then(() => flash.remove());
        });
        break;
      }

      case 'surge': {
        // SURGE FINALE - Acceleration surge with overshoot to draw attention
  fill.style.background = 'linear-gradient(90deg, #4e187c 0%, #7a468e 30%, #c47ae5 60%, #e8b4ff 100%)';
  fill.style.backgroundSize = '150% 100%';
  fill.style.backgroundRepeat = 'no-repeat'; // Prevent tiling that causes a bright strip on the left during overshoot
  fill.style.backgroundColor = '#4e187c'; // Base color under gradient to avoid any gap during overshoot shifts
        fill.style.position = 'relative';
        fill.style.overflow = 'visible';

        // Power buildup indicator
        const powerGauge = createEl('div', 'animation-element');
        powerGauge.style.position = 'absolute';
        powerGauge.style.inset = '0';
        powerGauge.style.background = 'linear-gradient(90deg, transparent 0%, rgba(232,180,255,0.15) 100%)';
        powerGauge.style.opacity = '0';
        powerGauge.style.pointerEvents = 'none';
        fill.appendChild(powerGauge);

        // Energy accumulation particles
        const particleContainer = createEl('div', 'animation-element');
        particleContainer.style.position = 'absolute';
        particleContainer.style.inset = '0';
        particleContainer.style.pointerEvents = 'none';
        trackContainer.appendChild(particleContainer);

        // Speed lines
        const speedLines = [];
        for (let i = 0; i < 5; i++) {
          const line = createEl('div', 'animation-element');
          line.style.position = 'absolute';
          line.style.left = '0';
          line.style.top = `${20 + i * 15}%`;
          line.style.width = '100%';
          line.style.height = '1px';
          line.style.background = `linear-gradient(90deg, transparent 0%, rgba(232,180,255,${0.4 - i * 0.06}) 50%, transparent 100%)`;
          line.style.opacity = '0';
          line.style.pointerEvents = 'none';
          line.style.transform = 'scaleX(0)';
          particleContainer.appendChild(line);
          speedLines.push(line);
        }

        // Shockwave ring - positioned inside fill container to track with progress
        const shockwave = createEl('div', 'animation-element');
        shockwave.style.position = 'absolute';
        shockwave.style.right = '-30px'; // Center it at the edge of the fill
        shockwave.style.top = '50%';
        shockwave.style.transform = 'translateY(-50%)';
        shockwave.style.width = '60px';
        shockwave.style.height = '60px';
        shockwave.style.border = '2px solid rgba(232,180,255,0.9)';
        shockwave.style.borderRadius = '50%';
        shockwave.style.opacity = '0';
        shockwave.style.pointerEvents = 'none';
        fill.appendChild(shockwave); // Add to fill instead of trackContainer

        const duration = entry.options.duration || 2000;

        // Main surge animation with accelerating buildup and explosive finish
        const fillAnim = fill.animate([
          { transform: 'scaleX(0)', backgroundPosition: '0% 0' },
          { transform: 'scaleX(0.3)', backgroundPosition: '10% 0', offset: 0.3 }, // Initial progress
          { transform: 'scaleX(0.5)', backgroundPosition: '20% 0', offset: 0.5 }, // Building momentum
          { transform: 'scaleX(0.7)', backgroundPosition: '30% 0', offset: 0.65 }, // Accelerating
          { transform: 'scaleX(1.08)', backgroundPosition: '-20% 0', offset: 0.82 }, // Explosive surge
          { transform: 'scaleX(0.96)', backgroundPosition: '-10% 0', offset: 0.88 }, // Recoil
          { transform: 'scaleX(1.02)', backgroundPosition: '-15% 0', offset: 0.94 }, // Secondary surge
          { transform: 'scaleX(1)', backgroundPosition: '-12% 0' } // Settle at exactly 100%
        ], { duration, fill: 'forwards', easing: 'cubic-bezier(0.5, 0, 0.15, 1)' });

        // Power gauge buildup
        powerGauge.animate([
          { opacity: 0 },
          { opacity: 0.3, offset: 0.3 },
          { opacity: 0.5, offset: 0.5 },
          { opacity: 0.8, offset: 0.6 },
          { opacity: 0, offset: 0.65 }
        ], { duration, fill: 'forwards', easing: 'ease-in' });

        // Speed lines activation
        setTimeout(() => {
          speedLines.forEach((line, i) => {
            setTimeout(() => {
              line.animate([
                { opacity: 0, transform: 'scaleX(0) translateX(0)' },
                { opacity: 1, transform: 'scaleX(0.5) translateX(50%)', offset: 0.3 },
                { opacity: 0, transform: 'scaleX(1) translateX(100%)' }
              ], { duration: 400, easing: 'cubic-bezier(0.5, 0, 0.5, 1)' });
            }, i * 30);
          });
        }, duration * 0.6);

        // Shockwave explosion - timed to match the explosive surge at 82% of duration
        setTimeout(() => {
          shockwave.animate([
            { transform: 'translateY(-50%) scale(0)', opacity: 0 },
            { transform: 'translateY(-50%) scale(1)', opacity: 1, offset: 0.2 },
            { transform: 'translateY(-50%) scale(2.5)', opacity: 0 }
          ], { duration: 600, easing: 'cubic-bezier(0.5, 0, 0.5, 1)' });

          // Impact shake
          trackContainer.animate([
            { transform: 'translateX(0)' },
            { transform: 'translateX(3px)', offset: 0.2 },
            { transform: 'translateX(-3px)', offset: 0.4 },
            { transform: 'translateX(2px)', offset: 0.6 },
            { transform: 'translateX(-1px)', offset: 0.8 },
            { transform: 'translateX(0)' }
          ], { duration: 300, easing: 'ease-out' });
        }, duration * 0.82);

        // Completion energy dispersal
        fillAnim.finished.then(() => {
          for (let i = 0; i < 8; i++) {
            const particle = createEl('div', 'animation-element');
            particle.style.position = 'absolute';
            particle.style.right = '10px';
            particle.style.top = '50%';
            particle.style.width = '3px';
            particle.style.height = '3px';
            particle.style.background = '#e8b4ff';
            particle.style.borderRadius = '50%';
            particle.style.pointerEvents = 'none';
            trackContainer.appendChild(particle);

            const angle = (i / 8) * Math.PI * 2;
            const velocity = 40 + Math.random() * 30;

            const particleAnim = particle.animate([
              { transform: 'translate(0, -50%)', opacity: 1 },
              {
                transform: `translate(${Math.cos(angle) * velocity}px, ${Math.sin(angle) * velocity - 50}%)`,
                opacity: 0
              }
            ], { duration: 800, easing: 'cubic-bezier(0.5, 0, 0.5, 1)' });

            // Clean up particle after animation
            particleAnim.finished.then(() => particle.remove());
          }
        });
        break;
      }

      case 'spark': {
        // SPARK TRAIL - Professional spark trail that glides along the bar with trailing particles
        fill.style.background = 'linear-gradient(90deg, #4e187c 0%, #7a468e 50%, #c47ae5 100%)';
        fill.style.position = 'relative';
        fill.style.overflow = 'visible';

        // Create trailing gradient that follows the spark
        const trailGradient = createEl('div', 'animation-element');
        trailGradient.style.position = 'absolute';
        trailGradient.style.inset = '0';
        trailGradient.style.background = 'linear-gradient(90deg, transparent 0%, rgba(232,180,255,0.6) 70%, rgba(255,255,255,0.9) 95%, transparent 100%)';
        trailGradient.style.backgroundSize = '30% 100%';
        trailGradient.style.backgroundPosition = '-30% 0';
        trailGradient.style.backgroundRepeat = 'no-repeat';
        trailGradient.style.mixBlendMode = 'screen';
        trailGradient.style.pointerEvents = 'none';
        fill.appendChild(trailGradient);

        // Main spark that travels along the bar
        const sparkLeader = createEl('div', 'animation-element');
        sparkLeader.style.position = 'absolute';
        sparkLeader.style.width = '60px';
        sparkLeader.style.height = '60px';
        sparkLeader.style.left = '-30px';
        sparkLeader.style.top = '50%';
        sparkLeader.style.transform = 'translateY(-50%)';
        sparkLeader.style.pointerEvents = 'none';
        sparkLeader.style.zIndex = '30';
        fill.appendChild(sparkLeader);

        // Bright core of the spark
        const sparkCore = createEl('div', '');
        sparkCore.style.position = 'absolute';
        sparkCore.style.left = '50%';
        sparkCore.style.top = '50%';
        sparkCore.style.transform = 'translate(-50%, -50%)';
        sparkCore.style.width = '8px';
        sparkCore.style.height = '8px';
        sparkCore.style.background = '#ffffff';
        sparkCore.style.borderRadius = '50%';
        sparkCore.style.boxShadow = '0 0 10px #ffffff, 0 0 20px #e8b4ff, 0 0 30px #c47ae5';
        sparkLeader.appendChild(sparkCore);

        // Outer glow halo
        const sparkHalo = createEl('div', '');
        sparkHalo.style.position = 'absolute';
        sparkHalo.style.inset = '0';
        sparkHalo.style.background = 'radial-gradient(circle, rgba(232,180,255,0.8) 0%, rgba(196,122,229,0.4) 30%, transparent 70%)';
        sparkHalo.style.filter = 'blur(3px)';
        sparkLeader.appendChild(sparkHalo);

        // Container for trailing particles
        const trailContainer = createEl('div', 'animation-element');
        trailContainer.style.position = 'absolute';
        trailContainer.style.inset = '0';
        trailContainer.style.pointerEvents = 'none';
        fill.appendChild(trailContainer);

        const duration = entry.options.duration || 2000;

        // Main fill animation
        fill.animate([
          { transform: 'scaleX(0)', opacity: 0.7 },
          { transform: 'scaleX(1)', opacity: 1 }
        ], { duration, fill: 'forwards', easing: 'cubic-bezier(0.25, 0.1, 0.25, 1)' });

        // Trailing gradient sweep
        trailGradient.animate([
          { backgroundPosition: '-30% 0' },
          { backgroundPosition: '130% 0' }
        ], { duration, fill: 'forwards', easing: 'cubic-bezier(0.25, 0.1, 0.25, 1)' });

        // Spark leader movement
        const leaderAnim = sparkLeader.animate([
          { left: '-30px', opacity: 0 },
          { left: '-30px', opacity: 1, offset: 0.02 },
          { left: 'calc(100% - 30px)', opacity: 1, offset: 0.98 },
          { left: 'calc(100% - 30px)', opacity: 0 }
        ], { duration, fill: 'forwards', easing: 'cubic-bezier(0.25, 0.1, 0.25, 1)' });

        // Spark core pulsing
        sparkCore.animate([
          { transform: 'translate(-50%, -50%) scale(0.8)', filter: 'brightness(0.9)' },
          { transform: 'translate(-50%, -50%) scale(1.3)', filter: 'brightness(1.2)', offset: 0.5 },
          { transform: 'translate(-50%, -50%) scale(0.8)', filter: 'brightness(0.9)' }
        ], { duration: 150, iterations: Math.ceil(duration / 150), easing: 'ease-in-out' });

        // Spark halo breathing
        sparkHalo.animate([
          { transform: 'scale(0.9)', opacity: 0.8 },
          { transform: 'scale(1.2)', opacity: 1, offset: 0.5 },
          { transform: 'scale(0.9)', opacity: 0.8 }
        ], { duration: 300, iterations: Math.ceil(duration / 300), easing: 'ease-in-out' });

        // Create trailing particles that follow the spark
        const createTrailParticle = (progress) => {
          const particle = createEl('div', 'animation-element');
          particle.style.position = 'absolute';
          particle.style.left = `${progress * 100}%`;
          particle.style.top = '50%';
          particle.style.width = '35px';
          particle.style.height = '2px';
          particle.style.background = 'linear-gradient(90deg, transparent, rgba(255,255,255,0.9) 20%, #e8b4ff 60%, transparent)';
          particle.style.transform = 'translateY(-50%)';
          particle.style.filter = 'blur(0.5px)';
          particle.style.pointerEvents = 'none';
          trailContainer.appendChild(particle);

          const particleAnim = particle.animate([
            { transform: 'translateY(-50%) translateX(0) scaleX(0.3)', opacity: 0 },
            { transform: 'translateY(-50%) translateX(-10px) scaleX(1)', opacity: 0.9, offset: 0.3 },
            { transform: 'translateY(-50%) translateX(-35px) scaleX(0.2)', opacity: 0 }
          ], { duration: 900, easing: 'cubic-bezier(0.5, 0, 0.5, 1)' });

          particleAnim.finished.then(() => particle.remove());
        };

        // Emit trailing particles at intervals
        const particleInterval = 50;
        const particleCount = duration / particleInterval;
        for (let i = 0; i < particleCount; i++) {
          setTimeout(() => {
            const progress = i / particleCount;
            createTrailParticle(progress);
            // Create multiple particles for denser trail
            if (Math.random() > 0.5) {
              createTrailParticle(progress);
            }
          }, i * particleInterval);
        }

        // Final burst when spark reaches the end
        leaderAnim.finished.then(() => {
          const burst = createEl('div', 'animation-element');
          burst.style.position = 'absolute';
          burst.style.right = '-50px'; // Center the burst at the right edge
          burst.style.top = '50%';
          burst.style.transform = 'translateY(-50%)';
          burst.style.width = '100px';
          burst.style.height = '100px';
          burst.style.background = 'radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(232,180,255,0.6) 30%, transparent 60%)';
          burst.style.pointerEvents = 'none';
          fill.appendChild(burst);

          const burstAnim = burst.animate([
            { transform: 'translateY(-50%) scale(0)', opacity: 1 },
            { transform: 'translateY(-50%) scale(2)', opacity: 0 }
          ], { duration: 400, easing: 'ease-out' });

          burstAnim.finished.then(() => burst.remove());
        });
        break;
      }

      case 'wave': {
        // WAVE MOTION - Professional wave pattern that ripples across the filled area
        fill.style.position = 'relative';
        fill.style.background = 'linear-gradient(90deg, #7a468e 0%, #c47ae5 50%, #7a468e 100%)';
        fill.style.overflow = 'hidden';
        fill.style.borderRadius = 'inherit';

        // Create wave pattern using SVG for smooth curves
        const wavePattern = createEl('div', 'animation-element');
        wavePattern.style.position = 'absolute';
        wavePattern.style.inset = '0';
        wavePattern.style.background = `repeating-linear-gradient(
          90deg,
          transparent,
          transparent 10px,
          rgba(232,180,255,0.15) 10px,
          rgba(232,180,255,0.15) 20px
        )`;
        wavePattern.style.backgroundSize = '40px 100%';
        wavePattern.style.pointerEvents = 'none';
        wavePattern.style.opacity = '0';
        fill.appendChild(wavePattern);

        // Create undulating wave effect with multiple layers
        const waveContainer = createEl('div', 'animation-element');
        waveContainer.style.position = 'absolute';
        waveContainer.style.inset = '0';
        waveContainer.style.pointerEvents = 'none';
        waveContainer.style.overflow = 'hidden';
        fill.appendChild(waveContainer);

        // Create 3 wave layers for depth
        const waves = [];
        for (let i = 0; i < 3; i++) {
          const wave = createEl('div', 'animation-element');
          wave.style.position = 'absolute';
          wave.style.left = '-100%';
          wave.style.top = '0';
          wave.style.width = '200%';
          wave.style.height = '100%';
          wave.style.background = `linear-gradient(
            90deg,
            transparent 0%,
            rgba(255,255,255,${0.3 - i * 0.08}) 25%,
            rgba(232,180,255,${0.4 - i * 0.1}) 50%,
            rgba(255,255,255,${0.3 - i * 0.08}) 75%,
            transparent 100%
          )`;
          wave.style.borderRadius = '50%';
          wave.style.transform = `translateY(${-30 + i * 20}%) scaleY(${2 - i * 0.3})`;
          wave.style.pointerEvents = 'none';
          waveContainer.appendChild(wave);
          waves.push(wave);
        }

        // Create shimmer highlight that travels with the wave
        const shimmer = createEl('div', 'animation-element');
        shimmer.style.position = 'absolute';
        shimmer.style.inset = '0';
        shimmer.style.background = 'linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.6) 50%, transparent 100%)';
        shimmer.style.backgroundSize = '20% 100%';
        shimmer.style.backgroundPosition = '-20% 0';
        shimmer.style.backgroundRepeat = 'no-repeat';
        shimmer.style.mixBlendMode = 'overlay';
        shimmer.style.pointerEvents = 'none';
        fill.appendChild(shimmer);

        // Create ripple effects container
        const rippleContainer = createEl('div', 'animation-element');
        rippleContainer.style.position = 'absolute';
        rippleContainer.style.inset = '0';
        rippleContainer.style.pointerEvents = 'none';
        fill.appendChild(rippleContainer);

        const duration = entry.options.duration || 2200;

        // Main fill animation
        const fillAnim = fill.animate([
          { transform: 'scaleX(0)', opacity: 0.8 },
          { transform: 'scaleX(1)', opacity: 1 }
        ], { duration, fill: 'forwards', easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)' });

        // Wave pattern animation
        wavePattern.animate([
          { backgroundPosition: '0px 0', opacity: 0 },
          { backgroundPosition: '0px 0', opacity: 1, offset: 0.1 },
          { backgroundPosition: '40px 0', opacity: 1, offset: 0.9 },
          { backgroundPosition: '40px 0', opacity: 0 }
        ], { duration, fill: 'forwards', easing: 'linear' });

        // Animate each wave layer with different speeds for depth
        waves.forEach((wave, index) => {
          const waveSpeed = 1 - index * 0.2;
          const waveDelay = index * 100;

          setTimeout(() => {
            wave.animate([
              { left: '-100%', opacity: 0 },
              { left: '-80%', opacity: 0.8, offset: 0.1 },
              { left: '0%', opacity: 1, offset: 0.5 },
              { left: '80%', opacity: 0.8, offset: 0.9 },
              { left: '100%', opacity: 0 }
            ], {
              duration: duration * waveSpeed,
              fill: 'forwards',
              easing: 'cubic-bezier(0.37, 0, 0.63, 1)'
            });
          }, waveDelay);
        });

        // Shimmer animation
        shimmer.animate([
          { backgroundPosition: '-20% 0' },
          { backgroundPosition: '120% 0' }
        ], { duration: duration * 0.8, fill: 'forwards', easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)' });

        // Create ripple effects at intervals
        const createRipple = (progress) => {
          const ripple = createEl('div', 'animation-element');
          ripple.style.position = 'absolute';
          ripple.style.left = `${progress * 100}%`;
          ripple.style.top = '50%';
          ripple.style.transform = 'translate(-50%, -50%)';
          ripple.style.width = '20px';
          ripple.style.height = '20px';
          ripple.style.border = '1px solid rgba(232,180,255,0.6)';
          ripple.style.borderRadius = '50%';
          ripple.style.pointerEvents = 'none';
          rippleContainer.appendChild(ripple);

          const rippleAnim = ripple.animate([
            { transform: 'translate(-50%, -50%) scale(0)', opacity: 1 },
            { transform: 'translate(-50%, -50%) scale(3)', opacity: 0 }
          ], { duration: 800, easing: 'ease-out' });

          rippleAnim.finished.then(() => ripple.remove());
        };

        // Generate ripples along the wave
        const rippleCount = 8;
        for (let i = 0; i < rippleCount; i++) {
          setTimeout(() => {
            createRipple(i / rippleCount);
          }, (duration / rippleCount) * i + 200);
        }

        // Final crest splash when wave completes
        fillAnim.finished.then(() => {
          // Create final wave crest
          const crest = createEl('div', 'animation-element');
          crest.style.position = 'absolute';
          crest.style.right = '0';
          crest.style.top = '0';
          crest.style.width = '60px';
          crest.style.height = '100%';
          crest.style.background = 'linear-gradient(90deg, transparent, rgba(232,180,255,0.4))';
          crest.style.pointerEvents = 'none';
          fill.appendChild(crest);

          const crestAnim = crest.animate([
            { transform: 'translateX(0) scaleY(0.5)', opacity: 0 },
            { transform: 'translateX(-10px) scaleY(1.2)', opacity: 1, offset: 0.3 },
            { transform: 'translateX(-20px) scaleY(1)', opacity: 0 }
          ], { duration: 400, easing: 'ease-out' });

          crestAnim.finished.then(() => crest.remove());

          // Create splash particles
          for (let i = 0; i < 5; i++) {
            const particle = createEl('div', 'animation-element');
            particle.style.position = 'absolute';
            particle.style.right = '10px';
            particle.style.top = `${30 + i * 10}%`;
            particle.style.width = '3px';
            particle.style.height = '3px';
            particle.style.background = '#e8b4ff';
            particle.style.borderRadius = '50%';
            particle.style.pointerEvents = 'none';
            fill.appendChild(particle);

            const particleAnim = particle.animate([
              { transform: 'translate(0, 0) scale(1)', opacity: 1 },
              { transform: `translate(${-10 - i * 5}px, ${-5 + i * 2}px) scale(0)`, opacity: 0 }
            ], { duration: 500, easing: 'ease-out' });

            particleAnim.finished.then(() => particle.remove());
          }
        });
        break;
      }

      default: {
        // Default smooth fill
        playWAAPI(fill, [
          { transform: 'scaleX(0)' },
          { transform: 'scaleX(1)' }
        ], { duration: entry.options.duration, fill: 'forwards', easing: entry.options.easing || easingCurves.gentle });
      }
    }
  };

  return { element: wrapper, play };
};


// Modal Celebration animations factory
factoryMap.modalCelebration = (entry) => {
  const { overlay, modal } = createModalShell('Victory!', ['Congratulations! You\'ve achieved greatness!']);
  const style = entry.options.style;

  // Add celebration container
  const celebrationContainer = createEl('div', 'pf-celebration');
  celebrationContainer.style.position = 'absolute';
  celebrationContainer.style.top = '0';
  celebrationContainer.style.left = '0';
  celebrationContainer.style.width = '100%';
  celebrationContainer.style.height = '100%';
  celebrationContainer.style.pointerEvents = 'none';
  celebrationContainer.style.zIndex = '1000';
  overlay.appendChild(celebrationContainer);

  const play = () => {
    // Clear previous animations
    celebrationContainer.innerHTML = '';

    if (style === 'confetti-burst') {
      // Create confetti burst effect
      const colors = ['#c83558', '#c6ff77', '#ecc3ff', '#47fff4', '#ffb300'];
      const particles = entry.options.particles || 32;

      for (let i = 0; i < particles; i++) {
        const confetti = createEl('div', '');
        confetti.style.position = 'absolute';
        confetti.style.width = '10px';
        confetti.style.height = '14px';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.left = '50%';
        confetti.style.top = '50%';
        confetti.style.transform = 'translate(-50%, -50%)';
        confetti.style.borderRadius = '2px';
        celebrationContainer.appendChild(confetti);

        const angle = (Math.PI * 2 * i) / particles;
        const velocity = 150 + Math.random() * 150;
        const rotateEnd = Math.random() * 720 - 360;

        playMotion(confetti, {
          translateX: [0, Math.cos(angle) * velocity],
          translateY: [0, Math.sin(angle) * velocity - 50],
          opacity: [1, 0],
          rotate: [0, rotateEnd],
          scale: [1, 0.5]
        }, {
          duration: entry.options.duration || 1500,
          easing: easingCurves.entrance
        });
      }
    } else if (style === 'confetti-fan') {
      // Fan spread pattern
      const colors = ['#c83558', '#c6ff77', '#ecc3ff', '#47fff4'];
      const particles = entry.options.particles || 28;

      for (let i = 0; i < particles; i++) {
        const confetti = createEl('div', '');
        confetti.style.position = 'absolute';
        confetti.style.width = '8px';
        confetti.style.height = '12px';
        confetti.style.backgroundColor = colors[i % colors.length];
        confetti.style.left = '50%';
        confetti.style.bottom = '20%';
        confetti.style.transform = 'translateX(-50%)';
        celebrationContainer.appendChild(confetti);

        const angle = -Math.PI/3 + (Math.PI * 2/3 * i) / (particles - 1);
        const velocity = 200 + Math.random() * 100;

        playMotion(confetti, {
          translateX: [0, Math.cos(angle) * velocity],
          translateY: [0, Math.sin(angle) * velocity],
          opacity: [1, 0],
          rotate: [0, Math.random() * 360]
        }, {
          duration: entry.options.duration || 1300,
          easing: easingCurves.entrance
        });
      }
    } else if (style === 'confetti-spiral') {
      // Spiral pattern
      const colors = ['#c83558', '#c6ff77', '#ecc3ff', '#ffb300'];
      const particles = entry.options.particles || 36;

      for (let i = 0; i < particles; i++) {
        const confetti = createEl('div', '');
        confetti.style.position = 'absolute';
        confetti.style.width = '10px';
        confetti.style.height = '10px';
        confetti.style.backgroundColor = colors[i % colors.length];
        confetti.style.left = '50%';
        confetti.style.top = '50%';
        confetti.style.borderRadius = '50%';
        celebrationContainer.appendChild(confetti);

        const angle = (Math.PI * 2 * i * 3) / particles;
        const radius = 20 + (i * 8);

        playMotion(confetti, {
          translateX: [0, Math.cos(angle) * radius],
          translateY: [0, Math.sin(angle) * radius],
          opacity: [1, 0],
          scale: [0.5, 1.2, 0]
        }, {
          duration: entry.options.duration || 1500,
          easing: easingCurves.vibrant,
          delay: i * 20
        });
      }
    } else if (style === 'confetti-rain') {
      // Rainfall pattern
      const colors = ['#c83558', '#c6ff77', '#ecc3ff', '#47fff4', '#ffb300'];
      const particles = entry.options.particles || 60;

      for (let i = 0; i < particles; i++) {
        const confetti = createEl('div', '');
        confetti.style.position = 'absolute';
        confetti.style.width = '6px';
        confetti.style.height = '10px';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.top = '-20px';
        confetti.style.borderRadius = '2px';
        celebrationContainer.appendChild(confetti);

        playMotion(confetti, {
          translateY: [0, window.innerHeight + 40],
          translateX: [0, (Math.random() - 0.5) * 100],
          rotate: [0, Math.random() * 360],
          opacity: [1, 0.7, 0]
        }, {
          duration: entry.options.duration || 1700,
          easing: easingCurves.gentle,
          delay: Math.random() * 500
        });
      }
    } else if (style === 'fireworks-triple') {
      // Triple burst fireworks
      const bursts = entry.options.bursts || 3;
      const colors = ['#c83558', '#c6ff77', '#47fff4'];

      for (let b = 0; b < bursts; b++) {
        setTimeout(() => {
          const burstX = 25 + (b * 25) + '%';
          const burstY = 30 + (Math.random() * 20) + '%';

          // Create burst center flash
          const flash = createEl('div', '');
          flash.style.position = 'absolute';
          flash.style.width = '60px';
          flash.style.height = '60px';
          flash.style.borderRadius = '50%';
          flash.style.background = `radial-gradient(circle, ${colors[b]}, transparent)`;
          flash.style.left = burstX;
          flash.style.top = burstY;
          flash.style.transform = 'translate(-50%, -50%)';
          celebrationContainer.appendChild(flash);

          playMotion(flash, {
            scale: [0, 2, 0],
            opacity: [1, 0.3, 0]
          }, {
            duration: 600,
            easing: easingCurves.vibrant
          });

          // Create particles
          for (let i = 0; i < 12; i++) {
            const particle = createEl('div', '');
            particle.style.position = 'absolute';
            particle.style.width = '4px';
            particle.style.height = '4px';
            particle.style.borderRadius = '50%';
            particle.style.backgroundColor = colors[b];
            particle.style.left = burstX;
            particle.style.top = burstY;
            particle.style.boxShadow = `0 0 6px ${colors[b]}`;
            celebrationContainer.appendChild(particle);

            const angle = (Math.PI * 2 * i) / 12;
            const velocity = 80 + Math.random() * 40;

            playMotion(particle, {
              translateX: [0, Math.cos(angle) * velocity],
              translateY: [0, Math.sin(angle) * velocity],
              opacity: [1, 0],
              scale: [1, 0]
            }, {
              duration: 800,
              easing: easingCurves.entrance
            });
          }
        }, b * 200);
      }
    } else if (style === 'fireworks-ring') {
      // Halo/ring fireworks
      const rings = entry.options.bursts || 2;

      for (let r = 0; r < rings; r++) {
        const ring = createEl('div', '');
        ring.style.position = 'absolute';
        ring.style.width = '200px';
        ring.style.height = '200px';
        ring.style.border = '3px solid';
        ring.style.borderColor = r === 0 ? '#c6ff77' : '#47fff4';
        ring.style.borderRadius = '50%';
        ring.style.left = '50%';
        ring.style.top = '40%';
        ring.style.transform = 'translate(-50%, -50%)';
        ring.style.boxShadow = `0 0 20px ${r === 0 ? '#c6ff77' : '#47fff4'}`;
        celebrationContainer.appendChild(ring);

        playMotion(ring, {
          scale: [0, 1.5 + r * 0.3],
          opacity: [1, 0],
          borderWidth: ['3px', '1px']
        }, {
          duration: entry.options.duration || 1500,
          easing: easingCurves.entrance,
          delay: r * 150
        });
      }
    } else if (style === 'reward-spotlight') {
      // Spotlight beams
      const beams = entry.options.beams || 5;

      for (let i = 0; i < beams; i++) {
        const beam = createEl('div', '');
        beam.style.position = 'absolute';
        beam.style.width = '2px';
        beam.style.height = '300px';
        beam.style.background = 'linear-gradient(to bottom, transparent, #c6ff77, transparent)';
        beam.style.left = '50%';
        beam.style.top = '50%';
        beam.style.transformOrigin = 'center top';
        beam.style.opacity = '0.6';
        celebrationContainer.appendChild(beam);

        const angle = (360 / beams) * i;

        playMotion(beam, {
          rotate: [angle, angle + 360],
          scaleY: [0, 1, 1, 0],
          opacity: [0, 0.6, 0.6, 0]
        }, {
          duration: entry.options.duration || 1500,
          easing: easingCurves.standard
        });
      }
    } else if (style === 'jackpot-celebration') {
      // Complex jackpot celebration
      const colors = ['#ffb300', '#c6ff77', '#c83558', '#47fff4'];

      // Central burst
      const centralBurst = createEl('div', '');
      centralBurst.style.position = 'absolute';
      centralBurst.style.width = '100px';
      centralBurst.style.height = '100px';
      centralBurst.style.borderRadius = '50%';
      centralBurst.style.background = 'radial-gradient(circle, #ffb300, transparent)';
      centralBurst.style.left = '50%';
      centralBurst.style.top = '50%';
      centralBurst.style.transform = 'translate(-50%, -50%)';
      celebrationContainer.appendChild(centralBurst);

      playMotion(centralBurst, {
        scale: [0, 3],
        opacity: [1, 0]
      }, {
        duration: 800,
        easing: easingCurves.vibrant
      });

      // Star particles
      for (let i = 0; i < 24; i++) {
        const star = createEl('div', '');
        star.style.position = 'absolute';
        star.style.width = '8px';
        star.style.height = '8px';
        star.style.backgroundColor = colors[i % colors.length];
        star.style.left = '50%';
        star.style.top = '50%';
        star.style.clipPath = 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)';
        celebrationContainer.appendChild(star);

        const angle = (Math.PI * 2 * i) / 24;
        const velocity = 100 + Math.random() * 100;

        playMotion(star, {
          translateX: [0, Math.cos(angle) * velocity],
          translateY: [0, Math.sin(angle) * velocity],
          rotate: [0, 720],
          scale: [0, 1.5, 0],
          opacity: [1, 1, 0]
        }, {
          duration: entry.options.duration || 1700,
          easing: easingCurves.vibrant,
          delay: Math.floor(i / 6) * 100
        });
      }
    } else if (style === 'confetti-pulse') {
      // Pulse wave confetti
      const waves = 3;
      const particlesPerWave = Math.floor((entry.options.particles || 40) / waves);
      const colors = ['#c83558', '#c6ff77', '#ecc3ff', '#47fff4'];

      for (let w = 0; w < waves; w++) {
        setTimeout(() => {
          for (let i = 0; i < particlesPerWave; i++) {
            const confetti = createEl('div', '');
            confetti.style.position = 'absolute';
            confetti.style.width = '8px';
            confetti.style.height = '8px';
            confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.borderRadius = '50%';
            confetti.style.left = '50%';
            confetti.style.top = '50%';
            celebrationContainer.appendChild(confetti);

            const angle = (Math.PI * 2 * i) / particlesPerWave;
            const velocity = 80 + w * 40;

            playMotion(confetti, {
              translateX: [0, Math.cos(angle) * velocity],
              translateY: [0, Math.sin(angle) * velocity],
              scale: [0, 1, 0],
              opacity: [1, 1, 0]
            }, {
              duration: 1000,
              easing: easingCurves.vibrant
            });
          }
        }, w * 200);
      }
    }

    // Animate modal entrance
    overlay.style.animation = `pf-overlay-fade 400ms ${easingCurves.entrance} forwards`;
    modal.style.animation = `pf-modal-scale-pop 500ms ${easingCurves.entrance} both`;
  };

  return { element: overlay, play, height: "400px" };
};

factoryMap.loader = (entry) => {
  const container = createEl('div', 'pf-loader');
  const style = entry.options.style || entry.options.layout;

  const createSkeleton = (orientation) => {
    const skeleton = createEl('div', `pf-skeleton pf-skeleton--${orientation}`);
    if (orientation === 'grid') {
      for (let i = 0; i < 6; i += 1) {
        skeleton.appendChild(createEl('div', 'pf-skeleton__tile'));
      }
    } else {
      const lines = orientation === 'card' ? 4 : 6;
      for (let i = 0; i < lines; i += 1) {
        skeleton.appendChild(createEl('div', 'pf-skeleton__line'));
      }
    }
    container.appendChild(skeleton);
    return skeleton;
  };

  let animatedElement;
  let dots = [];

  if (entry.options.layout) {
    animatedElement = createSkeleton(entry.options.layout);
  } else if (style === 'dual-ring' || style === 'orbital' || style === 'galaxy') {
    animatedElement = createEl('div', `pf-spinner pf-spinner--${style}`);
    container.appendChild(animatedElement);
  } else if (style === 'rise' || style === 'wave' || style === 'portal') {
    // Dots animations
    animatedElement = createEl('div', 'pf-dots');
    animatedElement.style.display = 'flex';
    animatedElement.style.gap = '8px';
    animatedElement.style.alignItems = 'center';
    animatedElement.style.justifyContent = 'center';

    for (let i = 0; i < 3; i += 1) {
      const dot = createEl('span', '');
      dot.style.width = '12px';
      dot.style.height = '12px';
      dot.style.backgroundColor = '#c47ae5';
      dot.style.borderRadius = '50%';
      dot.style.display = 'inline-block';
      dots.push(dot);
      animatedElement.appendChild(dot);
    }
    container.appendChild(animatedElement);
  } else if (style === 'ring' || style === 'multi-ring') {
    // Ring animations
    animatedElement = createEl('div', `pf-ring pf-ring--${style}`);
    animatedElement.style.position = 'relative';
    animatedElement.style.width = '60px';
    animatedElement.style.height = '60px';

    if (style === 'ring') {
      // Single progress ring
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('viewBox', '0 0 60 60');
      svg.style.width = '100%';
      svg.style.height = '100%';
      svg.style.transform = 'rotate(-90deg)';

      const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      bgCircle.setAttribute('cx', '30');
      bgCircle.setAttribute('cy', '30');
      bgCircle.setAttribute('r', '25');
      bgCircle.setAttribute('fill', 'none');
      bgCircle.setAttribute('stroke', 'rgba(236,195,255,0.2)');
      bgCircle.setAttribute('stroke-width', '4');

      const progressCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      progressCircle.setAttribute('cx', '30');
      progressCircle.setAttribute('cy', '30');
      progressCircle.setAttribute('r', '25');
      progressCircle.setAttribute('fill', 'none');
      progressCircle.setAttribute('stroke', '#c47ae5');
      progressCircle.setAttribute('stroke-width', '4');
      progressCircle.setAttribute('stroke-linecap', 'round');
      const circumference = 2 * Math.PI * 25;
      progressCircle.style.strokeDasharray = circumference;
      progressCircle.style.strokeDashoffset = circumference;
      progressCircle.classList.add('progress-ring');

      svg.appendChild(bgCircle);
      svg.appendChild(progressCircle);
      animatedElement.appendChild(svg);
    } else {
      // Multi ring
      for (let i = 0; i < 3; i += 1) {
        const ring = createEl('span', 'pf-ring__segment');
        ring.style.position = 'absolute';
        ring.style.width = `${40 + i * 10}px`;
        ring.style.height = `${40 + i * 10}px`;
        ring.style.border = '3px solid';
        ring.style.borderColor = i === 0 ? '#c47ae5' : i === 1 ? '#c6ff77' : '#47fff4';
        ring.style.borderRadius = '50%';
        ring.style.top = '50%';
        ring.style.left = '50%';
        ring.style.transform = 'translate(-50%, -50%)';
        ring.style.borderTopColor = 'transparent';
        ring.style.opacity = 0.8 - i * 0.2;
        animatedElement.appendChild(ring);
      }
    }
    container.appendChild(animatedElement);
  }

  const play = () => {
    if (!animatedElement) return;

    // For skeletons and CSS-based spinners, use the original CSS class-based animation system
    if (animatedElement.classList.contains('pf-skeleton')) {
      animatedElement.classList.remove('is-animating');
      void animatedElement.offsetWidth; // Force reflow
      animatedElement.classList.add('is-animating');
      animatedElement.querySelectorAll('.pf-skeleton__line, .pf-skeleton__tile').forEach((line, index) => {
        line.style.animationDelay = `${index * 0.08}s`;
      });
      return;
    }

    // For CSS-based spinners
    if (animatedElement.classList.contains('pf-spinner')) {
      animatedElement.classList.remove('is-animating');
      void animatedElement.offsetWidth; // Force reflow
      animatedElement.classList.add('is-animating');
      return;
    }

    // Clear any existing animations for other types
    if (animatedElement.getAnimations) {
      animatedElement.getAnimations().forEach(anim => anim.cancel());
    }

    if (style === 'rise') {
      // Dots rise animation
      dots.forEach((dot, i) => {
        playMotion(dot, {
          translateY: [0, -15, 0],
          opacity: [0.3, 1, 0.3]
        }, {
          duration: 1000,
          easing: easingCurves.gentle,
          delay: i * 150,
          iterations: Infinity
        });
      });
    } else if (style === 'wave') {
      // Dots wave animation
      dots.forEach((dot, i) => {
        playMotion(dot, {
          translateY: [0, -8, 0],
          scale: [0.8, 1.2, 0.8]
        }, {
          duration: 800,
          easing: 'cubic-bezier(0.4, 0, 0.6, 1)',
          delay: i * 100,
          iterations: Infinity
        });
      });
    } else if (style === 'portal') {
      // Dots portal animation - dots fold into center
      dots.forEach((dot, i) => {
        const offset = (i - 1) * 20; // -20, 0, 20
        playMotion(dot, [
          { transform: `translateX(${offset}px) scale(1)`, opacity: 1 },
          { transform: `translateX(0) scale(0.5)`, opacity: 0.5, offset: 0.5 },
          { transform: `translateX(${offset}px) scale(1)`, opacity: 1 }
        ], {
          duration: 1200,
          easing: easingCurves.standard,
          iterations: Infinity
        });
      });
    } else if (style === 'ring') {
      // Single ring progress animation
      const progressRing = animatedElement.querySelector('.progress-ring');
      if (progressRing) {
        const circumference = 2 * Math.PI * 25;
        playMotion(progressRing, {
          strokeDashoffset: [circumference, 0, circumference]
        }, {
          duration: 2000,
          easing: easingCurves.standard,
          iterations: Infinity
        });
      }
    } else if (style === 'multi-ring') {
      // Multi ring animation
      animatedElement.querySelectorAll('.pf-ring__segment').forEach((ring, i) => {
        playMotion(ring, [
          { transform: 'translate(-50%, -50%) rotate(0deg)' },
          { transform: 'translate(-50%, -50%) rotate(360deg)' }
        ], {
          duration: 1200 + i * 200,
          easing: 'linear',
          iterations: Infinity,
          direction: i % 2 === 0 ? 'normal' : 'reverse'
        });
      });
    } else if (style === 'dual-ring' || style === 'orbital' || style === 'galaxy') {
      // Spinner animations should use CSS animation
      animatedElement.classList.remove('is-animating');
      void animatedElement.offsetWidth; // Force reflow
      animatedElement.classList.add('is-animating');
      return;
    } else if (false) { // Disabled old rotate code
      playMotion(animatedElement, {
        rotate: [0, 360]
      }, {
        duration: style === 'galaxy' ? 2000 : 1000,
        easing: 'linear',
        iterations: Infinity
      });
    }
  };

  return { element: container, play };
};


factoryMap.progressDynamic = (entry) => {
  const container = createEl('div', 'pf-progress-dynamic');
  const style = entry.options.style;
  const duration = entry.options.duration || durations.lg;

  let play;

  if (style === 'number-pop') {
    // XP Number Pop - Premium floating numbers with sophisticated effects
    const xpContainer = createEl('div', 'pf-xp-pop');
    xpContainer.style.position = 'relative';
    xpContainer.style.height = '120px';
    xpContainer.style.display = 'flex';
    xpContainer.style.alignItems = 'center';
    xpContainer.style.justifyContent = 'center';
    xpContainer.style.overflow = 'hidden';

    // Background glow orb
    const glowOrb = createEl('div', '');
    glowOrb.style.position = 'absolute';
    glowOrb.style.width = '200px';
    glowOrb.style.height = '200px';
    glowOrb.style.background = 'radial-gradient(circle, rgba(198, 255, 119, 0.3) 0%, transparent 70%)';
    glowOrb.style.filter = 'blur(40px)';
    glowOrb.style.opacity = '0';
    xpContainer.appendChild(glowOrb);

    // Main number with multiple text shadows for depth
    const mainNumber = createEl('div', 'pf-xp-main');
    mainNumber.style.fontSize = '56px';
    mainNumber.style.fontWeight = '900';
    mainNumber.style.background = 'linear-gradient(135deg, #c6ff77, #a8ff3e)';
    mainNumber.style.webkitBackgroundClip = 'text';
    mainNumber.style.webkitTextFillColor = 'transparent';
    mainNumber.style.backgroundClip = 'text';
    mainNumber.style.textShadow = `
      0 0 30px rgba(198, 255, 119, 0.8),
      0 0 60px rgba(198, 255, 119, 0.5),
      0 2px 4px rgba(0, 0, 0, 0.3)
    `;
    mainNumber.style.letterSpacing = '2px';
    mainNumber.style.position = 'relative';
    mainNumber.style.zIndex = '2';
    mainNumber.textContent = '+0';

    // Add "XP" label
    const xpLabel = createEl('span', '');
    xpLabel.style.fontSize = '24px';
    xpLabel.style.marginLeft = '8px';
    xpLabel.style.fontWeight = '700';
    xpLabel.style.opacity = '0.8';
    xpLabel.textContent = 'XP';

    const numberWrapper = createEl('div', '');
    numberWrapper.style.display = 'flex';
    numberWrapper.style.alignItems = 'baseline';
    numberWrapper.appendChild(mainNumber);
    numberWrapper.appendChild(xpLabel);
    xpContainer.appendChild(numberWrapper);

    container.appendChild(xpContainer);

    play = () => {
      mainNumber.textContent = '+0';

      // Glow orb pulse
      playMotion(glowOrb, [
        { opacity: 0, transform: 'scale(0.5)' },
        { opacity: 1, transform: 'scale(1.2)', offset: 0.3 },
        { opacity: 0.3, transform: 'scale(1)' }
      ], { duration: duration * 1.2, easing: easingCurves.gentle });

      // Animate number counting with easing - slower for readability
      let startTime = null;
      const countDuration = 2500; // 2.5 seconds for counting animation
      const animateCount = (timestamp) => {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / countDuration, 1);
        const easedProgress = 1 - Math.pow(1 - progress, 3); // Cubic ease-out
        const value = Math.round(240 * easedProgress);
        mainNumber.textContent = '+' + value;
        if (progress < 1) requestAnimationFrame(animateCount);
      };
      requestAnimationFrame(animateCount);

      // Enhanced pop animation with blur
      playMotion(numberWrapper, [
        { transform: 'scale(0.3) translateY(20px)', opacity: 0, filter: 'blur(10px)' },
        { transform: 'scale(1.15) translateY(-5px)', opacity: 1, filter: 'blur(0px)', offset: 0.6 },
        { transform: 'scale(1) translateY(0)', opacity: 1, filter: 'blur(0px)' }
      ], { duration: duration * 0.8, easing: easingCurves.pop });

      // Create multiple layers of particles
      for (let layer = 0; layer < 2; layer++) {
        for (let i = 0; i < 5; i++) {
          const particle = createEl('div', '');
          particle.style.position = 'absolute';
          particle.style.fontSize = layer === 0 ? '18px' : '14px';
          particle.style.fontWeight = '700';
          particle.style.color = layer === 0 ? '#c6ff77' : '#a8ff3e';
          particle.style.textShadow = '0 0 10px currentColor';
          particle.textContent = '+' + Math.round(10 + Math.random() * 30);

          const angle = (i / 5) * Math.PI * 2;
          const radius = 60 + layer * 20;
          particle.style.left = '50%';
          particle.style.top = '50%';

          xpContainer.appendChild(particle);

          playMotion(particle, [
            {
              transform: 'translate(-50%, -50%) scale(0)',
              opacity: 0
            },
            {
              transform: `translate(calc(-50% + ${Math.cos(angle) * radius}px), calc(-50% + ${Math.sin(angle) * radius}px)) scale(1)`,
              opacity: 1,
              offset: 0.4
            },
            {
              transform: `translate(calc(-50% + ${Math.cos(angle) * radius * 1.5}px), calc(-50% + ${Math.sin(angle) * radius * 1.5 - 40}px)) scale(0.7)`,
              opacity: 0
            }
          ], {
            duration: duration * 1.3,
            delay: layer * 100 + i * 50,
            easing: easingCurves.gentle
          });

          setTimeout(() => particle.remove(), duration * 1.3 + layer * 100 + i * 50);
        }
      }

      // Add sparkle effects
      for (let i = 0; i < 8; i++) {
        const sparkle = createEl('div', '');
        sparkle.style.position = 'absolute';
        sparkle.style.width = '4px';
        sparkle.style.height = '4px';
        sparkle.style.background = '#fff';
        sparkle.style.borderRadius = '50%';
        sparkle.style.boxShadow = '0 0 6px #fff';
        sparkle.style.left = `${40 + Math.random() * 20}%`;
        sparkle.style.top = `${40 + Math.random() * 20}%`;
        xpContainer.appendChild(sparkle);

        playMotion(sparkle, [
          { opacity: 0, transform: 'scale(0)' },
          { opacity: 1, transform: 'scale(1)', offset: 0.5 },
          { opacity: 0, transform: 'scale(0)' }
        ], { duration: 600, delay: Math.random() * duration });

        setTimeout(() => sparkle.remove(), duration + 600);
      }
    };

  } else if (style === 'bar-flare') {
    // XP Bar Flare - Bar with glowing flare sweep
    const heading = createEl('div', 'pf-progress-dynamic__heading');
    const label = createEl('span', '', { text: 'Level Progress' });
    const value = createEl('strong', 'pf-progress-dynamic__value', { text: '0%' });
    heading.append(label, value);

    const track = createEl('div', 'pf-progress-track');
    track.style.overflow = 'hidden';
    const fill = createEl('div', 'pf-progress-fill');
    fill.style.background = 'linear-gradient(90deg, #c47ae5, #c6ff77)';

    const flare = createEl('div', 'pf-progress-flare');
    flare.style.position = 'absolute';
    flare.style.top = '0';
    flare.style.left = '0';
    flare.style.width = '100px';
    flare.style.height = '100%';
    flare.style.background = 'linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent)';
    flare.style.transform = 'translateX(-100px)';

    track.appendChild(fill);
    track.appendChild(flare);
    container.append(heading, track);

    play = () => {
      fill.style.transform = 'scaleX(0)';
      value.textContent = '0%';

      // Animate percentage counter synchronized with bar fill
      let startTime = null;
      const animatePercentage = (timestamp) => {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / duration, 1);
        const easedProgress = 1 - Math.pow(1 - progress, 3); // Cubic ease-out to match bar
        const percentage = Math.round(100 * easedProgress);
        value.textContent = percentage + '%';
        if (progress < 1) requestAnimationFrame(animatePercentage);
      };
      requestAnimationFrame(animatePercentage);

      // Animate bar fill
      playMotion(fill, [
        { transform: 'scaleX(0)' },
        { transform: 'scaleX(1)' }
      ], { duration, easing: easingCurves.entrance });

      // Animate flare sweep
      playMotion(flare, [
        { transform: 'translateX(-100px)' },
        { transform: 'translateX(400px)' }
      ], { duration: duration * 0.7, delay: duration * 0.3, easing: 'linear' });
    };

  } else if (style === 'breakthrough') {
    // Level Breakthrough - Explosive breakthrough with shake
    const levelDisplay = createEl('div', 'pf-level-breakthrough');
    levelDisplay.style.fontSize = '36px';
    levelDisplay.style.fontWeight = 'bold';
    levelDisplay.style.color = '#ffce1a';
    levelDisplay.style.textAlign = 'center';
    levelDisplay.style.padding = '20px';
    levelDisplay.textContent = 'LEVEL 1';

    const surgeLines = createEl('div', 'pf-surge-lines');
    surgeLines.style.position = 'absolute';
    surgeLines.style.inset = '0';
    surgeLines.style.background = 'radial-gradient(circle, transparent 30%, #ffce1a 31%, transparent 33%, transparent 40%, #ffce1a 41%, transparent 43%)';
    surgeLines.style.opacity = '0';

    container.style.position = 'relative';
    container.appendChild(surgeLines);
    container.appendChild(levelDisplay);

    play = () => {
      levelDisplay.textContent = 'LEVEL 1';

      // Shake and breakthrough effect
      playMotion(levelDisplay, [
        { transform: 'scale(1) rotate(0)' },
        { transform: 'scale(0.9) rotate(-2deg)', offset: 0.1 },
        { transform: 'scale(0.9) rotate(2deg)', offset: 0.2 },
        { transform: 'scale(0.9) rotate(-2deg)', offset: 0.3 },
        { transform: 'scale(1.5) rotate(0)', offset: 0.5 },
        { transform: 'scale(1) rotate(0)' }
      ], { duration, easing: easingCurves.vibrant });

      // Surge lines explosion
      playMotion(surgeLines, [
        { opacity: 0, transform: 'scale(0.5)' },
        { opacity: 1, transform: 'scale(1.5)', offset: 0.5 },
        { opacity: 0, transform: 'scale(2)' }
      ], { duration: duration * 0.7, delay: duration * 0.3 });

      // Change level text
      setTimeout(() => {
        levelDisplay.textContent = 'LEVEL 2';
        levelDisplay.style.textShadow = '0 0 30px rgba(255, 206, 26, 0.8)';
      }, duration * 0.5);
    };

  } else if (style === 'meter-spin') {
    // Level Meter Spin - Spinning meter needle
    const meterContainer = createEl('div', 'pf-meter');
    meterContainer.style.width = '120px';
    meterContainer.style.height = '80px';
    meterContainer.style.position = 'relative';
    meterContainer.style.margin = '0 auto';

    // Create meter arc
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('viewBox', '0 0 120 80');
    svg.style.width = '100%';
    svg.style.height = '100%';

    const arc = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    arc.setAttribute('d', 'M 10 70 A 50 50 0 0 1 110 70');
    arc.setAttribute('fill', 'none');
    arc.setAttribute('stroke', 'rgba(236, 195, 255, 0.3)');
    arc.setAttribute('stroke-width', '8');

    const needle = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    needle.setAttribute('x1', '60');
    needle.setAttribute('y1', '70');
    needle.setAttribute('x2', '60');
    needle.setAttribute('y2', '25');
    needle.setAttribute('stroke', '#c47ae5');
    needle.setAttribute('stroke-width', '3');
    needle.setAttribute('stroke-linecap', 'round');
    needle.style.transformOrigin = '60px 70px';

    svg.appendChild(arc);
    svg.appendChild(needle);
    meterContainer.appendChild(svg);

    const valueDisplay = createEl('div', '');
    valueDisplay.style.textAlign = 'center';
    valueDisplay.style.fontSize = '20px';
    valueDisplay.style.fontWeight = 'bold';
    valueDisplay.style.color = '#c47ae5';
    valueDisplay.textContent = '0';

    container.appendChild(meterContainer);
    container.appendChild(valueDisplay);

    play = () => {
      valueDisplay.textContent = '0';

      // Animate needle spinning with overshoot
      playMotion(needle, [
        { transform: 'rotate(-90deg)' },
        { transform: 'rotate(100deg)', offset: 0.8 },
        { transform: 'rotate(90deg)' }
      ], { duration, easing: easingCurves.snap });

      // Animate value counter synchronized with needle
      let startTime = null;
      const animateValue = (timestamp) => {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / duration, 1);
        const easedProgress = 1 - Math.pow(1 - progress, 3);
        const value = Math.round(100 * easedProgress);
        valueDisplay.textContent = value;
        if (progress < 1) requestAnimationFrame(animateValue);
      };
      requestAnimationFrame(animateValue);
    };

  } else if (style === 'banner-rise') {
    // Level Banner Rise - Banner sliding up with fanfare
    const banner = createEl('div', 'pf-level-banner');
    banner.style.background = 'linear-gradient(135deg, #ffce1a, #ff9a00)';
    banner.style.padding = '15px 30px';
    banner.style.borderRadius = '8px';
    banner.style.color = '#fff';
    banner.style.fontWeight = 'bold';
    banner.style.fontSize = '24px';
    banner.style.textAlign = 'center';
    banner.style.boxShadow = '0 4px 20px rgba(255, 206, 26, 0.4)';
    banner.textContent = 'LEVEL UP!';

    const stars = createEl('div', 'pf-banner-stars');
    stars.style.position = 'absolute';
    stars.style.inset = '0';
    stars.style.pointerEvents = 'none';

    container.style.position = 'relative';
    container.style.height = '100px';
    container.style.display = 'flex';
    container.style.alignItems = 'center';
    container.style.justifyContent = 'center';
    container.appendChild(banner);
    container.appendChild(stars);

    play = () => {
      // Banner rise animation
      playMotion(banner, [
        { transform: 'translateY(100px) scale(0.8)', opacity: 0 },
        { transform: 'translateY(-10px) scale(1.05)', opacity: 1, offset: 0.7 },
        { transform: 'translateY(0) scale(1)', opacity: 1 }
      ], { duration, easing: easingCurves.entrance });

      // Create star particles
      for (let i = 0; i < 5; i++) {
        const star = createEl('span', '');
        star.style.position = 'absolute';
        star.style.fontSize = '20px';
        star.textContent = '';
        star.style.left = `${20 + i * 15}%`;
        star.style.top = '50%';
        stars.appendChild(star);

        playMotion(star, [
          { transform: 'translateY(0) rotate(0) scale(0)', opacity: 0 },
          { transform: 'translateY(-30px) rotate(180deg) scale(1)', opacity: 1, offset: 0.5 },
          { transform: 'translateY(-50px) rotate(360deg) scale(0.5)', opacity: 0 }
        ], { duration: duration * 1.2, delay: i * 50 });

        setTimeout(() => star.remove(), duration * 1.2 + i * 50);
      }
    };

  } else if (style === 'ring-fill') {
    // Achievement Ring - Circular progress ring
    const ringContainer = createEl('div', 'pf-achievement-ring');
    ringContainer.style.width = '100px';
    ringContainer.style.height = '100px';
    ringContainer.style.margin = '0 auto';

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('viewBox', '0 0 100 100');
    svg.style.width = '100%';
    svg.style.height = '100%';
    svg.style.transform = 'rotate(-90deg)';

    const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    bgCircle.setAttribute('cx', '50');
    bgCircle.setAttribute('cy', '50');
    bgCircle.setAttribute('r', '40');
    bgCircle.setAttribute('fill', 'none');
    bgCircle.setAttribute('stroke', 'rgba(236, 195, 255, 0.2)');
    bgCircle.setAttribute('stroke-width', '8');

    const progressRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    progressRing.setAttribute('cx', '50');
    progressRing.setAttribute('cy', '50');
    progressRing.setAttribute('r', '40');
    progressRing.setAttribute('fill', 'none');
    progressRing.setAttribute('stroke', 'url(#ring-gradient)');
    progressRing.setAttribute('stroke-width', '8');
    progressRing.setAttribute('stroke-linecap', 'round');
    const circumference = 2 * Math.PI * 40;
    progressRing.style.strokeDasharray = circumference;
    progressRing.style.strokeDashoffset = circumference;

    // Add gradient
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
    gradient.setAttribute('id', 'ring-gradient');
    const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop1.setAttribute('offset', '0%');
    stop1.setAttribute('stop-color', '#c47ae5');
    const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop2.setAttribute('offset', '100%');
    stop2.setAttribute('stop-color', '#ecc3ff');
    gradient.appendChild(stop1);
    gradient.appendChild(stop2);
    defs.appendChild(gradient);

    svg.appendChild(defs);
    svg.appendChild(bgCircle);
    svg.appendChild(progressRing);
    ringContainer.appendChild(svg);

    const achievementText = createEl('div', '');
    achievementText.style.textAlign = 'center';
    achievementText.style.marginTop = '10px';
    achievementText.style.fontSize = '18px';
    achievementText.style.fontWeight = 'bold';
    achievementText.style.color = '#ecc3ff';
    achievementText.textContent = 'ACHIEVEMENT!';
    achievementText.style.opacity = '0';

    container.appendChild(ringContainer);
    container.appendChild(achievementText);

    play = () => {
      // Animate ring fill
      playMotion(progressRing, [
        { strokeDashoffset: circumference },
        { strokeDashoffset: 0 }
      ], { duration, easing: easingCurves.entrance });

      // Show achievement text
      playMotion(achievementText, [
        { opacity: 0, transform: 'scale(0.8)' },
        { opacity: 1, transform: 'scale(1)' }
      ], { duration: duration * 0.3, delay: duration * 0.7 });
    };

  } else if (style === 'card-slide') {
    // Achievement Card - Card sliding in with flip
    const card = createEl('div', 'pf-achievement-card');
    card.style.width = '200px';
    card.style.height = '120px';
    card.style.background = 'linear-gradient(135deg, #c47ae5, #ecc3ff)';
    card.style.borderRadius = '12px';
    card.style.padding = '20px';
    card.style.color = '#fff';
    card.style.boxShadow = '0 8px 32px rgba(196, 122, 229, 0.3)';
    card.style.display = 'flex';
    card.style.flexDirection = 'column';
    card.style.alignItems = 'center';
    card.style.justifyContent = 'center';
    card.style.perspective = '1000px';

    const icon = createEl('div', '');
    icon.style.fontSize = '36px';
    icon.textContent = '';

    const title = createEl('div', '');
    title.style.fontSize = '18px';
    title.style.fontWeight = 'bold';
    title.style.marginTop = '10px';
    title.textContent = 'First Victory!';

    card.appendChild(icon);
    card.appendChild(title);
    container.appendChild(card);

    play = () => {
      // Card slide and flip animation
      playMotion(card, [
        { transform: 'translateX(-300px) rotateY(-90deg)', opacity: 0 },
        { transform: 'translateX(20px) rotateY(10deg)', opacity: 1, offset: 0.7 },
        { transform: 'translateX(0) rotateY(0)', opacity: 1 }
      ], { duration, easing: easingCurves.entrance });

      // Icon bounce
      playMotion(icon, [
        { transform: 'scale(0)' },
        { transform: 'scale(1.3)', offset: 0.7 },
        { transform: 'scale(1)' }
      ], { duration: duration * 0.8, delay: duration * 0.2 });
    };

  } else if (style === 'quest-chain') {
    // Quest Chain - Chain of nodes lighting up
    const chainContainer = createEl('div', 'pf-quest-chain');
    chainContainer.style.display = 'flex';
    chainContainer.style.gap = '20px';
    chainContainer.style.alignItems = 'center';
    chainContainer.style.padding = '20px';

    const nodes = [];
    for (let i = 0; i < 5; i++) {
      const nodeWrapper = createEl('div', '');
      nodeWrapper.style.position = 'relative';

      const node = createEl('div', 'pf-chain-node');
      node.style.width = '40px';
      node.style.height = '40px';
      node.style.borderRadius = '50%';
      node.style.background = 'rgba(71, 255, 244, 0.2)';
      node.style.border = '2px solid #47fff4';
      node.style.display = 'flex';
      node.style.alignItems = 'center';
      node.style.justifyContent = 'center';
      node.style.fontSize = '16px';
      node.style.fontWeight = 'bold';
      node.style.color = '#47fff4';
      node.textContent = i + 1;

      if (i < 4) {
        const connector = createEl('div', 'pf-chain-connector');
        connector.style.position = 'absolute';
        connector.style.left = '40px';
        connector.style.top = '50%';
        connector.style.width = '20px';
        connector.style.height = '2px';
        connector.style.background = 'rgba(71, 255, 244, 0.3)';
        connector.style.transform = 'translateY(-50%)';
        nodeWrapper.appendChild(connector);
      }

      nodeWrapper.appendChild(node);
      nodes.push({ wrapper: nodeWrapper, node, connector: i < 4 ? nodeWrapper.querySelector('.pf-chain-connector') : null });
      chainContainer.appendChild(nodeWrapper);
    }

    container.appendChild(chainContainer);

    play = () => {
      // Reset all nodes
      nodes.forEach(({ node, connector }) => {
        node.style.background = 'rgba(71, 255, 244, 0.2)';
        node.style.transform = 'scale(1)';
        if (connector) {
          connector.style.background = 'rgba(71, 255, 244, 0.3)';
          connector.style.transform = 'translateY(-50%) scaleX(1)';
        }
      });

      // Animate each node in sequence
      nodes.forEach(({ node, connector }, i) => {
        playMotion(node, [
          { background: 'rgba(71, 255, 244, 0.2)', transform: 'scale(1)', boxShadow: 'none' },
          { background: 'rgba(71, 255, 244, 0.8)', transform: 'scale(1.2)', boxShadow: '0 0 20px rgba(71, 255, 244, 0.8)', offset: 0.5 },
          { background: '#47fff4', transform: 'scale(1)', boxShadow: '0 0 10px rgba(71, 255, 244, 0.6)' }
        ], { duration: 300, delay: i * 200, fill: 'forwards' });

        if (connector) {
          playMotion(connector, [
            { background: 'rgba(71, 255, 244, 0.3)', transform: 'translateY(-50%) scaleX(0)' },
            { background: '#47fff4', transform: 'translateY(-50%) scaleX(1)' }
          ], { duration: 200, delay: i * 200 + 150, fill: 'forwards' });
        }
      });
    };

  } else {
    // Default fallback
    const heading = createEl('div', 'pf-progress-dynamic__heading');
    const label = createEl('span', '', { text: 'Progress' });
    const value = createEl('strong', 'pf-progress-dynamic__value', { text: '0' });
    heading.append(label, value);

    const track = createEl('div', 'pf-progress-track');
    const fill = createEl('div', 'pf-progress-fill');
    track.appendChild(fill);
    container.append(heading, track);

    play = () => {
      fill.style.transform = 'scaleX(0)';
      value.textContent = '0';
      // Animate counter
      let startTime = null;
      const animateCounter = (timestamp) => {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / duration, 1);
        const easedProgress = 1 - Math.pow(1 - progress, 3);
        const val = Math.round(100 * easedProgress);
        value.textContent = val;
        if (progress < 1) requestAnimationFrame(animateCounter);
      };
      requestAnimationFrame(animateCounter);
      playWAAPI(fill, [{ transform: 'scaleX(0)' }, { transform: 'scaleX(1)' }], { duration, fill: 'forwards', easing: easingCurves.entrance });
    };
  }

  return { element: container, play };
};


const progressMilestoneConfigs = {
  'quest-burst': {
    badgeText: 'Quest Complete',
    accent: '#47fff4',
    icon: '',
    caption: 'Mission reward unlocked.',
    buildEffects(layer, { accent, reduced }) {
      const sparks = 12;
      for (let i = 0; i < sparks; i += 1) {
        const spark = createEl('span', 'pf-milestone__spark');
        spark.style.background = accent;
        spark.style.left = '50%';
        spark.style.top = '50%';
        layer.appendChild(spark);
        const angle = (Math.PI * 2 * i) / sparks;
        const distance = 70;
        const tx = Math.cos(angle) * distance;
        const ty = Math.sin(angle) * distance;
        if (reduced) {
          spark.style.opacity = '0.55';
          spark.style.transform = `translate(-50%, -50%) translate(${tx}px, ${ty}px) scale(0.8)`;
        } else {
          playMotion(spark, [
            { transform: 'translate(-50%, -50%) scale(0.2)', opacity: 0 },
            { transform: `translate(-50%, -50%) translate(${tx}px, ${ty}px) scale(1)`, opacity: 1, offset: 0.65 },
            { transform: `translate(-50%, -50%) translate(${tx * 1.25}px, ${ty * 1.25}px) scale(0.3)`, opacity: 0 }
          ], { duration: 0.8, delay: i * 0.05, easing: easingCurves.vibrant });
        }
      }
      for (let i = 0; i < 6; i += 1) {
        const star = createEl('span', 'pf-milestone__star');
        star.style.background = accent;
        star.style.left = '50%';
        star.style.top = '50%';
        layer.appendChild(star);
        const angle = (Math.PI * 2 * i) / 6 + 0.3;
        const radius = 46 + i * 4;
        const tx = Math.cos(angle) * radius;
        const ty = Math.sin(angle) * radius;
        if (reduced) {
          star.style.opacity = '0.6';
          star.style.transform = `translate(-50%, -50%) translate(${tx}px, ${ty}px)`;
        } else {
          playMotion(star, [
            { transform: 'translate(-50%, -50%) scale(0.4)', opacity: 0 },
            { transform: `translate(-50%, -50%) translate(${tx}px, ${ty}px) scale(1)`, opacity: 1, offset: 0.6 },
            { transform: `translate(-50%, -50%) translate(${tx}px, ${ty}px) scale(0.4)`, opacity: 0 }
          ], { duration: 1.1, delay: 0.2 + i * 0.08, easing: easingCurves.gentle });
        }
      }
    },
    animate({ glow, badge, iconEl, headline, caption }) {
      playMotion(glow, { opacity: [0, 0.8, 0], scale: [0.6, 1.4, 1.9] }, { duration: 1.2, easing: easingCurves.vibrant });
      playMotion(badge, { translateY: [-14, 0], scale: [0.9, 1] }, { duration: 0.6, easing: easingCurves.entrance });
      if (iconEl) {
        playMotion(iconEl, { scale: [0.6, 1.18, 1], rotate: [-6, 0, 4, 0] }, { duration: 0.7, easing: easingCurves.pop });
      }
      playMotion(headline, { opacity: [0, 1], translateY: [6, 0] }, { duration: 0.6, easing: easingCurves.standard, delay: 0.1 });
      if (caption) {
        playMotion(caption, { opacity: [0, 1], translateY: [10, 0] }, { duration: 0.6, easing: easingCurves.gentle, delay: 0.2 });
      }
    }
  },
  'loyalty-tier': {
    badgeText: 'Loyalty Tier',
    accent: '#c6ff77',
    icon: '',
    caption: 'Tier bonus multiplier active.',
    buildEffects(layer, { accent, reduced }) {
      for (let r = 0; r < 3; r += 1) {
        const ring = createEl('span', 'pf-milestone__ring');
        ring.style.left = '50%';
        ring.style.top = '50%';
        const size = 160 + r * 40;
        ring.style.width = `${size}px`;
        ring.style.height = `${size}px`;
        ring.style.border = `2px dashed ${hexToRgba(accent, 0.45)}`;
        layer.appendChild(ring);
        if (reduced) {
          ring.style.opacity = '0.45';
          ring.style.transform = 'translate(-50%, -50%)';
        } else {
          playMotion(ring, [
            { opacity: 0, transform: 'translate(-50%, -50%) scale(0.75)' },
            { opacity: 0.6, transform: 'translate(-50%, -50%) scale(1)', offset: 0.6 },
            { opacity: 0, transform: 'translate(-50%, -50%) scale(1.25)' }
          ], { duration: 1.6, delay: r * 0.18, easing: easingCurves.gentle });
        }
      }
      for (let i = 0; i < 4; i += 1) {
        const star = createEl('span', 'pf-milestone__star');
        star.style.background = hexToRgba(accent, 0.9);
        star.style.left = '50%';
        star.style.top = '35%';
        layer.appendChild(star);
        const angle = (Math.PI * 2 * i) / 4;
        const radius = 80;
        const tx = Math.cos(angle) * radius;
        const ty = Math.sin(angle) * 28;
        if (reduced) {
          star.style.opacity = '0.7';
          star.style.transform = `translate(-50%, -50%) translate(${tx}px, ${ty}px)`;
        } else {
          playMotion(star, [
            { opacity: 0, transform: 'translate(-50%, -50%) scale(0.5)' },
            { opacity: 1, transform: `translate(-50%, -50%) translate(${tx}px, ${ty}px) scale(1)`, offset: 0.6 },
            { opacity: 0, transform: `translate(-50%, -50%) translate(${tx}px, ${ty}px) scale(0.5)` }
          ], { duration: 1.4, delay: 0.25 + i * 0.12, easing: easingCurves.gentle });
        }
      }
    },
    animate({ glow, badge, iconEl, headline, caption }) {
      playMotion(glow, { opacity: [0, 0.85, 0], scale: [0.7, 1.3, 1.8] }, { duration: 1.4, easing: easingCurves.gentle });
      playMotion(badge, { rotate: [0, 6, -4, 0], scale: [0.9, 1.1, 1] }, { duration: 0.9, easing: easingCurves.vibrant });
      if (iconEl) {
        playMotion(iconEl, { translateY: [6, -6, 0], rotate: [0, -8, 0] }, { duration: 1.2, easing: easingCurves.gentle });
      }
      playMotion(headline, { letterSpacing: ['0.12em', '0.3em', '0.14em'] }, { duration: 1.2, easing: easingCurves.gentle });
      if (caption) {
        playMotion(caption, { opacity: [0, 1], translateY: [8, 0] }, { duration: 0.7, easing: easingCurves.standard, delay: 0.2 });
      }
    }
  },
  'level-breakthrough-flare': {
    badgeText: 'Level Up',
    accent: '#ffce1a',
    icon: '',
    caption: 'Power boost unlocked.',
    buildEffects(layer, { accent, reduced }) {
      const angles = [-32, -10, 10, 32];
      angles.forEach((deg, index) => {
        const beam = createEl('span', 'pf-milestone__beam');
        beam.style.left = '50%';
        beam.style.top = '65%';
        beam.style.background = `linear-gradient(180deg, ${hexToRgba(accent, 0.75)}, rgba(255, 206, 26, 0))`;
        beam.style.transform = `translate(-50%, -100%) rotate(${deg}deg) scaleY(${reduced ? 1 : 0.2})`;
        beam.style.opacity = reduced ? '0.55' : '0';
        layer.appendChild(beam);
        if (!reduced) {
          playMotion(beam, [
            { opacity: 0, transform: `translate(-50%, -100%) rotate(${deg}deg) scaleY(0.1)` },
            { opacity: 0.85, transform: `translate(-50%, -100%) rotate(${deg}deg) scaleY(1)`, offset: 0.55 },
            { opacity: 0, transform: `translate(-50%, -100%) rotate(${deg}deg) scaleY(0.4)` }
          ], { duration: 1.1, delay: index * 0.12, easing: easingCurves.vibrant });
        }
      });
      for (let i = 0; i < 6; i += 1) {
        const spark = createEl('span', 'pf-milestone__spark');
        spark.style.background = '#ffd966';
        spark.style.left = '50%';
        spark.style.top = '42%';
        layer.appendChild(spark);
        const angle = (Math.PI * 2 * i) / 6;
        const tx = Math.cos(angle) * 48;
        const ty = Math.sin(angle) * 32;
        if (reduced) {
          spark.style.opacity = '0.5';
          spark.style.transform = `translate(-50%, -50%) translate(${tx}px, ${ty}px)`;
        } else {
          playMotion(spark, [
            { opacity: 0, transform: 'translate(-50%, -50%) scale(0.3)' },
            { opacity: 1, transform: `translate(-50%, -50%) translate(${tx}px, ${ty}px) scale(1)`, offset: 0.6 },
            { opacity: 0, transform: `translate(-50%, -50%) translate(${tx * 1.2}px, ${ty * 1.2}px) scale(0.4)` }
          ], { duration: 0.9, delay: 0.2 + i * 0.08, easing: easingCurves.pop });
        }
      }
    },
    animate({ glow, badge, iconEl, headline, caption }) {
      playMotion(glow, { opacity: [0, 1, 0], scale: [0.8, 1.7, 2.2] }, { duration: 1.1, easing: easingCurves.vibrant });
      playMotion(badge, { translateY: [10, 0], scale: [1.2, 1], filter: ['brightness(1)', 'brightness(1.2)', 'brightness(1)'] }, { duration: 0.6, easing: easingCurves.snap });
      if (iconEl) {
        playMotion(iconEl, { translateY: [16, -6, 0], scale: [0.8, 1.1, 1] }, { duration: 0.7, easing: easingCurves.vibrant });
      }
      playMotion(headline, { scale: [0.92, 1.06, 1], color: ['var(--pf-base-60)', '#ffce1a', 'var(--pf-base-60)'] }, { duration: 0.9, easing: easingCurves.standard });
      if (caption) {
        playMotion(caption, { opacity: [0, 1], translateY: [12, 0] }, { duration: 0.6, easing: easingCurves.entrance, delay: 0.2 });
      }
    }
  },
  'achievement-burst': {
    badgeText: 'Achievement',
    accent: '#ecc3ff',
    icon: '',
    caption: 'New badge added to your profile.',
    buildEffects(layer, { accent, reduced }) {
      const count = 10;
      for (let i = 0; i < count; i += 1) {
        const star = createEl('span', 'pf-milestone__star');
        star.style.background = accent;
        star.style.left = '50%';
        star.style.top = '50%';
        layer.appendChild(star);
        const angle = (Math.PI * 2 * i) / count;
        const radius = 60 + randBetween(-10, 18);
        const tx = Math.cos(angle) * radius;
        const ty = Math.sin(angle) * radius;
        if (reduced) {
          star.style.opacity = '0.7';
          star.style.transform = `translate(-50%, -50%) translate(${tx}px, ${ty}px)`;
        } else {
          playMotion(star, [
            { opacity: 0, transform: 'translate(-50%, -50%) scale(0.4)' },
            { opacity: 1, transform: `translate(-50%, -50%) translate(${tx}px, ${ty}px) scale(1)`, offset: 0.55 },
            { opacity: 0, transform: `translate(-50%, -50%) translate(${tx * 1.15}px, ${ty * 1.15}px) scale(0.4)` }
          ], { duration: 1, delay: i * 0.06, easing: easingCurves.pop });
        }
      }
    },
    animate({ glow, badge, iconEl, headline, caption }) {
      playMotion(glow, { opacity: [0, 0.7, 0], scale: [0.6, 1.4, 1.8] }, { duration: 1.1, easing: easingCurves.standard });
      playMotion(badge, { rotate: [0, -8, 8, 0], scale: [1, 1.12, 1] }, { duration: 0.8, easing: easingCurves.standard });
      if (iconEl) {
        playMotion(iconEl, { scale: [0.6, 1.2, 1], rotate: [0, 12, -6, 0] }, { duration: 0.8, easing: easingCurves.pop });
      }
      playMotion(headline, { opacity: [0, 1], translateY: [12, 0] }, { duration: 0.7, easing: easingCurves.entrance });
      if (caption) {
        playMotion(caption, { opacity: [0, 1], translateY: [8, 0] }, { duration: 0.6, easing: easingCurves.gentle, delay: 0.1 });
      }
    }
  },
  'milestone-banner': {
    badgeText: 'Milestone',
    accent: '#47fff4',
    icon: '',
    caption: 'Community spotlight achieved.',
    buildEffects(layer, { accent, reduced }) {
      const left = createEl('span', 'pf-milestone__ribbon pf-milestone__ribbon--left');
      left.style.left = '12%';
      left.style.top = '62%';
      left.style.background = `linear-gradient(135deg, ${hexToRgba(accent, 0.48)}, ${hexToRgba(accent, 0.12)})`;
      layer.appendChild(left);
      const right = createEl('span', 'pf-milestone__ribbon pf-milestone__ribbon--right');
      right.style.right = '12%';
      right.style.top = '62%';
      right.style.background = `linear-gradient(135deg, ${hexToRgba(accent, 0.48)}, ${hexToRgba(accent, 0.12)})`;
      layer.appendChild(right);
      if (reduced) {
        left.style.opacity = '0.6';
        left.style.transform = 'translateY(0)';
        right.style.opacity = '0.6';
        right.style.transform = 'translateY(0)';
      } else {
        playMotion(left, [
          { opacity: 0, transform: 'translateX(-80px) rotate(-6deg)' },
          { opacity: 1, transform: 'translateX(0) rotate(0deg)' }
        ], { duration: 0.6, easing: easingCurves.entrance });
        playMotion(right, [
          { opacity: 0, transform: 'translateX(80px) rotate(6deg)' },
          { opacity: 1, transform: 'translateX(0) rotate(0deg)' }
        ], { duration: 0.6, easing: easingCurves.entrance });
      }
      const confettiColors = [accent, '#ecc3ff', '#c83558', '#ffce1a'];
      for (let i = 0; i < 10; i += 1) {
        const confetti = createEl('span', 'pf-milestone__confetti');
        confetti.style.background = confettiColors[i % confettiColors.length];
        confetti.style.left = '50%';
        confetti.style.top = '30%';
        layer.appendChild(confetti);
        const angle = randBetween(-Math.PI / 2, Math.PI / 2);
        const distance = 90 + randBetween(-20, 40);
        const tx = Math.cos(angle) * distance;
        const ty = Math.sin(angle) * distance;
        if (reduced) {
          confetti.style.opacity = '0.7';
          confetti.style.transform = `translate(-50%, -50%) translate(${tx}px, ${ty}px) rotate(${randBetween(-40, 40)}deg)`;
        } else {
          const rotate = randBetween(-30, 30);
          const rotateExit = randBetween(-60, 60);
          playMotion(confetti, [
            { opacity: 0, transform: 'translate(-50%, -50%) rotate(0deg) scale(0.4)' },
            { opacity: 1, transform: `translate(-50%, -50%) translate(${tx}px, ${ty}px) rotate(${rotate}deg)`, offset: 0.6 },
            { opacity: 0, transform: `translate(-50%, -50%) translate(${tx}px, ${ty + 40}px) rotate(${rotateExit}deg)` }
          ], { duration: 1.1, delay: i * 0.06, easing: easingCurves.gentle });
        }
      }
    },
    animate({ glow, badge, iconEl, headline, caption }) {
      playMotion(glow, { opacity: [0.2, 0.6, 0.2], scale: [1, 1.08, 1] }, { duration: 1.5, easing: easingCurves.gentle });
      playMotion(badge, { translateY: [-40, 0], opacity: [0, 1] }, { duration: 0.6, easing: easingCurves.entrance });
      if (iconEl) {
        playMotion(iconEl, { scale: [0.7, 1.2, 1], rotate: [0, -8, 6, 0] }, { duration: 0.7, easing: easingCurves.pop });
      }
      playMotion(headline, { letterSpacing: ['0.08em', '0.22em', '0.12em'] }, { duration: 1.1, easing: easingCurves.gentle });
      if (caption) {
        playMotion(caption, { opacity: [0, 1], translateY: [12, 0] }, { duration: 0.6, easing: easingCurves.gentle, delay: 0.15 });
      }
    }
  },
  'tier-up-lights': {
    badgeText: 'Tier Lights',
    accent: '#c6ff77',
    icon: '',
    caption: 'Streak bonus amplified.',
    buildEffects(layer, { reduced }) {
      const offsets = [-70, -25, 25, 70];
      offsets.forEach((offset, index) => {
        const light = createEl('span', 'pf-milestone__light');
        light.style.left = `calc(50% + ${offset}px)`;
        layer.appendChild(light);
        if (reduced) {
          light.style.opacity = '0.65';
          light.style.transform = 'translate(-50%, -20px) scaleY(1)';
        } else {
          playMotion(light, [
            { opacity: 0, transform: 'translate(-50%, 50px) scaleY(0.2)' },
            { opacity: 0.9, transform: 'translate(-50%, 0) scaleY(1)', offset: 0.55 },
            { opacity: 0, transform: 'translate(-50%, -40px) scaleY(0.6)' }
          ], { duration: 1.2, delay: index * 0.15, easing: easingCurves.entrance });
        }
      });
    },
    animate({ glow, badge, iconEl, headline, caption }) {
      playMotion(glow, { opacity: [0, 0.9, 0], scale: [0.7, 1.5, 2] }, { duration: 1.3, easing: easingCurves.gentle });
      playMotion(badge, { boxShadow: ['0 0 0 rgba(198,255,119,0)', '0 0 24px rgba(198,255,119,0.5)', '0 0 0 rgba(198,255,119,0)'] }, { duration: 1, easing: easingCurves.standard });
      if (iconEl) {
        playMotion(iconEl, { translateY: [12, -6, 0], scale: [0.9, 1.1, 1] }, { duration: 0.8, easing: easingCurves.pop });
      }
      playMotion(headline, { opacity: [0, 1], translateY: [10, 0] }, { duration: 0.7, easing: easingCurves.entrance, delay: 0.1 });
      if (caption) {
        playMotion(caption, { opacity: [0, 1], translateY: [6, 0] }, { duration: 0.6, easing: easingCurves.gentle, delay: 0.2 });
      }
    }
  },
  'badge-glow': {
    badgeText: 'Badge Glow',
    accent: '#ecc3ff',
    icon: '',
    caption: 'Badge prestige increased.',
    buildEffects(layer, { accent, reduced }) {
      for (let i = 0; i < 2; i += 1) {
        const halo = createEl('span', 'pf-milestone__halo');
        halo.style.left = '50%';
        halo.style.top = '50%';
        const size = 200 + i * 60;
        halo.style.width = `${size}px`;
        halo.style.height = `${size}px`;
        halo.style.border = `2px solid ${hexToRgba(accent, 0.35)}`;
        layer.appendChild(halo);
        if (reduced) {
          halo.style.opacity = '0.5';
          halo.style.transform = 'translate(-50%, -50%)';
        } else {
          playMotion(halo, [
            { opacity: 0, transform: 'translate(-50%, -50%) scale(0.7)' },
            { opacity: 0.45, transform: 'translate(-50%, -50%) scale(1)', offset: 0.6 },
            { opacity: 0, transform: 'translate(-50%, -50%) scale(1.2)' }
          ], { duration: 1.4, delay: i * 0.2, easing: easingCurves.gentle });
        }
      }
      for (let i = 0; i < 6; i += 1) {
        const spark = createEl('span', 'pf-milestone__spark');
        spark.style.background = hexToRgba(accent, 0.8);
        spark.style.left = '50%';
        spark.style.top = '50%';
        layer.appendChild(spark);
        const angle = (Math.PI * 2 * i) / 6;
        const radius = 60;
        const tx = Math.cos(angle) * radius;
        const ty = Math.sin(angle) * radius;
        if (reduced) {
          spark.style.opacity = '0.6';
          spark.style.transform = `translate(-50%, -50%) translate(${tx}px, ${ty}px)`;
        } else {
          playMotion(spark, [
            { opacity: 0, transform: 'translate(-50%, -50%) scale(0.4)' },
            { opacity: 1, transform: `translate(-50%, -50%) translate(${tx}px, ${ty}px) scale(1)`, offset: 0.6 },
            { opacity: 0, transform: `translate(-50%, -50%) translate(${tx}px, ${ty}px) scale(0.4)` }
          ], { duration: 1.1, delay: 0.2 + i * 0.1, easing: easingCurves.gentle });
        }
      }
    },
    animate({ glow, badge, iconEl, headline, caption }) {
      playMotion(glow, { opacity: [0, 0.8, 0.2], scale: [0.5, 1.35, 1.7] }, { duration: 1.2, easing: easingCurves.gentle });
      playMotion(badge, { scale: [0.95, 1.12, 1], filter: ['brightness(1)', 'brightness(1.25)', 'brightness(1)'] }, { duration: 0.8, easing: easingCurves.standard });
      if (iconEl) {
        playMotion(iconEl, { scale: [0.9, 1.18, 1], rotate: [0, 8, -6, 0] }, { duration: 0.8, easing: easingCurves.pop });
      }
      playMotion(headline, { opacity: [0, 1], scale: [0.93, 1] }, { duration: 0.7, easing: easingCurves.entrance });
      if (caption) {
        playMotion(caption, { opacity: [0, 1], translateY: [10, 0] }, { duration: 0.6, easing: easingCurves.gentle, delay: 0.1 });
      }
    }
  },
  'progress-fireworks': {
    badgeText: 'Grand Win',
    accent: '#ff5981',
    icon: '',
    caption: 'Jackpot fireworks triggered.',
    buildEffects(layer, { reduced }) {
      const colors = ['#ff5981', '#ffce1a', '#47fff4', '#c6ff77'];
      const count = 18;
      for (let i = 0; i < count; i += 1) {
        const confetti = createEl('span', 'pf-milestone__confetti');
        confetti.style.background = colors[i % colors.length];
        confetti.style.left = '50%';
        confetti.style.top = '45%';
        layer.appendChild(confetti);
        const angle = (Math.PI * 2 * i) / count;
        const distance = 90 + randBetween(-20, 30);
        const tx = Math.cos(angle) * distance;
        const ty = Math.sin(angle) * distance;
        const rotate = randBetween(-120, 120);
        const rotateExit = rotate * 1.2;
        if (reduced) {
          confetti.style.opacity = '0.75';
          confetti.style.transform = `translate(-50%, -50%) translate(${tx}px, ${ty}px) rotate(${rotate}deg)`;
        } else {
          playMotion(confetti, [
            { opacity: 0, transform: 'translate(-50%, -50%) rotate(0deg) scale(0.5)' },
            { opacity: 1, transform: `translate(-50%, -50%) translate(${tx}px, ${ty}px) rotate(${rotate}deg)`, offset: 0.55 },
            { opacity: 0, transform: `translate(-50%, -50%) translate(${tx * 1.15}px, ${ty * 1.15}px) rotate(${rotateExit}deg)` }
          ], { duration: 1.2, delay: i * 0.04, easing: easingCurves.vibrant });
        }
      }
      for (let i = 0; i < 6; i += 1) {
        const spark = createEl('span', 'pf-milestone__spark');
        spark.style.background = '#ffd966';
        spark.style.left = '50%';
        spark.style.top = '40%';
        layer.appendChild(spark);
        const angle = randBetween(0, Math.PI * 2);
        const tx = Math.cos(angle) * 60;
        const ty = Math.sin(angle) * 60;
        if (reduced) {
          spark.style.opacity = '0.6';
          spark.style.transform = `translate(-50%, -50%) translate(${tx}px, ${ty}px)`;
        } else {
          playMotion(spark, [
            { opacity: 0, transform: 'translate(-50%, -50%) scale(0.4)' },
            { opacity: 1, transform: `translate(-50%, -50%) translate(${tx}px, ${ty}px) scale(1)`, offset: 0.55 },
            { opacity: 0, transform: `translate(-50%, -50%) translate(${tx}px, ${ty}px) scale(0.4)` }
          ], { duration: 0.9, delay: 0.3 + i * 0.08, easing: easingCurves.pop });
        }
      }
    },
    animate({ glow, badge, iconEl, headline, caption }) {
      playMotion(glow, { opacity: [0, 1, 0], scale: [0.8, 1.9, 2.4] }, { duration: 1.2, easing: easingCurves.vibrant });
      playMotion(badge, { translateY: [-18, 0], scale: [1.1, 1] }, { duration: 0.6, easing: easingCurves.snap });
      if (iconEl) {
        playMotion(iconEl, { scale: [0.7, 1.25, 1], rotate: [0, -16, 8, 0] }, { duration: 0.7, easing: easingCurves.vibrant });
      }
      playMotion(headline, { opacity: [0, 1], translateY: [10, 0] }, { duration: 0.7, easing: easingCurves.standard });
      if (caption) {
        playMotion(caption, { opacity: [0, 1], translateY: [12, 0] }, { duration: 0.6, easing: easingCurves.gentle, delay: 0.2 });
      }
    }
  }
};

factoryMap.progressMilestone = (entry) => {
  const style = entry.options.style;
  const config = progressMilestoneConfigs[style] || progressMilestoneConfigs['quest-burst'];
  const accent = config.accent || '#c6ff77';
  const container = createEl('div', 'pf-milestone');
  container.style.setProperty('--pf-milestone-accent', accent);

  const visuals = createEl('div', 'pf-milestone__visuals');
  const glow = createEl('div', 'pf-milestone__glow');
  glow.style.background = `radial-gradient(circle, ${hexToRgba(accent, 0.55)}, rgba(236, 195, 255, 0))`;
  const effects = createEl('div', 'pf-milestone__effects');
  const content = createEl('div', 'pf-milestone__content');
  const badge = createEl('div', 'pf-milestone__badge', { text: config.badgeText });
  const iconEl = config.icon ? createEl('div', 'pf-milestone__icon', { text: config.icon }) : null;
  const headline = createEl('div', 'pf-milestone__headline', { text: formatTitle(style) });
  const caption = config.caption ? createEl('div', 'pf-milestone__caption', { text: config.caption }) : null;

  content.append(badge);
  if (iconEl) content.append(iconEl);
  content.append(headline);
  if (caption) content.append(caption);

  visuals.append(glow, effects, content);
  container.appendChild(visuals);

  const play = () => {
    [glow, badge, iconEl, headline, caption].filter(Boolean).forEach((node) => node.getAnimations().forEach((anim) => anim.cancel()));
    effects.innerHTML = '';

    if (config.buildEffects) {
      config.buildEffects(effects, { accent, reduced: state.reducedMotion });
    }

    if (state.reducedMotion) {
      glow.style.opacity = '0.38';
      glow.style.transform = 'translate(-50%, -50%) scale(1)';
      badge.style.transform = 'none';
      badge.style.opacity = '1';
      if (iconEl) iconEl.style.transform = 'none';
      headline.style.opacity = '1';
      if (caption) caption.style.opacity = '1';
      return;
    }

    glow.style.opacity = '0.2';
    glow.style.transform = 'translate(-50%, -50%) scale(0.6)';

    if (config.animate) {
      config.animate({ glow, badge, iconEl, headline, caption, effects, accent });
    }
  };

  return { element: container, play };
};


factoryMap.timer = (entry) => {
  const style = entry.options.style;
  const container = createEl('div', 'pf-timer');
  const value = createEl('div', 'pf-timer__value', { text: '10' });
  const label = createEl('span', 'pf-timer__label', { text: 'Seconds left' });
  const underline = createEl('div', 'pf-timer__underline');
  container.append(value, label, underline);

  let arcPath = null;
  if (style === 'arc' || style === 'color-shift' || style === 'tick') {
    const arc = createEl('div', 'pf-timer__arc');
    arc.innerHTML = '<svg viewBox="0 0 36 36"><path class="pf-timer__path" d="M18 2.5a15.5 15.5 0 1 1 0 31 15.5 15.5 0 0 1 0-31" /></svg>';
    arcPath = arc.querySelector('.pf-timer__path');
    container.appendChild(arc);
  }

  if (style === 'glow') {
    container.classList.add('pf-timer--glow');
  }

  const timers = [];
  const clearTimers = () => { timers.splice(0).forEach(clearTimeout); };
  const duration = entry.options.duration || durations.lg;
  const step = duration / 10;

  const play = () => {
    clearTimers();
    value.textContent = '10';
    underline.style.transform = 'scaleX(1)';
    container.style.removeProperty('--timer-color');
    value.style.transform = 'none';
    value.style.opacity = '1';
    if (arcPath) {
      arcPath.style.strokeDasharray = '97';
      arcPath.style.strokeDashoffset = '97';
    }

    if (state.reducedMotion) {
      value.textContent = '0';
      underline.style.transform = 'scaleX(0)';
      if (arcPath) arcPath.style.strokeDashoffset = '0';
      return;
    }

    numberTween(10, 0, duration, (val) => {
      value.textContent = Math.max(0, Math.ceil(val));
    });

    playWAAPI(underline, [
      { transform: 'scaleX(1)' },
      { transform: 'scaleX(0)' }
    ], { duration, easing: 'linear', fill: 'forwards' });

    const styleHandlers = {
      'pulse': () => {
        playWAAPI(value, [
          { transform: 'scale(1)', color: '#ecc3ff' },
          { transform: 'scale(1.12)', color: '#c6ff77' },
          { transform: 'scale(1)', color: '#ecc3ff' }
        ], { duration: 800, iterations: duration / 800, easing: easingCurves.gentle });
      },
      'breathe': () => {
        playWAAPI(value, [
          { transform: 'scale(1)', letterSpacing: '0.08em' },
          { transform: 'scale(1.08)', letterSpacing: '0.24em' },
          { transform: 'scale(1)', letterSpacing: '0.08em' }
        ], { duration: 1200, iterations: duration / 1200, easing: easingCurves.gentle });
      },
      'color-shift': () => {
        playWAAPI(container, [
          { '--timer-color': '#c6ff77' },
          { '--timer-color': '#ffb300' },
          { '--timer-color': '#fa114f' }
        ], { duration, easing: 'linear', fill: 'forwards' });
        if (arcPath) {
          playMotion(arcPath, { strokeDashoffset: [97, 0] }, { duration: duration / 1000, easing: 'linear' });
        }
      },
      'arc': () => {
        if (arcPath) {
          playMotion(arcPath, { strokeDashoffset: [97, 0] }, { duration: duration / 1000, easing: 'linear' });
        }
      },
      'flash': () => {
        playWAAPI(container, [
          { backgroundColor: 'rgba(255, 89, 129, 0.15)' },
          { backgroundColor: 'rgba(221, 23, 23, 0.45)' },
          { backgroundColor: 'transparent' }
        ], { duration: 0.6, iterations: duration / 600, easing: easingCurves.snap });
      },
      'tick': () => {
        for (let i = 0; i < 10; i += 1) {
          timers.push(setTimeout(() => {
            playMotion(value, { rotate: [0, i % 2 === 0 ? 3 : -3, 0] }, { duration: 0.25, easing: easingCurves.standard });
            if (arcPath) {
              const portion = 97 - (97 / 10) * (i + 1);
              arcPath.style.strokeDashoffset = portion.toString();
            }
          }, step * i));
        }
      },
      'underline': () => {
        playWAAPI(underline, [
          { background: 'rgba(236,195,255,0.16)' },
          { background: 'var(--pf-sweep-gradient)' },
          { background: 'rgba(236,195,255,0.16)' }
        ], { duration: 900, iterations: duration / 900, easing: easingCurves.standard });
      },
      'flip': () => {
        for (let i = 0; i < 10; i += 1) {
          timers.push(setTimeout(() => {
            playMotion(value, { rotateX: [0, -180, -360], opacity: [1, 0.6, 1] }, { duration: 0.5, easing: easingCurves.snap });
          }, step * i));
        }
      },
      'glow': () => {
        playMotion(value, { textShadow: ['0 0 0 rgba(198,255,119,0)', '0 0 24px rgba(198,255,119,0.6)', '0 0 0 rgba(198,255,119,0)'] }, { duration: 1, easing: easingCurves.gentle });
      },
      'pop': () => {
        timers.push(setTimeout(() => {
          playMotion(value, { scale: [1, 1.35, 0.92, 1] }, { duration: 0.6, easing: easingCurves.vibrant });
        }, duration - 400));
      },
    };

    if (styleHandlers[style]) {
      styleHandlers[style]();
    }
  };

  return { element: container, play };
};


const updateIndicatorConfigs = {
  'badge-pop': {
    animate(container, badge, icon, copy) {
      playMotion(badge, { scale: [0.6, 1.1, 1] }, { duration: 0.4, easing: easingCurves.pop });
    },
  },
  'badge-pulse': {
    animate(container, badge) {
      playMotion(badge, { boxShadow: ['0 0 0 rgba(236,195,255,0)', '0 0 18px rgba(236,195,255,0.4)', '0 0 0 rgba(236,195,255,0)'] }, { duration: 1, easing: easingCurves.gentle });
    },
  },
  'live-ping': {
    animate(container, badge, icon) {
      playMotion(icon, { scale: [1, 1.6, 1], opacity: [1, 0, 1] }, { duration: 1.2, easing: easingCurves.gentle });
    },
  },
  'notification-dot': {
    animate(container, badge, icon) {
      playMotion(icon, { boxShadow: ['0 0 0 rgba(198,255,119,0.6)', '0 0 18px rgba(198,255,119,0)', '0 0 0 rgba(198,255,119,0)'] }, { duration: 0.8, easing: easingCurves.standard });
    },
  },
  'counter-increment': {
    animate(container, badge, icon, copy) {
      const number = createEl('span', '', { text: '+1' });
      number.className = 'pf-update-indicator__counter';
      copy.appendChild(number);
      playMotion(number, { translateY: [8, -12], opacity: [0, 1, 0] }, { duration: 0.8, easing: easingCurves.entrance }).finished?.finally(() => number.remove());
    },
  },
  'ticker-scroll': {
    animate(container, badge, icon, copy) {
      const text = copy.textContent || 'Content update arrived';
      const ticker = createEl('div', 'pf-update-indicator__ticker', { text });
      copy.innerHTML = '';
      copy.appendChild(ticker);
      playMotion(ticker, { translateX: ['0%', '-60%'] }, { duration: 4, easing: 'linear' }).finished?.finally(() => { copy.textContent = text; });
    },
  },
  'update-slide': {
    animate(container, badge, icon, copy) {
      playMotion(copy, { translateY: [16, 0], opacity: [0, 1] }, { duration: 0.5, easing: easingCurves.entrance });
    },
  },
  'update-flip': {
    animate(container, badge, icon, copy) {
      playMotion(copy, { rotateX: [-90, 0], opacity: [0, 1] }, { duration: 0.45, easing: easingCurves.snap });
    },
  },
  'update-spark': {
    animate(container, badge, icon, copy) {
      playMotion(container, { boxShadow: ['0 0 0 rgba(200,53,88,0)', '0 0 22px rgba(200,53,88,0.4)', '0 0 0 rgba(200,53,88,0)'] }, { duration: 0.8, easing: easingCurves.vibrant });
    },
  },
};

factoryMap.updateIndicator = (entry) => {
  const container = createEl('div', 'pf-update-indicator');
  const icon = createEl('div', 'pf-update-indicator__icon');
  const copy = createEl('div', 'pf-update-indicator__copy', { text: 'Content update arrived' });
  const badge = createEl('div', 'pf-update-indicator__badge', { text: 'New' });
  container.append(icon, copy, badge);

  const play = () => {
    [container, badge, icon, copy].forEach((node) => node.getAnimations().forEach((anim) => anim.cancel()));
    const config = updateIndicatorConfigs[entry.options.style];
    if (config && config.animate) {
      config.animate(container, badge, icon, copy);
    }
  };

  return { element: container, play };
};


const timerComplexConfigs = {
  'circular': {
    label: 'Circular Sweep',
    pointerRange: 320,
    accent: '#47fff4',
    animate(container, pointer, dial) {
      playMotion(pointer, { rotate: ['-90deg', '230deg'] }, { duration: 1.4, easing: easingCurves.entrance });
      playMotion(dial, { boxShadow: ['0 0 0 rgba(71,255,244,0)', '0 0 24px rgba(71,255,244,0.4)', '0 0 0 rgba(71,255,244,0)'] }, { duration: 1, easing: easingCurves.gentle });
    },
  },
  'mode-switch': {
    label: 'Mode Switch',
    pointerRange: 260,
    accent: '#c47ae5',
    animate(container, pointer) {
      playMotion(pointer, { rotate: ['-120deg', '140deg'] }, { duration: 1.2, easing: easingCurves.vibrant });
      playMotion(container, { background: ['rgba(78,24,124,0.45)', 'rgba(33,15,49,0.9)'] }, { duration: 0.6, direction: 'alternate', iterations: state.reducedMotion ? 1 : 3 });
    },
  },
  'generator-fill': {
    label: 'Generator Fill',
    pointerRange: 200,
    accent: '#c6ff77',
    animate(container, pointer, dial) {
      const segments = dial.querySelectorAll('.pf-timer-complex__segment');
      segments.forEach((segment, index) => {
        playMotion(segment, { opacity: [0.1, 0.9] }, { duration: 0.3, easing: easingCurves.entrance, delay: index * 0.18 });
      });
      playMotion(pointer, { rotate: ['-150deg', '80deg'] }, { duration: 1.3, easing: easingCurves.standard });
    },
  },
  'tournament-timer': {
    label: 'Tournament Clock',
    pointerRange: 300,
    accent: '#ffce1a',
    animate(container, pointer, dial) {
      const ranks = container.querySelectorAll('.pf-timer-complex__ranks span');
      ranks.forEach((rank, index) => {
        playMotion(rank, { translateY: [8, 0], opacity: [0, 1] }, { duration: 0.4, easing: easingCurves.entrance, delay: index * 0.12 });
      });
      playMotion(pointer, { rotate: ['-110deg', '150deg'] }, { duration: 1.5, easing: easingCurves.vibrant });
    },
  },
  'countdown-flip': {
    label: 'Flip Countdown',
    pointerRange: 240,
    accent: '#ff5981',
    animate(container, pointer) {
      playMotion(pointer, { rotate: ['-90deg', '120deg'] }, { duration: 1.2, easing: easingCurves.snap });
      const flaps = container.querySelectorAll('.pf-timer-complex__flap');
      flaps.forEach((flap, index) => {
        playMotion(flap, { rotateX: [0, -180], opacity: [1, 0.6, 1] }, { duration: 0.6, easing: easingCurves.snap, delay: index * 0.18 });
      });
    },
  },
};

factoryMap.timerComplex = (entry) => {
  const style = entry.options.style;
  const config = timerComplexConfigs[style] || timerComplexConfigs['circular'];
  const container = createEl('div', 'pf-timer-complex');
  container.dataset.style = style;
  const dial = createEl('div', 'pf-timer-complex__dial');
  dial.style.setProperty('--pf-timer-accent', config.accent);
  const pointer = createEl('div', 'pf-timer-complex__pointer');
  dial.appendChild(pointer);

  if (style === 'generator-fill') {
    const segmentWrap = createEl('div', 'pf-timer-complex__segments');
    for (let i = 0; i < 6; i += 1) {
      const segment = createEl('span', 'pf-timer-complex__segment');
      segment.style.transform = `rotate(${i * 60}deg)`;
      segmentWrap.appendChild(segment);
    }
    dial.appendChild(segmentWrap);
  }

  if (style === 'countdown-flip') {
    const flapWrap = createEl('div', 'pf-timer-complex__flaps');
    for (let i = 0; i < 3; i += 1) {
      flapWrap.appendChild(createEl('span', 'pf-timer-complex__flap', { text: `${3 - i}` }));
    }
    dial.appendChild(flapWrap);
  }

  container.appendChild(dial);
  const footer = createEl('div', 'pf-timer-complex__footer', { text: config.label });
  container.appendChild(footer);

  if (style === 'tournament-timer') {
    const ranks = createEl('div', 'pf-timer-complex__ranks');
    ['#1', '#2', '#3'].forEach((rank) => ranks.appendChild(createEl('span', '', { text: rank })));
    container.appendChild(ranks);
  }

  const play = () => {
    pointer.getAnimations().forEach((anim) => anim.cancel());
    pointer.style.transform = 'rotate(-120deg)';
    const dialChildren = dial.querySelectorAll('*');
    dialChildren.forEach((child) => child.getAnimations().forEach((anim) => anim.cancel()));
    if (state.reducedMotion) {
      pointer.style.transform = 'rotate(45deg)';
      return;
    }
    if (config.animate) {
      config.animate(container, pointer, dial);
    }
  };

  return { element: container, play };
};


const realtimeDataItems = [
  { name: 'NovaStream', score: 12840 },
  { name: 'PixelPulse', score: 10840 },
  { name: 'EchoArena', score: 9650 },
  { name: 'VibeCast', score: 8120 }
];

const realtimeConfigs = {
  'leaderboard-shift': (list) => {
    const rows = Array.from(list.children);
    playMotion(rows[0], { translateY: [0, 100], opacity: [1, 0.6] }, { duration: 0.5, easing: easingCurves.entrance }).finished?.then(() => {
      list.appendChild(rows[0]);
      playMotion(rows[0], { translateY: [-100, 0], opacity: [0.6, 1] }, { duration: 0.4, easing: easingCurves.standard });
    });
  },
  'live-score-update': (list) => {
    list.querySelectorAll('.pf-realtime__score').forEach((scoreEl) => {
      const value = parseInt(scoreEl.dataset.value, 10);
      playMotion(scoreEl, { scale: [1, 1.2, 1], color: ['#ecc3ff', '#c6ff77', '#ecc3ff'] }, { duration: 0.6, easing: easingCurves.gentle });
      numberTween(value, value + 120, 600, (val) => {
        scoreEl.textContent = Math.round(val).toLocaleString();
      });
    });
  },
  'win-ticker': (list) => {
    const ticker = createEl('div', 'pf-realtime__ticker', { text: 'Mega Win! +5,000 credits  Daily streak unlocked  Bonus wheel ready' });
    const tickerRow = createEl('div', 'pf-realtime__ticker-row');
    tickerRow.appendChild(ticker);
    list.innerHTML = '';
    list.appendChild(tickerRow);
    playMotion(ticker, { translateX: ['0%', '-80%'] }, { duration: 6, easing: 'linear' });
  },
  'currency-update': (list) => {
    list.querySelectorAll('.pf-realtime__score').forEach((scoreEl) => {
      const sparkle = createEl('span', 'pf-realtime__sparkle', { text: '' });
      scoreEl.appendChild(sparkle);
      playMotion(sparkle, { opacity: [0.8, 0], translateY: [0, -20], scale: [0.6, 1.2] }, { duration: 0.6, easing: easingCurves.entrance }).finished?.finally(() => sparkle.remove());
    });
  },
  'stacked-realtime': (list) => {
    list.classList.add('pf-realtime__list--stacked');
    list.querySelectorAll('.pf-realtime__item').forEach((row, index) => {
      playMotion(row, { translateX: [index % 2 === 0 ? -16 : 16, 0], opacity: [0, 1] }, { duration: 0.4, easing: easingCurves.entrance, delay: index * 0.08 });
    });
  },
};

factoryMap.realtimeData = (entry) => {
  const container = createEl('div', 'pf-realtime');
  const heading = createEl('div', 'pf-realtime__heading', { text: 'Top creators' });
  const list = createEl('div', 'pf-realtime__list');

  realtimeDataItems.forEach((item) => {
    const row = createEl('div', 'pf-realtime__item');
    row.appendChild(createEl('span', 'pf-realtime__rank', { text: `#${item.rank || 1}` }));
    row.appendChild(createEl('span', 'pf-realtime__name', { text: item.name }));
    const score = createEl('span', 'pf-realtime__score', { text: item.score.toLocaleString() });
    score.dataset.value = item.score;
    row.appendChild(score);
    list.appendChild(row);
  });

  container.append(heading, list);

  const play = () => {
    list.classList.remove('pf-realtime__list--stacked');
    list.innerHTML = '';
    realtimeDataItems.forEach((item, index) => {
      const row = createEl('div', 'pf-realtime__item');
      row.appendChild(createEl('span', 'pf-realtime__rank', { text: `#${index + 1}` }));
      row.appendChild(createEl('span', 'pf-realtime__name', { text: item.name }));
      const score = createEl('span', 'pf-realtime__score', { text: item.score.toLocaleString() });
      score.dataset.value = item.score;
      row.appendChild(score);
      list.appendChild(row);
    });

    const handler = realtimeConfigs[entry.options.style];
    if (handler) {
      handler(list);
    }
  };

  return { element: container, play };
};


const rewardBasicConfigs = {
  'coin-spin-soft': {
    label: 'Soft Coin Spin',
    symbol: '',
    background: 'linear-gradient(135deg, #ffd966 0%, #ffb300 100%)',
    color: '#1d092f',
    animate(icon, options = {}) {
      const duration = ((options.duration || durations.md) / 1000) || 0.32;
      playMotion(icon, {
        rotateY: ['0deg', '360deg'],
        scale: [0.9, 1.05, 0.98, 1],
      }, { duration, easing: easingCurves.entrance });
    },
  },
  'coin-spin-fast': {
    label: 'Quick Coin Spin',
    symbol: '',
    background: 'linear-gradient(135deg, #ffe066 0%, #ff9500 100%)',
    color: '#14021f',
    animate(icon, options = {}) {
      const duration = Math.max(((options.duration || durations.sm) / 1000) * 0.8, 0.28);
      playMotion(icon, {
        rotateY: ['0deg', '720deg'],
        scale: [0.92, 1.12, 1],
      }, { duration, easing: easingCurves.vibrant });
    },
  },
  'star-burst': {
    label: 'Star Burst',
    symbol: '',
    background: 'linear-gradient(135deg, #ecc3ff 0%, #ff5981 100%)',
    color: '#1d092f',
    animate(icon, options = {}) {
      const duration = (options.duration || durations.md) / 1000;
      playMotion(icon, {
        scale: [0.7, 1.22, 1],
        filter: ['brightness(0.8)', 'brightness(1.4)', 'brightness(1)'],
      }, { duration, easing: easingCurves.vibrant });
    },
  },
  'star-radiate': {
    label: 'Star Radiate',
    symbol: '',
    background: 'linear-gradient(135deg, #47fff4 0%, #0586ae 100%)',
    color: '#0b1b23',
    animate(icon, options = {}) {
      const duration = (options.duration || durations.lg) / 1000;
      playMotion(icon, {
        rotate: ['0deg', '36deg', '-18deg', '0deg'],
        boxShadow: ['0 0 0 rgba(71,255,244,0)', '0 0 22px rgba(71,255,244,0.6)', '0 0 0 rgba(71,255,244,0)'],
      }, { duration, easing: easingCurves.entrance });
    },
  },
  'glow-pulse': {
    label: 'Glow Pulse',
    symbol: '',
    background: 'linear-gradient(135deg, #c47ae5 0%, #ecc3ff 100%)',
    color: '#1d092f',
    animate(icon, options = {}) {
      const duration = (options.duration || durations.lg) / 1000;
      playMotion(icon, {
        scale: [0.92, 1.08, 1],
        boxShadow: ['0 0 0 rgba(236,195,255,0)', '0 0 24px rgba(236,195,255,0.55)', '0 0 0 rgba(236,195,255,0)'],
      }, { duration, easing: easingCurves.gentle });
    },
  },
  'glow-orbit': {
    label: 'Glow Orbit',
    symbol: '',
    background: 'radial-gradient(circle at 50% 50%, rgba(198,255,119,0.85) 0%, rgba(29,9,47,0.4) 70%)',
    color: '#1d092f',
    animate(icon, options = {}) {
      const duration = (options.duration || durations.xl) / 1000;
      playMotion(icon, {
        rotate: ['0deg', '360deg'],
        boxShadow: ['0 0 0 rgba(198,255,119,0)', '0 0 20px rgba(198,255,119,0.45)', '0 0 0 rgba(198,255,119,0)'],
      }, { duration, easing: 'linear' });
    },
  },
  'bounce-soft': {
    label: 'Soft Bounce',
    symbol: '',
    background: 'linear-gradient(135deg, #ffb3c6 0%, #c83558 100%)',
    color: '#ffffff',
    animate(icon, options = {}) {
      const duration = (options.duration || durations.md) / 1000;
      playMotion(icon, {
        translateY: ['0px', '-10px', '0px'],
        scale: [1, 1.08, 1],
      }, { duration, easing: easingCurves.entrance });
    },
  },
  'bounce-energy': {
    label: 'Energetic Bounce',
    symbol: '',
    background: 'linear-gradient(135deg, #c6ff77 0%, #47fff4 100%)',
    color: '#1d092f',
    animate(icon, options = {}) {
      const duration = (options.duration || durations.md) / 1000;
      playMotion(icon, {
        translateY: ['0px', '-18px', '0px'],
        scale: [1, 1.15, 1],
        rotate: ['-6deg', '4deg', '0deg'],
      }, { duration, easing: easingCurves.vibrant });
    },
  },
  'badge-glint': {
    label: 'Badge Glint',
    symbol: '',
    background: 'linear-gradient(135deg, #ff5981 0%, #ffce1a 100%)',
    color: '#1d092f',
    animate(icon, options = {}) {
      const duration = (options.duration || durations.lg) / 1000;
      playMotion(icon, {
        scale: [0.94, 1.06, 1],
        filter: ['brightness(0.85)', 'brightness(1.4)', 'brightness(1)'],
      }, { duration, easing: easingCurves.gentle });
    },
  },
  'badge-sweep': {
    label: 'Badge Sweep',
    symbol: '',
    background: 'linear-gradient(135deg, #4e187c 0%, #c47ae5 100%)',
    color: '#ffffff',
    animate(icon, options = {}) {
      const duration = (options.duration || durations.lg) / 1000;
      playMotion(icon, {
        translateX: ['-6px', '6px', '0px'],
        boxShadow: ['0 0 0 rgba(236,195,255,0)', '0 0 20px rgba(236,195,255,0.35)', '0 0 0 rgba(236,195,255,0)'],
      }, { duration, easing: easingCurves.standard });
    },
  },
};


factoryMap.rewardBasic = (entry) => {
  const style = entry.options.style;
  const config = rewardBasicConfigs[style] || rewardBasicConfigs['coin-spin-soft'];
  const container = createEl('div', 'pf-reward-basic');
  container.dataset.style = style;
  const icon = createEl('div', 'pf-reward-basic__icon', { text: config.symbol || '' });
  icon.style.background = config.background;
  if (config.color) {
    icon.style.color = config.color;
  }
  const label = createEl('span', 'pf-reward-basic__label', { text: config.label });
  container.append(icon, label);

  const play = () => {
    icon.getAnimations().forEach((anim) => anim.cancel());
    icon.style.transform = 'none';
    icon.style.filter = 'none';
    if (config.animate) {
      config.animate(icon, entry.options);
    }
  };

  return { element: container, play };
};

const rewardFeedbackConfigs = {
  'button-success': {
    label: 'Success CTA',
    background: 'linear-gradient(135deg, #1bee02 0%, #00ad45 100%)',
    animate(button) {
      playMotion(button, { scale: [1, 1.08, 1], filter: ['brightness(1)', 'brightness(1.2)', 'brightness(1)'] }, { duration: 0.6, easing: easingCurves.pop });
    },
  },
  'button-success-spark': {
    label: 'Spark CTA',
    background: 'linear-gradient(135deg, #47fff4 0%, #0586ae 100%)',
    animate(button) {
      playMotion(button, { scale: [1, 1.12, 1], boxShadow: ['0 0 0 rgba(71,255,244,0)', '0 0 28px rgba(71,255,244,0.5)', '0 0 0 rgba(71,255,244,0)'] }, { duration: 0.7, easing: easingCurves.vibrant });
    },
  },
  'button-hover-tilt': {
    label: 'Hover Tilt',
    background: 'rgba(236, 195, 255, 0.12)',
    animate(button) {
      playMotion(button, { rotate: [0, -4, 4, 0], translateY: [0, -2, -1, 0] }, { duration: 0.8, easing: easingCurves.standard });
    },
  },
  'button-hover-glow': {
    label: 'Hover Glow',
    background: 'rgba(236, 195, 255, 0.18)',
    animate(button) {
      playMotion(button, { boxShadow: ['0 0 0 rgba(236,195,255,0)', '0 0 22px rgba(236,195,255,0.5)', '0 0 0 rgba(236,195,255,0)'] }, { duration: 1, easing: easingCurves.gentle });
    },
  },
  'focus-ring': {
    label: 'Focus Ring',
    background: 'rgba(236, 195, 255, 0.08)',
    animate(button) {
      const ring = createEl('span', 'pf-reward-feedback__ring');
      button.appendChild(ring);
      playMotion(ring, { opacity: [0.6, 0], scale: [1, 1.6] }, { duration: 0.8, easing: easingCurves.gentle }).finished?.finally(() => ring.remove());
    },
  },
  'click-ripple-soft': {
    label: 'Soft Ripple',
    background: 'rgba(236, 195, 255, 0.08)',
    animate(button) {
      const ripple = createEl('span', 'pf-reward-feedback__ripple');
      button.appendChild(ripple);
      playMotion(ripple, { opacity: [0.45, 0], scale: [0.4, 1.4] }, { duration: 0.7, easing: easingCurves.gentle }).finished?.finally(() => ripple.remove());
    },
  },
  'click-ripple-strong': {
    label: 'Strong Ripple',
    background: 'rgba(236, 195, 255, 0.12)',
    animate(button) {
      const ripple = createEl('span', 'pf-reward-feedback__ripple');
      button.appendChild(ripple);
      playMotion(ripple, { opacity: [0.6, 0], scale: [0.3, 1.6] }, { duration: 0.6, easing: easingCurves.vibrant }).finished?.finally(() => ripple.remove());
    },
  },
  'tile-activate': {
    label: 'Tile Activate',
    background: 'linear-gradient(135deg, #c47ae5 0%, #7a468e 100%)',
    animate(button) {
      playMotion(button, { translateY: [0, -6, 0], scale: [1, 1.02, 1] }, { duration: 0.6, easing: easingCurves.standard });
    },
  },
  'tile-press': {
    label: 'Tile Press',
    background: 'linear-gradient(135deg, #4e187c 0%, #3a125d 100%)',
    animate(button) {
      playMotion(button, { scale: [1, 0.94, 1] }, { duration: 0.4, easing: easingCurves.snap });
    },
  },
  'glow-hover': {
    label: 'Glow Hover',
    background: 'linear-gradient(135deg, #c83558 0%, #7a468e 100%)',
    animate(button) {
      playMotion(button, { boxShadow: ['0 0 0 rgba(200,53,88,0)', '0 0 24px rgba(200,53,88,0.45)', '0 0 0 rgba(200,53,88,0)'] }, { duration: 0.9, easing: easingCurves.gentle });
    },
  },
};

factoryMap.rewardFeedback = (entry) => {
  const style = entry.options.style;
  const config = rewardFeedbackConfigs[style] || rewardFeedbackConfigs['button-success'];
  const container = createEl('div', 'pf-reward-feedback');
  const button = createEl('button', 'pf-reward-feedback__button', { text: config.label });
  button.style.background = config.background;
  container.appendChild(button);

  const play = () => {
    button.getAnimations().forEach((anim) => anim.cancel());
    button.style.transform = 'none';
    button.style.boxShadow = 'none';
    if (config.animate) {
      config.animate(button, entry.options);
    }
  };

  return { element: container, play };
};


factoryMap.rewardMechanic = (entry) => {
  const style = entry.options.style;
  const container = createEl('div', `pf-reward-mechanic pf-reward-mechanic--${style}`);
  let primary;

  if (style.startsWith('wheel')) {
    primary = createEl('div', 'pf-reward-wheel');
    for (let i = 0; i < 6; i += 1) {
      primary.appendChild(createEl('span', 'pf-reward-wheel__slice', { text: `${i + 1}` }));
    }
    const pointer = createEl('div', 'pf-reward-wheel__pointer');
    primary.appendChild(pointer);
    container.appendChild(primary);
  } else if (style.startsWith('chest')) {
    primary = createEl('div', 'pf-reward-chest');
    primary.appendChild(createEl('div', 'pf-reward-chest__lid'));
    primary.appendChild(createEl('div', 'pf-reward-chest__body'));
    container.appendChild(primary);
  } else if (style.startsWith('card')) {
    primary = createEl('div', 'pf-reward-cards');
    for (let i = 0; i < 3; i += 1) {
      primary.appendChild(createEl('div', 'pf-reward-card'));
    }
    container.appendChild(primary);
  } else if (style === 'scratch-card') {
    primary = createEl('div', 'pf-reward-scratch');
    primary.appendChild(createEl('div', 'pf-reward-scratch__mask'));
    container.appendChild(primary);
  } else if (style === 'slot-reels') {
    primary = createEl('div', 'pf-reward-slot');
    for (let i = 0; i < 3; i += 1) {
      const reel = createEl('div', 'pf-reward-slot__reel');
      ['', '', '', '7'].forEach((symbol) => reel.appendChild(createEl('span', '', { text: symbol })));
      primary.appendChild(reel);
    }
    container.appendChild(primary);
  } else if (style === 'dice-roll') {
    primary = createEl('div', 'pf-reward-dice');
    for (let i = 0; i < 6; i += 1) {
      primary.appendChild(createEl('span', 'pf-reward-dice__pip'));
    }
    container.appendChild(primary);
  } else if (style === 'mystery-box') {
    primary = createEl('div', 'pf-reward-box');
    primary.appendChild(createEl('div', 'pf-reward-box__lid'));
    primary.appendChild(createEl('div', 'pf-reward-box__body'));
    container.appendChild(primary);
  } else if (style === 'map-path') {
    primary = createEl('div', 'pf-reward-map');
    for (let i = 0; i < 4; i += 1) {
      primary.appendChild(createEl('div', 'pf-reward-map__step'));
    }
    container.appendChild(primary);
  } else {
    primary = createEl('div', 'pf-reward-generic');
    container.appendChild(primary);
  }

  const play = () => {
    if (state.reducedMotion) {
      primary.style.transform = 'scale(1)';
      if (primary.classList.contains('pf-reward-wheel')) {
        primary.style.rotate = '45deg';
      }
      return;
    }
    if (style.startsWith('wheel')) {
      playMotion(primary, [
        { rotate: '0deg' },
        { rotate: `${style === 'wheel-spin-fast' ? 1080 : 720}deg` },
        { rotate: `${style === 'wheel-spin-fast' ? 1110 : 720}deg` }
      ], { duration: (entry.options.duration || 3200) / 1000, easing: easingCurves.vibrant });
    } else if (style.startsWith('chest')) {
      const lid = primary.querySelector('.pf-reward-chest__lid');
      playMotion(lid, [
        { transform: 'rotateX(0deg)' },
        { transform: 'rotateX(-70deg)' }
      ], { duration: 0.6, easing: easingCurves.entrance });
    } else if (style.startsWith('card')) {
      const cards = primary.querySelectorAll('.pf-reward-card');
      cards.forEach((card, index) => {
        playMotion(card, [
          { transform: `translateX(${index * 10}px) translateY(0) rotate(${index * 2}deg)` },
          { transform: `translateX(${index * 10}px) translateY(-30px) rotate(${index * 5 - 10}deg)` }
        ], { duration: 0.4, easing: easingCurves.entrance, delay: index * 0.12 });
      });
    } else if (style === 'scratch-card') {
      const mask = primary.querySelector('.pf-reward-scratch__mask');
      playMotion(mask, [ { width: '100%' }, { width: '0%' } ], { duration: 0.8, easing: easingCurves.standard });
    } else if (style === 'slot-reels') {
      primary.querySelectorAll('.pf-reward-slot__reel').forEach((reel, index) => {
        playMotion(reel, [ { transform: 'translateY(0)' }, { transform: 'translateY(-75%)' } ], { duration: 0.9 + index * 0.12, easing: easingCurves.vibrant });
      });
    } else if (style === 'dice-roll') {
      playMotion(primary, [
        { transform: 'rotateX(0deg) rotateY(0deg)' },
        { transform: 'rotateX(360deg) rotateY(720deg)' }
      ], { duration: 1.2, easing: easingCurves.vibrant });
    } else if (style === 'mystery-box') {
      const lid = primary.querySelector('.pf-reward-box__lid');
      playMotion(lid, [ { transform: 'translateY(0)' }, { transform: 'translateY(-40px)' } ], { duration: 0.6, easing: easingCurves.entrance });
    } else if (style === 'map-path') {
      const steps = primary.querySelectorAll('.pf-reward-map__step');
      steps.forEach((step, index) => {
        step.classList.remove('is-active');
        void step.offsetWidth;
        setTimeout(() => step.classList.add('is-active'), index * 120);
      });
    } else if (style === 'loot-drop') {
      playMotion(primary, [ { transform: 'translateY(-60px)', opacity: 0 }, { transform: 'translateY(0)', opacity: 1 } ], { duration: 0.6, easing: easingCurves.bounce });
    } else {
      playMotion(primary, [ { transform: 'scale(0.8)' }, { transform: 'scale(1.05)' }, { transform: 'scale(1)' } ], { duration: 0.6, easing: easingCurves.pop });
    }
  };

  return { element: container, play };
};


factoryMap.rewardOrchestration = (entry) => {
  const container = createEl('div', 'pf-reward-orchestration');
  const stage = createEl('div', 'pf-reward-orchestration__stage');
  container.appendChild(stage);

  const play = () => {
    clearChildren(stage);
    if (state.reducedMotion) {
      const coin = createEl('div', 'pf-reward-orchestration__coin');
      coin.style.left = '50%';
      coin.style.top = '40%';
      stage.appendChild(coin);
      return;
    }
    const total = entry.options.style.includes('multi') ? 14 : 8;
    for (let i = 0; i < total; i += 1) {
      const coin = createEl('div', 'pf-reward-orchestration__coin');
      stage.appendChild(coin);
      const angle = (i / total) * Math.PI * 2;
      const radius = entry.options.style.includes('trail') ? 40 : 60;
      const targetX = Math.cos(angle) * radius;
      const targetY = Math.sin(angle) * radius;
      playMotion(coin, [
        { transform: 'translate3d(0, 0, 0) scale(0.5)', opacity: 0 },
        { transform: `translate3d(${targetX}px, ${targetY}px, 0) scale(1)`, opacity: 1 },
        { transform: `translate3d(${targetX * 1.4}px, ${targetY * -0.6}px, 0) scale(0.4)`, opacity: 0 }
      ], { duration: (entry.options.duration || 2600) / 1000, easing: easingCurves.vibrant, delay: i * 0.06 });
    }
  };

  return { element: container, play };
};


const navigationMenuHandlers = {
  'drawer-slide': (menu, content) => {
    playMotion(menu, { transform: ['translateX(-100%)', 'translateX(0)'] }, { duration: 0.5, easing: easingCurves.entrance });
  },
  'drawer-scale': (menu) => {
    playMotion(menu, { transform: ['scale(0.85)', 'scale(1)'], opacity: [0, 1] }, { duration: 0.45, easing: easingCurves.standard });
  },
  'dropdown': (menu) => {
    playMotion(menu, { height: ['0px', '120px'] }, { duration: 0.4, easing: easingCurves.entrance });
  },
  'dropdown-soft': (menu) => {
    playMotion(menu, { opacity: [0, 1], transform: ['translateY(-10px)', 'translateY(0)'] }, { duration: 0.5, easing: easingCurves.gentle });
  },
  'tab-ink': (menu, content, indicator) => {
    playMotion(indicator, { transform: ['scaleX(0)', 'scaleX(1)'] }, { duration: 0.4, easing: easingCurves.standard });
  },
  'tab-glide': (menu, content, indicator) => {
    playMotion(indicator, { transform: ['translateX(0)', 'translateX(120px)'] }, { duration: 0.6, easing: easingCurves.entrance });
  },
  'mobile-transform': (menu) => {
    playMotion(menu, { transform: ['translateY(40px)', 'translateY(0)'], opacity: [0, 1] }, { duration: 0.4, easing: easingCurves.entrance });
  },
  'breadcrumb-flare': (menu, content) => {
    playMotion(content, { opacity: [0, 1], letterSpacing: ['0.06em', '0.22em', '0.08em'] }, { duration: 0.6, easing: easingCurves.gentle });
  },
  'breadcrumb-slide': (menu, content) => {
    playMotion(content, { translateX: [-12, 0], opacity: [0, 1] }, { duration: 0.4, easing: easingCurves.standard });
  },
  'sidebar-reveal': (menu, content) => {
    playMotion(menu, { width: ['0px', '200px'] }, { duration: 0.5, easing: easingCurves.entrance });
  },
  'sidebar-floating': (menu, content) => {
    playMotion(menu, { translateY: [12, 0], boxShadow: ['0 0 0 rgba(236,195,255,0)', '0 18px 32px rgba(0,0,0,0.35)'] }, { duration: 0.6, easing: easingCurves.gentle });
  },
  'nav-hover': (menu, content) => {
    playMotion(menu, { transform: ['translateY(0)', 'translateY(-4px)', 'translateY(0)'] }, { duration: 0.5, easing: easingCurves.standard });
  },
};

factoryMap.navigationMenu = (entry) => {
  const container = createEl('div', 'pf-nav-preview');
  const menu = createEl('div', 'pf-nav-preview__menu');
  const content = createEl('div', 'pf-nav-preview__content');
  const indicator = createEl('div', 'pf-nav-preview__indicator');
  content.appendChild(indicator);

  const items = ['Overview', 'Rewards', 'Leaderboard', 'Store'];
  const buttons = items.map((label, index) => {
    const button = createEl('button', '', { text: label });
    if (index === 0) button.classList.add('is-active');
    menu.appendChild(button);
    return button;
  });

  container.append(menu, content);

  const play = () => {
    buttons.forEach((btn) => btn.classList.remove('is-active'));
    buttons[1]?.classList.add('is-active');
    menu.getAnimations().forEach((anim) => anim.cancel());
    const handler = navigationMenuHandlers[entry.options.style];
    if (handler) {
      handler(menu, content, indicator);
    }
  };

  return { element: container, play };
};


const pageTransitionHandlers = {
  'page-fade': (hero, blocks) => { playMotion(hero, { opacity: [0, 1] }, { duration: 0.5, easing: easingCurves.gentle }); },
  'page-slide-up': (hero, blocks) => { playMotion(hero, { translateY: [80, 0], opacity: [0, 1] }, { duration: 0.6, easing: easingCurves.entrance }); },
  'page-slide-right': (hero, blocks) => { playMotion(hero, { translateX: [-120, 0], opacity: [0, 1] }, { duration: 0.6, easing: easingCurves.standard }); },
  'page-scale': (hero) => { playMotion(hero, { scale: [0.85, 1], opacity: [0.4, 1] }, { duration: 0.5, easing: easingCurves.standard }); },
  'page-wipe': (hero) => { playMotion(hero, { clipPath: ['inset(0 100% 0 0)', 'inset(0 0 0 0)'] }, { duration: 0.5, easing: easingCurves.snap }); },
  'section-reveal': (hero, blocks) => { blocks.forEach((block, index) => playMotion(block, { opacity: [0, 1], translateY: [20, 0] }, { duration: 0.4, easing: easingCurves.entrance, delay: index * 0.08 })); },
  'section-rise': (hero, blocks) => { blocks.forEach((block, index) => playMotion(block, { translateY: [30, 0], opacity: [0, 1] }, { duration: 0.5, easing: easingCurves.standard, delay: index * 0.1 })); },
  'lazy-entrance': (hero, blocks) => { playMotion(hero, { opacity: [0, 1], translateY: [40, 0] }, { duration: 0.6, easing: easingCurves.gentle }); },
  'lazy-fade': (hero, blocks) => { blocks.forEach((block) => playMotion(block, { opacity: [0, 1] }, { duration: 0.6, easing: easingCurves.gentle })); },
  'scroll-reveal-soft': (hero, blocks) => { blocks.forEach((block, index) => playMotion(block, { opacity: [0, 1], translateY: [14, 0] }, { duration: 0.4, easing: easingCurves.gentle, delay: index * 0.05 })); },
  'scroll-reveal-burst': (hero, blocks) => { blocks.forEach((block, index) => playMotion(block, { scale: [0.8, 1.05, 1], opacity: [0, 1] }, { duration: 0.5, easing: easingCurves.vibrant, delay: index * 0.06 })); },
  'hero-parallax': (hero, blocks) => { playMotion(hero, { transform: ['translateY(-30px)', 'translateY(0)'] }, { duration: 0.8, easing: easingCurves.gentle }); }
};

factoryMap.pageTransition = (entry) => {
  const container = createEl('div', 'pf-page-transition');
  const hero = createEl('div', 'pf-page-transition__hero', { text: 'Hero Section' });
  const body = createEl('div', 'pf-page-transition__body');
  const blocks = [];
  for (let i = 0; i < 3; i += 1) {
    const block = createEl('div', 'pf-page-transition__block');
    body.appendChild(block);
    blocks.push(block);
  }
  container.append(hero, body);

  const play = () => {
    hero.getAnimations().forEach((anim) => anim.cancel());
    blocks.forEach((block) => block.getAnimations().forEach((anim) => anim.cancel()));
    const handler = pageTransitionHandlers[entry.options.style];
    if (handler) {
      handler(hero, blocks);
    }
  };

  return { element: container, play };
};


const navigationComplexHandlers = {
  'nav-morph': (container, panels) => {
    playMotion(container, { borderRadius: ['24px', '8px', '24px'] }, { duration: 0.8, easing: easingCurves.gentle });
  },
  'nav-gesture': (container, panels) => {
    playMotion(container, { translateX: [-40, 0], opacity: [0, 1] }, { duration: 0.5, easing: easingCurves.entrance });
  },
  'nav-parallax': (container, panels) => {
    panels.forEach((panel, index) => {
      playMotion(panel, { translateY: [index * 8, 0] }, { duration: 0.6, easing: easingCurves.gentle });
    });
  },
  'nav-sticky': (container, panels) => {
    playMotion(container, { boxShadow: ['0 0 0 rgba(0,0,0,0)', '0 18px 32px rgba(0,0,0,0.4)'] }, { duration: 0.6, easing: easingCurves.standard });
  },
  'nav-spotlight': (container, panels) => {
    playMotion(container, { background: ['rgba(78,24,124,0.35)', 'rgba(33,15,49,0.9)'] }, { duration: 0.6, easing: easingCurves.gentle });
  },
  'nav-orbit': (container, panels) => {
    panels.forEach((panel, index) => {
      playMotion(panel, { rotate: [0, index % 2 === 0 ? 6 : -6, 0] }, { duration: 0.6, easing: easingCurves.standard });
    });
  },
};

factoryMap.navigationComplex = (entry) => {
  const container = createEl('div', 'pf-nav-complex');
  const header = createEl('div', 'pf-nav-complex__header', { text: 'PlayFame' });
  const panels = createEl('div', 'pf-nav-complex__panels');
  const panelElements = [];
  for (let i = 0; i < 3; i += 1) {
    const panel = createEl('div', 'pf-nav-complex__panel');
    panels.appendChild(panel);
    panelElements.push(panel);
  }
  container.append(header, panels);

  const play = () => {
    [container, header, ...panelElements].forEach((el) => el.getAnimations().forEach((anim) => anim.cancel()));
    const handler = navigationComplexHandlers[entry.options.style];
    if (handler) {
      handler(container, panelElements);
    }
  };

  return { element: container, play };
};


const layoutShiftHandlers = {
  'grid-reflow': (tiles) => {
    tiles.forEach((tile, index) => {
      playMotion(tile, { transform: ['scale(0.85)', 'scale(1)'] }, { duration: 0.4, easing: easingCurves.entrance, delay: index * 0.05 });
    });
  },
  'filter-flow': (tiles) => {
    tiles.forEach((tile, index) => {
      playMotion(tile, { opacity: [0, 1], translateY: [20, 0] }, { duration: 0.4, easing: easingCurves.standard, delay: index * 0.06 });
    });
  },
  'sort-transition': (tiles) => {
    const first = tiles[0];
    playMotion(first, { translateX: [0, 220], opacity: [1, 0.4] }, { duration: 0.5, easing: easingCurves.standard }).finished?.then(() => {
      const parent = first.parentElement;
      if (parent) {
        parent.appendChild(first);
        playMotion(first, { translateX: [-220, 0], opacity: [0.4, 1] }, { duration: 0.5, easing: easingCurves.standard });
      }
    });
  },
  'responsive-stack': (tiles) => {
    tiles.forEach((tile, index) => {
      playMotion(tile, { translateY: [index * 10, 0], opacity: [0, 1] }, { duration: 0.5, easing: easingCurves.gentle });
    });
  },
  'layout-panels': (tiles) => {
    tiles.forEach((tile, index) => {
      playMotion(tile, { rotate: [0, index % 2 === 0 ? 2 : -2, 0], scale: [1, 1.05, 1] }, { duration: 0.6, easing: easingCurves.gentle });
    });
  },
};

factoryMap.layoutShift = (entry) => {
  const container = createEl('div', 'pf-layout-shift');
  const grid = createEl('div', 'pf-layout-shift__grid');
  const tiles = [];
  for (let i = 0; i < 6; i += 1) {
    const tile = createEl('div', 'pf-layout-shift__tile', { text: `Tile ${i + 1}` });
    grid.appendChild(tile);
    tiles.push(tile);
  }
  container.appendChild(grid);

  const play = () => {
    tiles.forEach((tile) => tile.getAnimations().forEach((anim) => anim.cancel()));
    tiles.forEach((tile, index) => {
      tile.classList.toggle('is-highlighted', false);
    });
    const handler = layoutShiftHandlers[entry.options.style];
    if (handler) {
      handler(tiles);
    }
    tiles[1]?.classList.add('is-highlighted');
  };

  return { element: container, play };
};


const microInteractiveHandlers = {
  'button-hover-glint': (target) => playMotion(target, { boxShadow: ['inset 0 0 0 rgba(236,195,255,0)', 'inset 0 -4px 0 rgba(236,195,255,0.6)', 'inset 0 0 0 rgba(236,195,255,0)'] }, { duration: 0.5, easing: easingCurves.standard }),
  'button-hover-rise': (target) => playMotion(target, { translateY: [0, -6, 0] }, { duration: 0.5, easing: easingCurves.standard }),
  'button-press': (target) => playMotion(target, { scale: [1, 0.94, 1] }, { duration: 0.3, easing: easingCurves.snap }),
  'link-underline-slide': (target) => playMotion(target, { backgroundSize: ['0% 2px', '100% 2px'] }, { duration: 0.4, easing: easingCurves.standard }),
  'link-underline-fade': (target) => playMotion(target, { opacity: [0.4, 1] }, { duration: 0.3, easing: easingCurves.gentle }),
  'input-focus-glow': (target) => playMotion(target.querySelector('input'), { boxShadow: ['0 0 0 rgba(71,255,244,0)', '0 0 0 4px rgba(71,255,244,0.25)', '0 0 0 rgba(71,255,244,0)'] }, { duration: 0.6, easing: easingCurves.gentle }),
  'input-focus-slide': (target) => playMotion(target.querySelector('input'), { translateX: [-10, 0], opacity: [0, 1] }, { duration: 0.4, easing: easingCurves.entrance }),
  'checkbox-check': (target) => playMotion(target, { scale: [1, 1.08, 1] }, { duration: 0.3, easing: easingCurves.pop }),
  'checkbox-bounce': (target) => playMotion(target, { translateY: [0, -4, 0] }, { duration: 0.4, easing: easingCurves.bounce }),
  'radio-fill': (target) => playMotion(target, { boxShadow: ['0 0 0 rgba(198,255,119,0)', '0 0 0 6px rgba(198,255,119,0.18)', '0 0 0 rgba(198,255,119,0)'] }, { duration: 0.5, easing: easingCurves.gentle }),
  'radio-bounce': (target) => playMotion(target, { scale: [1, 1.12, 1] }, { duration: 0.4, easing: easingCurves.pop }),
  'toggle-slide': (target) => playMotion(target, { translateX: [0, 24, 0] }, { duration: 0.4, easing: easingCurves.standard }),
  'toggle-pulse': (target) => playMotion(target, { boxShadow: ['0 0 0 rgba(198,255,119,0.4)', '0 0 0 16px rgba(198,255,119,0)', '0 0 0 rgba(198,255,119,0)'] }, { duration: 0.7, easing: easingCurves.gentle }),
  'tooltip-fade': (target) => playMotion(target, { opacity: [0, 1], translateY: [6, 0] }, { duration: 0.35, easing: easingCurves.standard }),
  'tooltip-pop': (target) => playMotion(target, { scale: [0.8, 1.05, 1] }, { duration: 0.35, easing: easingCurves.pop }),
  'badge-pulse': (target) => playMotion(target, { scale: [1, 1.18, 1] }, { duration: 0.6, easing: easingCurves.gentle }),
  'badge-bounce': (target) => playMotion(target, { translateY: [0, -6, 0] }, { duration: 0.45, easing: easingCurves.bounce }),
  'icon-hover-tilt': (target) => playMotion(target, { rotate: [0, 12, -8, 0] }, { duration: 0.6, easing: easingCurves.standard }),
  'icon-hover-spin': (target) => playMotion(target, { rotate: [0, 360] }, { duration: 0.8, easing: easingCurves.standard }),
  'tab-hover': (target) => playMotion(target, { translateY: [0, -4, 0], boxShadow: ['0 0 0 rgba(236,195,255,0)', '0 6px 12px rgba(0,0,0,0.25)', '0 0 0 rgba(236,195,255,0)'] }, { duration: 0.5, easing: easingCurves.standard }),
};

factoryMap.microInteractive = (entry) => {
  const container = createEl('div', 'pf-micro');
  const button = createEl('button', 'pf-micro__button', { text: 'Interact' });
  const link = createEl('a', 'pf-micro__link', { text: 'Learn more' });
  link.href = '#';
  const inputWrap = createEl('div', 'pf-micro__input');
  inputWrap.appendChild(createEl('input', '', { type: 'text', value: 'PlayFame' }));
  const checkboxWrap = createEl('label', 'pf-micro__checkbox');
  const checkbox = createEl('input', '', { type: 'checkbox' });
  checkboxWrap.append(checkbox, createEl('span', '', { text: 'Subscribe' }));
  const icon = createEl('div', 'pf-micro__icon', { text: '' });

  container.append(button, link, inputWrap, checkboxWrap, icon);

  const play = () => {
    const style = entry.options.style;
    const handler = microInteractiveHandlers[style];
    const target = style.startsWith('button') ? button
      : style.startsWith('link') ? link
      : style.startsWith('input') ? inputWrap
      : style.startsWith('checkbox') || style.startsWith('radio') || style.startsWith('toggle') ? checkboxWrap
      : style.startsWith('icon') || style.startsWith('tab') ? icon
      : style.startsWith('badge') ? button
      : button;

    [button, link, inputWrap, checkboxWrap, icon].forEach((el) => el.getAnimations().forEach((anim) => anim.cancel()));
    if (handler) {
      handler(style.startsWith('badge') ? button : target);
    }
  };

  return { element: container, play };
};


const microStateHandlers = {
  'loading-to-loaded': (card) => playMotion(card, { background: ['rgba(236,195,255,0.08)', 'rgba(71,255,244,0.15)'] }, { duration: 0.5, easing: easingCurves.gentle }),
  'empty-to-populated': (card) => playMotion(card, { opacity: [0.4, 1], transform: ['scale(0.95)', 'scale(1)'] }, { duration: 0.4, easing: easingCurves.entrance }),
  'error-to-success': (card) => playMotion(card, { background: ['rgba(221,23,23,0.25)', 'rgba(17,223,22,0.25)'] }, { duration: 0.6, easing: easingCurves.standard }),
  'enable-disable': (card) => playMotion(card, { filter: ['grayscale(1)', 'grayscale(0)'] }, { duration: 0.4, easing: easingCurves.gentle }),
  'selected-state': (card) => playMotion(card, { boxShadow: ['0 0 0 rgba(198,255,119,0)', '0 0 0 6px rgba(198,255,119,0.28)', '0 0 0 rgba(198,255,119,0)'] }, { duration: 0.6, easing: easingCurves.gentle }),
  'validation-pass': (card) => playMotion(card, { borderColor: ['rgba(236,195,255,0.12)', 'rgba(198,255,119,0.75)', 'rgba(236,195,255,0.12)'] }, { duration: 0.7, easing: easingCurves.gentle }),
  'validation-fail': (card) => playMotion(card, { borderColor: ['rgba(236,195,255,0.12)', 'rgba(221,23,23,0.75)', 'rgba(236,195,255,0.12)'] }, { duration: 0.7, easing: easingCurves.gentle }),
  'tab-change': (card) => playMotion(card, { translateX: [-12, 0], opacity: [0, 1] }, { duration: 0.4, easing: easingCurves.standard }),
  'card-hover': (card) => playMotion(card, { translateY: [0, -12, 0] }, { duration: 0.6, easing: easingCurves.standard }),
  'card-select': (card) => playMotion(card, { scale: [1, 1.04, 1] }, { duration: 0.4, easing: easingCurves.pop }),
  'list-item-activate': (card) => playMotion(card, { background: ['rgba(236,195,255,0.08)', 'rgba(71,255,244,0.18)'] }, { duration: 0.5, easing: easingCurves.standard }),
  'list-item-success': (card) => playMotion(card, { background: ['rgba(17,223,22,0.18)', 'rgba(17,223,22,0.05)'] }, { duration: 0.6, easing: easingCurves.gentle }),
  'chip-entry': (card) => playMotion(card, { transform: ['scale(0.8)', 'scale(1)'], opacity: [0, 1] }, { duration: 0.35, easing: easingCurves.entrance }),
  'chip-exit': (card) => playMotion(card, { transform: ['scale(1)', 'scale(0.6)'], opacity: [1, 0] }, { duration: 0.35, easing: easingCurves.snap }),
  'pill-glow': (card) => playMotion(card, { boxShadow: ['0 0 0 rgba(198,255,119,0)', '0 0 12px rgba(198,255,119,0.6)', '0 0 0 rgba(198,255,119,0)'] }, { duration: 0.6, easing: easingCurves.gentle }),
  'badge-complete': (card) => playMotion(card, { borderColor: ['rgba(236,195,255,0.12)', 'rgba(71,255,244,0.6)', 'rgba(236,195,255,0.12)'] }, { duration: 0.6, easing: easingCurves.gentle }),
  'list-sort': (card) => playMotion(card, { translateY: [0, -18, 0] }, { duration: 0.5, easing: easingCurves.standard }),
  'avatar-online': (card) => playMotion(card, { boxShadow: ['0 0 0 rgba(17,223,22,0.5)', '0 0 20px rgba(17,223,22,0)', '0 0 0 rgba(17,223,22,0)'] }, { duration: 0.8, easing: easingCurves.gentle }),
};

factoryMap.microState = (entry) => {
  const container = createEl('div', 'pf-micro-state');
  const card = createEl('div', 'pf-micro-state__card');
  const status = createEl('div', 'pf-micro-state__status', { text: 'Status' });
  const detail = createEl('p', '', { text: 'State transitions preview for micro-animation catalog.' });
  card.append(status, detail);
  container.appendChild(card);

  const play = () => {
    card.getAnimations().forEach((anim) => anim.cancel());
    const handler = microStateHandlers[entry.options.style];
    if (handler) {
      handler(card);
    }
  };

  return { element: container, play };
};


factoryMap.microAdvanced = (entry) => {
  const container = createEl('div', 'pf-micro-advanced');
  const surface = createEl('div', 'pf-micro-advanced__surface');
  const card = createEl('div', 'pf-micro-advanced__card', { text: formatTitle(entry.options.style) });
  surface.appendChild(card);
  container.appendChild(surface);

  const play = () => {
    card.style.transform = 'translate(0, 0)';
    if (state.reducedMotion) {
      return;
    }
    const style = entry.options.style;
    if (style === 'drag-card' || style === 'drag-snap') {
      playMotion(card, [ { transform: 'translateX(0)' }, { transform: 'translateX(140px)' }, { transform: 'translateX(0)' } ], { duration: 1.2, easing: easingCurves.pop });
    } else if (style === 'swipe-dismiss') {
      playMotion(card, [ { transform: 'translateX(0)', opacity: 1 }, { transform: 'translateX(160px)', opacity: 0 } ], { duration: 0.6, easing: easingCurves.snap });
    } else if (style === 'pull-to-refresh') {
      playMotion(card, [ { transform: 'translateY(0)' }, { transform: 'translateY(60px)' }, { transform: 'translateY(0)' } ], { duration: 1.4, easing: easingCurves.entrance });
    } else if (style === 'long-press') {
      playMotion(card, [ { transform: 'scale(1)' }, { transform: 'scale(0.94)' }, { transform: 'scale(1)' } ], { duration: 0.8, easing: easingCurves.gentle });
    } else if (style === 'pinch-zoom') {
      playMotion(card, [ { transform: 'scale(1)' }, { transform: 'scale(1.2)' }, { transform: 'scale(1)' } ], { duration: 1.2, easing: easingCurves.vibrant });
    } else if (style === 'magnetic-hover') {
      playMotion(card, [ { transform: 'translate(0,0)' }, { transform: 'translate(12px,-12px)' }, { transform: 'translate(0,0)' } ], { duration: 1, easing: easingCurves.bounce });
    }
  };

  return { element: container, play };
};


factoryMap.dataBasic = (entry) => {
  const style = entry.options.style;
  const container = createEl('div', 'pf-data-basic');
  const chart = createEl('div', 'pf-chart');
  let elements = [];

  const build = () => {
    chart.innerHTML = '';
    if (style.startsWith('bar-chart')) {
      for (let i = 0; i < 5; i += 1) {
        const bar = createEl('div', 'pf-chart__bar');
        chart.appendChild(bar);
        elements.push(bar);
      }
    } else if (style.startsWith('line-chart')) {
      const lineWrapper = createEl('div', 'pf-chart__line');
      lineWrapper.innerHTML = '<svg viewBox="0 0 100 40"><polyline points="0,35 20,25 40,30 60,18 80,26 100,15" /></svg>';
      chart.appendChild(lineWrapper);
      elements.push(lineWrapper.querySelector('polyline'));
    } else if (style.startsWith('pie-chart')) {
      const pie = createEl('div', 'pf-chart__pie');
      pie.innerHTML = '<svg viewBox="0 0 32 32" class="pf-chart__pie-svg"><circle r="16" cx="16" cy="16" class="pf-chart__pie-track"></circle><circle r="16" cx="16" cy="16" class="pf-chart__pie-value"></circle></svg>';
      chart.appendChild(pie);
      elements.push(pie.querySelector('.pf-chart__pie-value'));
    } else if (style === 'stat-count' || style === 'stat-flip' || style === 'delta-glow') {
      const stat = createEl('div', 'pf-chart__stat', { text: '12,540' });
      chart.appendChild(stat);
      elements.push(stat);
    } else if (style === 'rank-slide' || style === 'trend-highlight' || style === 'gauge-sweep') {
      for (let i = 0; i < 4; i += 1) {
        const block = createEl('div', 'pf-chart__block');
        block.style.height = `${40 + i * 12}px`;
        chart.appendChild(block);
        elements.push(block);
      }
    }
  };

  build();
  container.appendChild(chart);

  const play = () => {
    elements.forEach((el) => el.getAnimations().forEach((anim) => anim.cancel()));
    if (style === 'bar-chart-rise') {
      elements.forEach((bar, index) => {
        const height = 30 + index * 18;
        playMotion(bar, { height: ['12px', `${height}px`], opacity: [0.3, 1] }, { duration: 0.45 + index * 0.08, easing: easingCurves.entrance });
      });
    } else if (style === 'bar-chart-stack') {
      elements.forEach((bar, index) => {
        playMotion(bar, { transform: ['translateY(20px)', 'translateY(0)'], opacity: [0, 1] }, { duration: 0.5, easing: easingCurves.standard, delay: index * 0.08 });
      });
    } else if (style === 'line-chart-draw' || style === 'line-chart-dash') {
      const polyline = elements[0];
      if (polyline) {
        const length = polyline.getTotalLength();
        polyline.style.strokeDasharray = length;
        polyline.style.strokeDashoffset = length;
        playMotion(polyline, { strokeDashoffset: [length, 0] }, { duration: 0.8, easing: easingCurves.standard });
      }
    } else if (style === 'pie-chart-slice' || style === 'pie-chart-rotate') {
      const circle = elements[0];
      if (circle) {
        playMotion(circle, { strokeDashoffset: [100, 0] }, { duration: 0.8, easing: easingCurves.gentle });
        if (style === 'pie-chart-rotate') {
          playMotion(circle, { rotate: [0, 90] }, { duration: 0.8, easing: easingCurves.standard });
        }
      }
    } else if (style === 'stat-count') {
      numberTween(2000, 12540, 700, (val) => { elements[0].textContent = Math.round(val).toLocaleString(); });
    } else if (style === 'stat-flip') {
      numberTween(2500, 8250, 700, (val) => { elements[0].textContent = Math.round(val).toLocaleString(); });
      playMotion(elements[0], { rotateX: [0, -180, -360] }, { duration: 0.6, easing: easingCurves.snap });
    } else if (style === 'delta-glow') {
      playMotion(elements[0], { textShadow: ['0 0 0 rgba(198,255,119,0)', '0 0 24px rgba(198,255,119,0.5)', '0 0 0 rgba(198,255,119,0)'] }, { duration: 1, easing: easingCurves.gentle });
    } else if (style === 'rank-slide') {
      elements.forEach((block, index) => {
        playMotion(block, { translateY: [20, 0], opacity: [0, 1] }, { duration: 0.45, easing: easingCurves.entrance, delay: index * 0.08 });
      });
    } else if (style === 'trend-highlight') {
      elements.forEach((block, index) => {
        playMotion(block, { filter: ['brightness(1)', 'brightness(1.3)', 'brightness(1)'] }, { duration: 0.6, easing: easingCurves.gentle, delay: index * 0.1 });
      });
    } else if (style === 'gauge-sweep') {
      elements.forEach((block) => {
        playMotion(block, { width: ['30%', '100%'] }, { duration: 0.6, easing: easingCurves.standard });
      });
    }
  };

  return { element: container, play };
};


const dataInteractiveHandlers = {
  'tournament-bracket': (stage) => {
    stage.innerHTML = '';
    for (let i = 0; i < 3; i += 1) {
      const bracket = createEl('div', 'pf-data-interactive__bracket');
      stage.appendChild(bracket);
      playMotion(bracket, { transform: ['scaleX(0)', 'scaleX(1)'] }, { duration: 0.5, easing: easingCurves.entrance, delay: i * 0.1 });
    }
  },
  'heat-map': (stage) => {
    stage.innerHTML = '';
    for (let i = 0; i < 12; i += 1) {
      const cell = createEl('div', 'pf-data-interactive__cell');
      stage.appendChild(cell);
      playMotion(cell, { backgroundColor: ['rgba(200,53,88,0.2)', 'rgba(198,255,119,0.6)'] }, { duration: 0.6, easing: easingCurves.gentle, delay: i * 0.05 });
    }
  },
  'network-graph': (stage) => {
    stage.innerHTML = '';
    for (let i = 0; i < 6; i += 1) {
      const node = createEl('div', 'pf-data-interactive__node');
      stage.appendChild(node);
      playMotion(node, { transform: ['scale(0.4)', 'scale(1)'], opacity: [0, 1] }, { duration: 0.4, easing: easingCurves.entrance, delay: i * 0.05 });
    }
  },
  'comparison-charts': (stage) => {
    stage.innerHTML = '';
    for (let i = 0; i < 6; i += 1) {
      const block = createEl('div', 'pf-data-interactive__block');
      stage.appendChild(block);
      playMotion(block, { height: ['12px', `${24 + i * 8}px`] }, { duration: 0.4, easing: easingCurves.entrance });
    }
  },
  'live-stream': (stage) => {
    stage.innerHTML = '';
    const stream = createEl('div', 'pf-data-interactive__stream');
    stage.appendChild(stream);
    playMotion(stream, { transform: ['translateY(40px)', 'translateY(-40px)'] }, { duration: 2, easing: 'linear' });
  },
  'radar-sweep': (stage) => {
    stage.innerHTML = '';
    const radar = createEl('div', 'pf-data-interactive__radar');
    stage.appendChild(radar);
    playMotion(radar, { rotate: [0, 360] }, { duration: 2, easing: 'linear' });
  },
  'bracket-highlight': (stage) => {
    stage.innerHTML = '';
    for (let i = 0; i < 3; i += 1) {
      const bracket = createEl('div', 'pf-data-interactive__bracket pf-data-interactive__bracket--highlight');
      stage.appendChild(bracket);
      playMotion(bracket, { background: ['rgba(71,255,244,0.1)', 'rgba(71,255,244,0.5)', 'rgba(71,255,244,0.1)'] }, { duration: 0.7, easing: easingCurves.gentle, delay: i * 0.12 });
    }
  },
  'scoreboard-update': (stage) => {
    stage.innerHTML = '';
    for (let i = 0; i < 4; i += 1) {
      const row = createEl('div', 'pf-data-interactive__score');
      row.textContent = `${1000 + i * 320}`;
      stage.appendChild(row);
      playMotion(row, { translateX: [-30, 0], opacity: [0, 1] }, { duration: 0.4, easing: easingCurves.entrance, delay: i * 0.1 });
    }
  },
  'payout-curve': (stage) => {
    stage.innerHTML = '';
    const curve = createEl('div', 'pf-data-interactive__curve');
    curve.innerHTML = '<svg viewBox="0 0 100 40"><path d="M0,35 Q40,10 100,15" /></svg>';
    stage.appendChild(curve);
    const path = curve.querySelector('path');
    if (path) {
      const length = path.getTotalLength();
      path.style.strokeDasharray = length;
      path.style.strokeDashoffset = length;
      playMotion(path, { strokeDashoffset: [length, 0] }, { duration: 0.8, easing: easingCurves.standard });
    }
  },
  'victory-flash': (stage) => {
    stage.innerHTML = '';
    const flash = createEl('div', 'pf-data-interactive__flash');
    stage.appendChild(flash);
    playMotion(flash, { opacity: [0, 1, 0] }, { duration: 0.5, easing: easingCurves.vibrant });
  },
  'combo-surge': (stage) => {
    stage.innerHTML = '';
    for (let i = 0; i < 5; i += 1) {
      const surge = createEl('div', 'pf-data-interactive__surge');
      stage.appendChild(surge);
      playMotion(surge, { height: ['0%', `${40 + i * 12}%`], opacity: [0, 1] }, { duration: 0.4, easing: easingCurves.entrance, delay: i * 0.08 });
    }
  },
  'tier-ladder': (stage) => {
    stage.innerHTML = '';
    for (let i = 0; i < 5; i += 1) {
      const rung = createEl('div', 'pf-data-interactive__rung');
      stage.appendChild(rung);
      playMotion(rung, { translateY: [10, 0], opacity: [0, 1] }, { duration: 0.4, easing: easingCurves.standard, delay: i * 0.08 });
    }
  },
  'performance-loop': (stage) => {
    stage.innerHTML = '';
    const loop = createEl('div', 'pf-data-interactive__loop');
    stage.appendChild(loop);
    playMotion(loop, { rotate: [0, 360] }, { duration: 2.4, easing: 'linear' });
  },
};
factoryMap.dataInteractive = (entry) => {
  const container = createEl('div', 'pf-data-interactive');
  const stage = createEl('div', 'pf-data-interactive__stage');
  container.appendChild(stage);

  const play = () => {
    stage.getAnimations().forEach((anim) => anim.cancel());
    const handler = dataInteractiveHandlers[entry.options.style];
    if (handler) {
      handler(stage);
    }
  };

  return { element: container, play };
};


const ambientBaseConfigs = {
  'gradient-shift': (layer) => {
    layer.style.background = 'linear-gradient(120deg, rgba(71,255,244,0.25), rgba(200,53,88,0.15))';
  },
  'floating-particles': (layer) => {
    layer.innerHTML = '';
    for (let i = 0; i < 6; i += 1) {
      const particle = createEl('span', 'pf-ambient__particle');
      particle.style.left = `${randBetween(10, 90)}%`;
      particle.style.top = `${randBetween(10, 90)}%`;
      layer.appendChild(particle);
      playMotion(particle, { translateY: [0, -14, 0] }, { duration: 2.4, easing: easingCurves.gentle, delay: i * 0.1 });
    }
  },
  'parallax-layers': (layer) => {
    layer.innerHTML = '';
    for (let i = 0; i < 3; i += 1) {
      const band = createEl('span', 'pf-ambient__band');
      band.style.top = `${i * 30}%`;
      layer.appendChild(band);
      playMotion(band, { translateX: [i % 2 === 0 ? -20 : 20, 0] }, { duration: 1.6, easing: easingCurves.gentle });
    }
  },
  'ken-burns': (layer) => {
    layer.style.backgroundImage = 'url(https://storage.googleapis.com/www.playfame.com/images/hero-streamers-bg.jpg)';
    layer.style.backgroundSize = '120%';
    playMotion(layer, { backgroundPosition: ['0% 0%', '50% 50%'] }, { duration: 2.4, easing: easingCurves.gentle });
  },
  'ambient-glow': (layer) => {
    layer.style.background = 'radial-gradient(circle at 50% 50%, rgba(236,195,255,0.35), rgba(236,195,255,0))';
    playMotion(layer, { opacity: [0.2, 0.8, 0.2] }, { duration: 2, easing: easingCurves.gentle });
  },
  'ambient-aurora': (layer) => {
    layer.style.background = 'linear-gradient(135deg, rgba(71,255,244,0.3), rgba(200,53,88,0.2))';
    playMotion(layer, { backgroundPosition: ['0% 0%', '100% 100%'] }, { duration: 3, easing: easingCurves.gentle });
  },
};

factoryMap.ambientBase = (entry) => {
  const container = createEl('div', 'pf-ambient');
  const layer = createEl('div', 'pf-ambient__layer');
  container.appendChild(layer);

  const play = () => {
    layer.getAnimations().forEach((anim) => anim.cancel());
    layer.innerHTML = '';
    layer.style.background = 'transparent';
    layer.style.removeProperty('background-image');
    const handler = ambientBaseConfigs[entry.options.style];
    if (handler) handler(layer);
  };

  return { element: container, play };
};

const ambientAdvancedConfigs = {
  'confetti-loop': () => ['#ff5981', '#c6ff77', '#47fff4'],
  'snowfall': () => ['rgba(255,255,255,0.9)'],
  'rainfall': () => ['rgba(71,255,244,0.6)'],
  'fireworks-grand': () => ['#ffce1a', '#ff5981'],
  'magic-sparkles': () => ['#ecc3ff', '#c6ff77'],
  'portal-rings': () => ['#47fff4'],
  'light-rays': () => ['rgba(198,255,119,0.5)'],
  'smoke-plumes': () => ['rgba(236,195,255,0.2)'],
  'water-ripples': () => ['rgba(71,255,244,0.4)'],
  'fire-lift': () => ['#ffb300', '#f57c00'],
  'spark-trail': () => ['#ff5981'],
  'nebula-swell': () => ['#c47ae5', '#47fff4'],
  'energy-orbit': () => ['#c6ff77', '#ff5981'],
  'stardust': () => ['#ecc3ff'],
  'aura-pulse': () => ['rgba(198,255,119,0.6)'],
  'galaxy-spiral': () => ['#47fff4', '#c47ae5'],
};

factoryMap.ambientAdvanced = (entry) => {
  const container = createEl('div', 'pf-ambient pf-ambient--advanced');
  const layer = createEl('div', 'pf-ambient__layer');
  container.appendChild(layer);

  const play = () => {
    clearChildren(layer);
    const colors = ambientAdvancedConfigs[entry.options.style]?.() || ['#ecc3ff'];
    if (state.reducedMotion) {
      const particle = createEl('span', 'pf-ambient__particle');
      particle.style.background = colors[0];
      layer.appendChild(particle);
      return;
    }
    const total = 18;
    for (let i = 0; i < total; i += 1) {
      const particle = createEl('span', 'pf-ambient__particle');
      particle.style.background = colors[i % colors.length];
      layer.appendChild(particle);
      const x = randBetween(-80, 80);
      const y = randBetween(-60, 60);
      playMotion(particle, {
        transform: [`translate(${x}px, ${y}px) scale(0.4)`, `translate(${x * 1.2}px, ${y * 1.4}px) scale(1)`, `translate(${x * 1.4}px, ${y * -0.8}px) scale(0.2)`],
        opacity: [0, 0.9, 0],
      }, { duration: (entry.options.duration || durations.xxl) / 1000, easing: easingCurves.gentle, delay: i * 0.08 });
    }
  };

  return { element: container, play };
};


const catalogRoot = document.querySelector('[data-role="catalog"]');
const sidebarNavRoot = document.querySelector('[data-role="sidebar-nav"]');
const playAllButton = document.querySelector('[data-role="play-all"]');
const reducedMotionToggle = document.querySelector('[data-role="reduced-motion"]');
const techFilterButtons = Array.from(document.querySelectorAll('.pf-chip[data-tech]'));

document.body.toggleAttribute('data-reduced-motion', state.reducedMotion);
if (reducedMotionToggle) {
  reducedMotionToggle.checked = state.reducedMotion;
}

const { categories, entries } = createCatalogData();

const renderSidebar = () => {
  if (!sidebarNavRoot) return;
  clearChildren(sidebarNavRoot);
  categories.forEach((category) => {
    const section = createEl('div', 'pf-sidebar__section');
    section.appendChild(createEl('div', 'pf-sidebar__section-title', { text: category.title }));
    category.groups.forEach((group) => {
      const link = createEl('button', 'pf-sidebar__link', { text: `${group.title} (${group.count})` });
      link.dataset.target = group.id;
      link.addEventListener('click', () => {
        const target = document.getElementById(group.id);
        if (target) {
          target.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      });
      section.appendChild(link);
    });
    sidebarNavRoot.appendChild(section);
  });
};

const renderCatalog = () => {
  clearChildren(catalogRoot);
  const observer = new IntersectionObserver((entriesObserved) => {
    entriesObserved.forEach((entryObserved) => {
      if (entryObserved.isIntersecting) {
        const playableId = entryObserved.target.dataset.cardId;
        const playable = state.playables.get(playableId);
        if (playable && !playable.initialized) {
          playable.play();
          playable.initialized = true;
        }
      }
    });
  }, { rootMargin: '80px 0px', threshold: 0.3 });

  categories.forEach((category) => {
    const categoryEl = createEl('section', 'pf-category');
    categoryEl.id = category.id;
    const header = createEl('div', 'pf-category__header');
    const title = createEl('h2', 'pf-category__title', { text: category.title });
    const meta = createEl('div', 'pf-category__meta');
    const count = category.groups.reduce((acc, group) => acc + group.count, 0);    header.append(title, meta);
    categoryEl.appendChild(header);

    category.groups.forEach((group) => {
      const groupEl = createEl('div', 'pf-group');
      groupEl.id = group.id;
      const groupHeader = createEl('div', 'pf-group__header');
      groupHeader.appendChild(createEl('h3', 'pf-group__title', { text: `${group.title} (${group.count})` }));
      groupEl.appendChild(groupHeader);
      const grid = createEl('div', 'pf-card-grid');
      group.variants.forEach((variant) => {
        const card = createEl('article', 'pf-card');
        card.dataset.tech = variant.tech;
        card.dataset.cardId = variant.id;
        const cardHeader = createEl('div', 'pf-card__header');
        cardHeader.appendChild(createEl('div', 'pf-card__title', { text: variant.title }));        if (variant.easingLabel) {        }
        card.appendChild(cardHeader);

        card.appendChild(createEl('p', 'pf-card__description', { text: variant.description }));

        const canvas = createEl('div', 'pf-demo-canvas');
        canvas.dataset.demo = variant.demo;
        let play = () => {};
        try {
          const factory = factoryMap[variant.demo];
          if (factory) {
            const demo = factory(variant);
            if (demo && demo.element) {
              const stage = createEl('div', 'pf-demo-stage');
              if (demo.align === 'top') stage.classList.add('pf-demo-stage--top');
              if (demo.stageClass) stage.classList.add(demo.stageClass);
              if (demo.height) {
                stage.style.setProperty('--pf-demo-height', demo.height);
                canvas.style.setProperty('--pf-demo-height', demo.height);
              } else {
                stage.style.removeProperty('--pf-demo-height');
                canvas.style.removeProperty('--pf-demo-height');
              }
              stage.appendChild(demo.element);
              canvas.appendChild(stage);
              play = demo.play || (() => {});
            } else {
              canvas.appendChild(createEl('div', 'pf-demo-placeholder', { text: 'Demo not available' }));
            }
          } else {
            canvas.appendChild(createEl('div', 'pf-demo-placeholder', { text: 'Demo not available' }));
          }
        } catch (error) {
          console.error('Failed to initialize variant', variant.id, error);
          canvas.appendChild(createEl('div', 'pf-demo-placeholder', { text: 'Demo error' }));
        }

        card.appendChild(canvas);

        const actions = createEl('div', 'pf-card__actions');
        const techBadge = createEl('span', 'pf-badge-tech', { text: variant.tech === 'css' ? 'CSS' : 'Framer Motion' });
        const controls = createEl('div', 'pf-card__controls');
        const playButton = createEl('button', '', { text: 'Replay' });
        playButton.dataset.role = 'play-card';
        playButton.addEventListener('click', () => play());
        controls.appendChild(playButton);
        actions.append(techBadge, controls);
        card.appendChild(actions);

        grid.appendChild(card);
        observer.observe(card);
        state.playables.set(variant.id, { play, entry: variant, card, canvas, initialized: false });
        state.cards.set(variant.id, card);
      });
      groupEl.appendChild(grid);
      categoryEl.appendChild(groupEl);
    });

    catalogRoot.appendChild(categoryEl);
  });
};

renderSidebar();
renderCatalog();

const applyTechFilter = (tech) => {
  state.techFilter = tech;
  state.cards.forEach((card, id) => {
    if (tech === 'all') {
      card.style.display = '';
    } else {
      card.style.display = card.dataset.tech === tech ? '' : 'none';
    }
  });
};

techFilterButtons.forEach((button) => {
  button.addEventListener('click', () => {
    techFilterButtons.forEach((btn) => btn.classList.remove('pf-chip--active'));
    button.classList.add('pf-chip--active');
    applyTechFilter(button.dataset.tech);
  });
});

if (playAllButton) {
  playAllButton.addEventListener('click', () => {
    state.playables.forEach(({ play }) => play());
  });
}

if (reducedMotionToggle) {
  reducedMotionToggle.addEventListener('change', (event) => {
    state.reducedMotion = event.target.checked;
    document.body.toggleAttribute('data-reduced-motion', state.reducedMotion);
    state.playables.forEach(({ play }) => play());
  });
}
  </script>
</body>
</html>
